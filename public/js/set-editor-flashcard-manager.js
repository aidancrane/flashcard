/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 2);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/dompurify/dist/purify.js":
/*!***********************************************!*\
  !*** ./node_modules/dompurify/dist/purify.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*! @license DOMPurify | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.2.2/LICENSE */\n\n(function (global, factory) {\n   true ? module.exports = factory() :\n  undefined;\n}(this, function () { 'use strict';\n\n  function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n  var hasOwnProperty = Object.hasOwnProperty,\n      setPrototypeOf = Object.setPrototypeOf,\n      isFrozen = Object.isFrozen,\n      getPrototypeOf = Object.getPrototypeOf,\n      getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n  var freeze = Object.freeze,\n      seal = Object.seal,\n      create = Object.create; // eslint-disable-line import/no-mutable-exports\n\n  var _ref = typeof Reflect !== 'undefined' && Reflect,\n      apply = _ref.apply,\n      construct = _ref.construct;\n\n  if (!apply) {\n    apply = function apply(fun, thisValue, args) {\n      return fun.apply(thisValue, args);\n    };\n  }\n\n  if (!freeze) {\n    freeze = function freeze(x) {\n      return x;\n    };\n  }\n\n  if (!seal) {\n    seal = function seal(x) {\n      return x;\n    };\n  }\n\n  if (!construct) {\n    construct = function construct(Func, args) {\n      return new (Function.prototype.bind.apply(Func, [null].concat(_toConsumableArray(args))))();\n    };\n  }\n\n  var arrayForEach = unapply(Array.prototype.forEach);\n  var arrayPop = unapply(Array.prototype.pop);\n  var arrayPush = unapply(Array.prototype.push);\n\n  var stringToLowerCase = unapply(String.prototype.toLowerCase);\n  var stringMatch = unapply(String.prototype.match);\n  var stringReplace = unapply(String.prototype.replace);\n  var stringIndexOf = unapply(String.prototype.indexOf);\n  var stringTrim = unapply(String.prototype.trim);\n\n  var regExpTest = unapply(RegExp.prototype.test);\n\n  var typeErrorCreate = unconstruct(TypeError);\n\n  function unapply(func) {\n    return function (thisArg) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      return apply(func, thisArg, args);\n    };\n  }\n\n  function unconstruct(func) {\n    return function () {\n      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return construct(func, args);\n    };\n  }\n\n  /* Add properties to a lookup table */\n  function addToSet(set, array) {\n    if (setPrototypeOf) {\n      // Make 'in' and truthy checks like Boolean(set.constructor)\n      // independent of any properties defined on Object.prototype.\n      // Prevent prototype setters from intercepting set as a this value.\n      setPrototypeOf(set, null);\n    }\n\n    var l = array.length;\n    while (l--) {\n      var element = array[l];\n      if (typeof element === 'string') {\n        var lcElement = stringToLowerCase(element);\n        if (lcElement !== element) {\n          // Config presets (e.g. tags.js, attrs.js) are immutable.\n          if (!isFrozen(array)) {\n            array[l] = lcElement;\n          }\n\n          element = lcElement;\n        }\n      }\n\n      set[element] = true;\n    }\n\n    return set;\n  }\n\n  /* Shallow clone an object */\n  function clone(object) {\n    var newObject = create(null);\n\n    var property = void 0;\n    for (property in object) {\n      if (apply(hasOwnProperty, object, [property])) {\n        newObject[property] = object[property];\n      }\n    }\n\n    return newObject;\n  }\n\n  /* IE10 doesn't support __lookupGetter__ so lets'\n   * simulate it. It also automatically checks\n   * if the prop is function or getter and behaves\n   * accordingly. */\n  function lookupGetter(object, prop) {\n    while (object !== null) {\n      var desc = getOwnPropertyDescriptor(object, prop);\n      if (desc) {\n        if (desc.get) {\n          return unapply(desc.get);\n        }\n\n        if (typeof desc.value === 'function') {\n          return unapply(desc.value);\n        }\n      }\n\n      object = getPrototypeOf(object);\n    }\n\n    return null;\n  }\n\n  var html = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);\n\n  // SVG\n  var svg = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);\n\n  var svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);\n\n  // List of SVG elements that are disallowed by default.\n  // We still need to know them so that we can do namespace\n  // checks properly in case one wants to add them to\n  // allow-list.\n  var svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'fedropshadow', 'feimage', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);\n\n  var mathMl = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover']);\n\n  // Similarly to SVG, we want to know all MathML elements,\n  // even those that we disallow by default.\n  var mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);\n\n  var text = freeze(['#text']);\n\n  var html$1 = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns']);\n\n  var svg$1 = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'targetx', 'targety', 'transform', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\n\n  var mathMl$1 = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\n\n  var xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);\n\n  // eslint-disable-next-line unicorn/better-regex\n  var MUSTACHE_EXPR = seal(/\\{\\{[\\s\\S]*|[\\s\\S]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\n  var ERB_EXPR = seal(/<%[\\s\\S]*|[\\s\\S]*%>/gm);\n  var DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/); // eslint-disable-line no-useless-escape\n  var ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\n  var IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n  );\n  var IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n  var ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n  );\n\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n  function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n  var getGlobal = function getGlobal() {\n    return typeof window === 'undefined' ? null : window;\n  };\n\n  /**\n   * Creates a no-op policy for internal use only.\n   * Don't export this function outside this module!\n   * @param {?TrustedTypePolicyFactory} trustedTypes The policy factory.\n   * @param {Document} document The document object (to determine policy name suffix)\n   * @return {?TrustedTypePolicy} The policy created (or null, if Trusted Types\n   * are not supported).\n   */\n  var _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, document) {\n    if ((typeof trustedTypes === 'undefined' ? 'undefined' : _typeof(trustedTypes)) !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n      return null;\n    }\n\n    // Allow the callers to control the unique policy name\n    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n    // Policy creation with duplicate names throws in Trusted Types.\n    var suffix = null;\n    var ATTR_NAME = 'data-tt-policy-suffix';\n    if (document.currentScript && document.currentScript.hasAttribute(ATTR_NAME)) {\n      suffix = document.currentScript.getAttribute(ATTR_NAME);\n    }\n\n    var policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n\n    try {\n      return trustedTypes.createPolicy(policyName, {\n        createHTML: function createHTML(html$$1) {\n          return html$$1;\n        }\n      });\n    } catch (_) {\n      // Policy creation failed (most likely another DOMPurify script has\n      // already run). Skip creating the policy, as this will only cause errors\n      // if TT are enforced.\n      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n      return null;\n    }\n  };\n\n  function createDOMPurify() {\n    var window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n\n    var DOMPurify = function DOMPurify(root) {\n      return createDOMPurify(root);\n    };\n\n    /**\n     * Version label, exposed for easier checks\n     * if DOMPurify is up to date or not\n     */\n    DOMPurify.version = '2.2.6';\n\n    /**\n     * Array of elements that DOMPurify removed during sanitation.\n     * Empty if nothing was removed.\n     */\n    DOMPurify.removed = [];\n\n    if (!window || !window.document || window.document.nodeType !== 9) {\n      // Not running in a browser, provide a factory function\n      // so that you can pass your own Window\n      DOMPurify.isSupported = false;\n\n      return DOMPurify;\n    }\n\n    var originalDocument = window.document;\n\n    var document = window.document;\n    var DocumentFragment = window.DocumentFragment,\n        HTMLTemplateElement = window.HTMLTemplateElement,\n        Node = window.Node,\n        Element = window.Element,\n        NodeFilter = window.NodeFilter,\n        _window$NamedNodeMap = window.NamedNodeMap,\n        NamedNodeMap = _window$NamedNodeMap === undefined ? window.NamedNodeMap || window.MozNamedAttrMap : _window$NamedNodeMap,\n        Text = window.Text,\n        Comment = window.Comment,\n        DOMParser = window.DOMParser,\n        trustedTypes = window.trustedTypes;\n\n\n    var ElementPrototype = Element.prototype;\n\n    var cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n    var getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n    var getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n    var getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n\n    // As per issue #47, the web-components registry is inherited by a\n    // new document created via createHTMLDocument. As per the spec\n    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n    // a new empty registry is used when creating a template contents owner\n    // document, so we use that as our parent document to ensure nothing\n    // is inherited.\n    if (typeof HTMLTemplateElement === 'function') {\n      var template = document.createElement('template');\n      if (template.content && template.content.ownerDocument) {\n        document = template.content.ownerDocument;\n      }\n    }\n\n    var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);\n    var emptyHTML = trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML('') : '';\n\n    var _document = document,\n        implementation = _document.implementation,\n        createNodeIterator = _document.createNodeIterator,\n        getElementsByTagName = _document.getElementsByTagName,\n        createDocumentFragment = _document.createDocumentFragment;\n    var importNode = originalDocument.importNode;\n\n\n    var documentMode = {};\n    try {\n      documentMode = clone(document).documentMode ? document.documentMode : {};\n    } catch (_) {}\n\n    var hooks = {};\n\n    /**\n     * Expose whether this browser supports running the full DOMPurify.\n     */\n    DOMPurify.isSupported = implementation && typeof implementation.createHTMLDocument !== 'undefined' && documentMode !== 9;\n\n    var MUSTACHE_EXPR$$1 = MUSTACHE_EXPR,\n        ERB_EXPR$$1 = ERB_EXPR,\n        DATA_ATTR$$1 = DATA_ATTR,\n        ARIA_ATTR$$1 = ARIA_ATTR,\n        IS_SCRIPT_OR_DATA$$1 = IS_SCRIPT_OR_DATA,\n        ATTR_WHITESPACE$$1 = ATTR_WHITESPACE;\n    var IS_ALLOWED_URI$$1 = IS_ALLOWED_URI;\n\n    /**\n     * We consider the elements and attributes below to be safe. Ideally\n     * don't add any new ones but feel free to remove unwanted ones.\n     */\n\n    /* allowed element names */\n\n    var ALLOWED_TAGS = null;\n    var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(html), _toConsumableArray$1(svg), _toConsumableArray$1(svgFilters), _toConsumableArray$1(mathMl), _toConsumableArray$1(text)));\n\n    /* Allowed attribute names */\n    var ALLOWED_ATTR = null;\n    var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray$1(html$1), _toConsumableArray$1(svg$1), _toConsumableArray$1(mathMl$1), _toConsumableArray$1(xml)));\n\n    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n    var FORBID_TAGS = null;\n\n    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n    var FORBID_ATTR = null;\n\n    /* Decide if ARIA attributes are okay */\n    var ALLOW_ARIA_ATTR = true;\n\n    /* Decide if custom data attributes are okay */\n    var ALLOW_DATA_ATTR = true;\n\n    /* Decide if unknown protocols are okay */\n    var ALLOW_UNKNOWN_PROTOCOLS = false;\n\n    /* Output should be safe for common template engines.\n     * This means, DOMPurify removes data attributes, mustaches and ERB\n     */\n    var SAFE_FOR_TEMPLATES = false;\n\n    /* Decide if document with <html>... should be returned */\n    var WHOLE_DOCUMENT = false;\n\n    /* Track whether config is already set on this instance of DOMPurify. */\n    var SET_CONFIG = false;\n\n    /* Decide if all elements (e.g. style, script) must be children of\n     * document.body. By default, browsers might move them to document.head */\n    var FORCE_BODY = false;\n\n    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n     * string (or a TrustedHTML object if Trusted Types are supported).\n     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n     */\n    var RETURN_DOM = false;\n\n    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n     * string  (or a TrustedHTML object if Trusted Types are supported) */\n    var RETURN_DOM_FRAGMENT = false;\n\n    /* If `RETURN_DOM` or `RETURN_DOM_FRAGMENT` is enabled, decide if the returned DOM\n     * `Node` is imported into the current `Document`. If this flag is not enabled the\n     * `Node` will belong (its ownerDocument) to a fresh `HTMLDocument`, created by\n     * DOMPurify.\n     *\n     * This defaults to `true` starting DOMPurify 2.2.0. Note that setting it to `false`\n     * might cause XSS from attacks hidden in closed shadowroots in case the browser\n     * supports Declarative Shadow: DOM https://web.dev/declarative-shadow-dom/\n     */\n    var RETURN_DOM_IMPORT = true;\n\n    /* Try to return a Trusted Type object instead of a string, return a string in\n     * case Trusted Types are not supported  */\n    var RETURN_TRUSTED_TYPE = false;\n\n    /* Output should be free from DOM clobbering attacks? */\n    var SANITIZE_DOM = true;\n\n    /* Keep element content when removing element? */\n    var KEEP_CONTENT = true;\n\n    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n     * of importing it into a new Document and returning a sanitized copy */\n    var IN_PLACE = false;\n\n    /* Allow usage of profiles like html, svg and mathMl */\n    var USE_PROFILES = {};\n\n    /* Tags to ignore content of when KEEP_CONTENT is true */\n    var FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);\n\n    /* Tags that are safe for data: URIs */\n    var DATA_URI_TAGS = null;\n    var DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);\n\n    /* Attributes safe for values like \"javascript:\" */\n    var URI_SAFE_ATTRIBUTES = null;\n    var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'summary', 'title', 'value', 'style', 'xmlns']);\n\n    /* Keep a reference to config to pass to hooks */\n    var CONFIG = null;\n\n    /* Ideally, do not touch anything below this line */\n    /* ______________________________________________ */\n\n    var formElement = document.createElement('form');\n\n    /**\n     * _parseConfig\n     *\n     * @param  {Object} cfg optional config literal\n     */\n    // eslint-disable-next-line complexity\n    var _parseConfig = function _parseConfig(cfg) {\n      if (CONFIG && CONFIG === cfg) {\n        return;\n      }\n\n      /* Shield configuration object from tampering */\n      if (!cfg || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) !== 'object') {\n        cfg = {};\n      }\n\n      /* Shield configuration object from prototype pollution */\n      cfg = clone(cfg);\n\n      /* Set configuration parameters */\n      ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS) : DEFAULT_ALLOWED_TAGS;\n      ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR) : DEFAULT_ALLOWED_ATTR;\n      URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR) : DEFAULT_URI_SAFE_ATTRIBUTES;\n      DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS) : DEFAULT_DATA_URI_TAGS;\n      FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS) : {};\n      FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR) : {};\n      USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n      RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n      RETURN_DOM_IMPORT = cfg.RETURN_DOM_IMPORT !== false; // Default true\n      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n      FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n      IN_PLACE = cfg.IN_PLACE || false; // Default false\n      IS_ALLOWED_URI$$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$$1;\n      if (SAFE_FOR_TEMPLATES) {\n        ALLOW_DATA_ATTR = false;\n      }\n\n      if (RETURN_DOM_FRAGMENT) {\n        RETURN_DOM = true;\n      }\n\n      /* Parse profile info */\n      if (USE_PROFILES) {\n        ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray$1(text)));\n        ALLOWED_ATTR = [];\n        if (USE_PROFILES.html === true) {\n          addToSet(ALLOWED_TAGS, html);\n          addToSet(ALLOWED_ATTR, html$1);\n        }\n\n        if (USE_PROFILES.svg === true) {\n          addToSet(ALLOWED_TAGS, svg);\n          addToSet(ALLOWED_ATTR, svg$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.svgFilters === true) {\n          addToSet(ALLOWED_TAGS, svgFilters);\n          addToSet(ALLOWED_ATTR, svg$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n\n        if (USE_PROFILES.mathMl === true) {\n          addToSet(ALLOWED_TAGS, mathMl);\n          addToSet(ALLOWED_ATTR, mathMl$1);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n      }\n\n      /* Merge configuration parameters */\n      if (cfg.ADD_TAGS) {\n        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n          ALLOWED_TAGS = clone(ALLOWED_TAGS);\n        }\n\n        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS);\n      }\n\n      if (cfg.ADD_ATTR) {\n        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n          ALLOWED_ATTR = clone(ALLOWED_ATTR);\n        }\n\n        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR);\n      }\n\n      if (cfg.ADD_URI_SAFE_ATTR) {\n        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR);\n      }\n\n      /* Add #text in case KEEP_CONTENT is set to true */\n      if (KEEP_CONTENT) {\n        ALLOWED_TAGS['#text'] = true;\n      }\n\n      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n      if (WHOLE_DOCUMENT) {\n        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n      }\n\n      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n      if (ALLOWED_TAGS.table) {\n        addToSet(ALLOWED_TAGS, ['tbody']);\n        delete FORBID_TAGS.tbody;\n      }\n\n      // Prevent further manipulation of configuration.\n      // Not available in IE8, Safari 5, etc.\n      if (freeze) {\n        freeze(cfg);\n      }\n\n      CONFIG = cfg;\n    };\n\n    var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);\n\n    var HTML_INTEGRATION_POINTS = addToSet({}, ['foreignobject', 'desc', 'title', 'annotation-xml']);\n\n    /* Keep track of all possible SVG and MathML tags\n     * so that we can perform the namespace checks\n     * correctly. */\n    var ALL_SVG_TAGS = addToSet({}, svg);\n    addToSet(ALL_SVG_TAGS, svgFilters);\n    addToSet(ALL_SVG_TAGS, svgDisallowed);\n\n    var ALL_MATHML_TAGS = addToSet({}, mathMl);\n    addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n\n    var MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n    var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n    var HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n\n    /**\n     *\n     *\n     * @param  {Element} element a DOM element whose namespace is being checked\n     * @returns {boolean} Return false if the element has a\n     *  namespace that a spec-compliant parser would never\n     *  return. Return true otherwise.\n     */\n    var _checkValidNamespace = function _checkValidNamespace(element) {\n      var parent = getParentNode(element);\n\n      // In JSDOM, if we're inside shadow DOM, then parentNode\n      // can be null. We just simulate parent in this case.\n      if (!parent || !parent.tagName) {\n        parent = {\n          namespaceURI: HTML_NAMESPACE,\n          tagName: 'template'\n        };\n      }\n\n      var tagName = stringToLowerCase(element.tagName);\n      var parentTagName = stringToLowerCase(parent.tagName);\n\n      if (element.namespaceURI === SVG_NAMESPACE) {\n        // The only way to switch from HTML namespace to SVG\n        // is via <svg>. If it happens via any other tag, then\n        // it should be killed.\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'svg';\n        }\n\n        // The only way to switch from MathML to SVG is via\n        // svg if parent is either <annotation-xml> or MathML\n        // text integration points.\n        if (parent.namespaceURI === MATHML_NAMESPACE) {\n          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n        }\n\n        // We only allow elements that are defined in SVG\n        // spec. All others are disallowed in SVG namespace.\n        return Boolean(ALL_SVG_TAGS[tagName]);\n      }\n\n      if (element.namespaceURI === MATHML_NAMESPACE) {\n        // The only way to switch from HTML namespace to MathML\n        // is via <math>. If it happens via any other tag, then\n        // it should be killed.\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'math';\n        }\n\n        // The only way to switch from SVG to MathML is via\n        // <math> and HTML integration points\n        if (parent.namespaceURI === SVG_NAMESPACE) {\n          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n        }\n\n        // We only allow elements that are defined in MathML\n        // spec. All others are disallowed in MathML namespace.\n        return Boolean(ALL_MATHML_TAGS[tagName]);\n      }\n\n      if (element.namespaceURI === HTML_NAMESPACE) {\n        // The only way to switch from SVG to HTML is via\n        // HTML integration points, and from MathML to HTML\n        // is via MathML text integration points\n        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n\n        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n\n        // Certain elements are allowed in both SVG and HTML\n        // namespace. We need to specify them explicitly\n        // so that they don't get erronously deleted from\n        // HTML namespace.\n        var commonSvgAndHTMLElements = addToSet({}, ['title', 'style', 'font', 'a', 'script']);\n\n        // We disallow tags that are specific for MathML\n        // or SVG and should never appear in HTML namespace\n        return !ALL_MATHML_TAGS[tagName] && (commonSvgAndHTMLElements[tagName] || !ALL_SVG_TAGS[tagName]);\n      }\n\n      // The code should never reach this place (this means\n      // that the element somehow got namespace that is not\n      // HTML, SVG or MathML). Return false just in case.\n      return false;\n    };\n\n    /**\n     * _forceRemove\n     *\n     * @param  {Node} node a DOM node\n     */\n    var _forceRemove = function _forceRemove(node) {\n      arrayPush(DOMPurify.removed, { element: node });\n      try {\n        node.parentNode.removeChild(node);\n      } catch (_) {\n        try {\n          node.outerHTML = emptyHTML;\n        } catch (_) {\n          node.remove();\n        }\n      }\n    };\n\n    /**\n     * _removeAttribute\n     *\n     * @param  {String} name an Attribute name\n     * @param  {Node} node a DOM node\n     */\n    var _removeAttribute = function _removeAttribute(name, node) {\n      try {\n        arrayPush(DOMPurify.removed, {\n          attribute: node.getAttributeNode(name),\n          from: node\n        });\n      } catch (_) {\n        arrayPush(DOMPurify.removed, {\n          attribute: null,\n          from: node\n        });\n      }\n\n      node.removeAttribute(name);\n    };\n\n    /**\n     * _initDocument\n     *\n     * @param  {String} dirty a string of dirty markup\n     * @return {Document} a DOM, filled with the dirty markup\n     */\n    var _initDocument = function _initDocument(dirty) {\n      /* Create a HTML document */\n      var doc = void 0;\n      var leadingWhitespace = void 0;\n\n      if (FORCE_BODY) {\n        dirty = '<remove></remove>' + dirty;\n      } else {\n        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n        var matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n        leadingWhitespace = matches && matches[0];\n      }\n\n      var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n      /* Use the DOMParser API by default, fallback later if needs be */\n      try {\n        doc = new DOMParser().parseFromString(dirtyPayload, 'text/html');\n      } catch (_) {}\n\n      /* Use createHTMLDocument in case DOMParser is not available */\n      if (!doc || !doc.documentElement) {\n        doc = implementation.createHTMLDocument('');\n        var _doc = doc,\n            body = _doc.body;\n\n        body.parentNode.removeChild(body.parentNode.firstElementChild);\n        body.outerHTML = dirtyPayload;\n      }\n\n      if (dirty && leadingWhitespace) {\n        doc.body.insertBefore(document.createTextNode(leadingWhitespace), doc.body.childNodes[0] || null);\n      }\n\n      /* Work on whole document or just its body */\n      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n    };\n\n    /**\n     * _createIterator\n     *\n     * @param  {Document} root document/fragment to create iterator for\n     * @return {Iterator} iterator instance\n     */\n    var _createIterator = function _createIterator(root) {\n      return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, function () {\n        return NodeFilter.FILTER_ACCEPT;\n      }, false);\n    };\n\n    /**\n     * _isClobbered\n     *\n     * @param  {Node} elm element to check for clobbering attacks\n     * @return {Boolean} true if clobbered, false if safe\n     */\n    var _isClobbered = function _isClobbered(elm) {\n      if (elm instanceof Text || elm instanceof Comment) {\n        return false;\n      }\n\n      if (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function') {\n        return true;\n      }\n\n      return false;\n    };\n\n    /**\n     * _isNode\n     *\n     * @param  {Node} obj object to check whether it's a DOM node\n     * @return {Boolean} true is object is a DOM node\n     */\n    var _isNode = function _isNode(object) {\n      return (typeof Node === 'undefined' ? 'undefined' : _typeof(Node)) === 'object' ? object instanceof Node : object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\n    };\n\n    /**\n     * _executeHook\n     * Execute user configurable hooks\n     *\n     * @param  {String} entryPoint  Name of the hook's entry point\n     * @param  {Node} currentNode node to work on with the hook\n     * @param  {Object} data additional hook parameters\n     */\n    var _executeHook = function _executeHook(entryPoint, currentNode, data) {\n      if (!hooks[entryPoint]) {\n        return;\n      }\n\n      arrayForEach(hooks[entryPoint], function (hook) {\n        hook.call(DOMPurify, currentNode, data, CONFIG);\n      });\n    };\n\n    /**\n     * _sanitizeElements\n     *\n     * @protect nodeName\n     * @protect textContent\n     * @protect removeChild\n     *\n     * @param   {Node} currentNode to check for permission to exist\n     * @return  {Boolean} true if node was killed, false if left alive\n     */\n    var _sanitizeElements = function _sanitizeElements(currentNode) {\n      var content = void 0;\n\n      /* Execute a hook if present */\n      _executeHook('beforeSanitizeElements', currentNode, null);\n\n      /* Check if element is clobbered or can clobber */\n      if (_isClobbered(currentNode)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Check if tagname contains Unicode */\n      if (stringMatch(currentNode.nodeName, /[\\u0080-\\uFFFF]/)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Now let's check the element's type and name */\n      var tagName = stringToLowerCase(currentNode.nodeName);\n\n      /* Execute a hook if present */\n      _executeHook('uponSanitizeElement', currentNode, {\n        tagName: tagName,\n        allowedTags: ALLOWED_TAGS\n      });\n\n      /* Detect mXSS attempts abusing namespace confusion */\n      if (!_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Remove element if anything forbids its presence */\n      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n        /* Keep content except for bad-listed elements */\n        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n          var parentNode = getParentNode(currentNode);\n          var childNodes = getChildNodes(currentNode);\n          var childCount = childNodes.length;\n          for (var i = childCount - 1; i >= 0; --i) {\n            parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\n          }\n        }\n\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Check whether element has a valid namespace */\n      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      if ((tagName === 'noscript' || tagName === 'noembed') && regExpTest(/<\\/no(script|embed)/i, currentNode.innerHTML)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n\n      /* Sanitize element content to be template-safe */\n      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n        /* Get the element's text content */\n        content = currentNode.textContent;\n        content = stringReplace(content, MUSTACHE_EXPR$$1, ' ');\n        content = stringReplace(content, ERB_EXPR$$1, ' ');\n        if (currentNode.textContent !== content) {\n          arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\n          currentNode.textContent = content;\n        }\n      }\n\n      /* Execute a hook if present */\n      _executeHook('afterSanitizeElements', currentNode, null);\n\n      return false;\n    };\n\n    /**\n     * _isValidAttribute\n     *\n     * @param  {string} lcTag Lowercase tag name of containing element.\n     * @param  {string} lcName Lowercase attribute name.\n     * @param  {string} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid, otherwise false.\n     */\n    // eslint-disable-next-line complexity\n    var _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n      /* Make sure attribute cannot clobber */\n      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n        return false;\n      }\n\n      /* Allow valid data-* attributes: At least one character after \"-\"\n          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n          We don't need to check the value; it's always URI safe. */\n      if (ALLOW_DATA_ATTR && regExpTest(DATA_ATTR$$1, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$$1, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n        return false;\n\n        /* Check value is safe. First, is attr inert? If so, is safe */\n      } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$$1, stringReplace(value, ATTR_WHITESPACE$$1, ''))) ; else if (!value) ; else {\n        return false;\n      }\n\n      return true;\n    };\n\n    /**\n     * _sanitizeAttributes\n     *\n     * @protect attributes\n     * @protect nodeName\n     * @protect removeAttribute\n     * @protect setAttribute\n     *\n     * @param  {Node} currentNode to sanitize\n     */\n    var _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n      var attr = void 0;\n      var value = void 0;\n      var lcName = void 0;\n      var l = void 0;\n      /* Execute a hook if present */\n      _executeHook('beforeSanitizeAttributes', currentNode, null);\n\n      var attributes = currentNode.attributes;\n\n      /* Check if we have attributes; if not we might have a text node */\n\n      if (!attributes) {\n        return;\n      }\n\n      var hookEvent = {\n        attrName: '',\n        attrValue: '',\n        keepAttr: true,\n        allowedAttributes: ALLOWED_ATTR\n      };\n      l = attributes.length;\n\n      /* Go backwards over all attributes; safely remove bad ones */\n      while (l--) {\n        attr = attributes[l];\n        var _attr = attr,\n            name = _attr.name,\n            namespaceURI = _attr.namespaceURI;\n\n        value = stringTrim(attr.value);\n        lcName = stringToLowerCase(name);\n\n        /* Execute a hook if present */\n        hookEvent.attrName = lcName;\n        hookEvent.attrValue = value;\n        hookEvent.keepAttr = true;\n        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n        _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n        value = hookEvent.attrValue;\n        /* Did the hooks approve of the attribute? */\n        if (hookEvent.forceKeepAttr) {\n          continue;\n        }\n\n        /* Remove attribute */\n        _removeAttribute(name, currentNode);\n\n        /* Did the hooks approve of the attribute? */\n        if (!hookEvent.keepAttr) {\n          continue;\n        }\n\n        /* Work around a security issue in jQuery 3.0 */\n        if (regExpTest(/\\/>/i, value)) {\n          _removeAttribute(name, currentNode);\n          continue;\n        }\n\n        /* Sanitize attribute content to be template-safe */\n        if (SAFE_FOR_TEMPLATES) {\n          value = stringReplace(value, MUSTACHE_EXPR$$1, ' ');\n          value = stringReplace(value, ERB_EXPR$$1, ' ');\n        }\n\n        /* Is `value` valid for this attribute? */\n        var lcTag = currentNode.nodeName.toLowerCase();\n        if (!_isValidAttribute(lcTag, lcName, value)) {\n          continue;\n        }\n\n        /* Handle invalid data-* attribute set by try-catching it */\n        try {\n          if (namespaceURI) {\n            currentNode.setAttributeNS(namespaceURI, name, value);\n          } else {\n            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n            currentNode.setAttribute(name, value);\n          }\n\n          arrayPop(DOMPurify.removed);\n        } catch (_) {}\n      }\n\n      /* Execute a hook if present */\n      _executeHook('afterSanitizeAttributes', currentNode, null);\n    };\n\n    /**\n     * _sanitizeShadowDOM\n     *\n     * @param  {DocumentFragment} fragment to iterate over recursively\n     */\n    var _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n      var shadowNode = void 0;\n      var shadowIterator = _createIterator(fragment);\n\n      /* Execute a hook if present */\n      _executeHook('beforeSanitizeShadowDOM', fragment, null);\n\n      while (shadowNode = shadowIterator.nextNode()) {\n        /* Execute a hook if present */\n        _executeHook('uponSanitizeShadowNode', shadowNode, null);\n\n        /* Sanitize tags and elements */\n        if (_sanitizeElements(shadowNode)) {\n          continue;\n        }\n\n        /* Deep shadow DOM detected */\n        if (shadowNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(shadowNode.content);\n        }\n\n        /* Check attributes, sanitize if necessary */\n        _sanitizeAttributes(shadowNode);\n      }\n\n      /* Execute a hook if present */\n      _executeHook('afterSanitizeShadowDOM', fragment, null);\n    };\n\n    /**\n     * Sanitize\n     * Public method providing core sanitation functionality\n     *\n     * @param {String|Node} dirty string or DOM node\n     * @param {Object} configuration object\n     */\n    // eslint-disable-next-line complexity\n    DOMPurify.sanitize = function (dirty, cfg) {\n      var body = void 0;\n      var importedNode = void 0;\n      var currentNode = void 0;\n      var oldNode = void 0;\n      var returnNode = void 0;\n      /* Make sure we have a string to sanitize.\n        DO NOT return early, as this will return the wrong type if\n        the user has requested a DOM object rather than a string */\n      if (!dirty) {\n        dirty = '<!-->';\n      }\n\n      /* Stringify, in case dirty is an object */\n      if (typeof dirty !== 'string' && !_isNode(dirty)) {\n        // eslint-disable-next-line no-negated-condition\n        if (typeof dirty.toString !== 'function') {\n          throw typeErrorCreate('toString is not a function');\n        } else {\n          dirty = dirty.toString();\n          if (typeof dirty !== 'string') {\n            throw typeErrorCreate('dirty is not a string, aborting');\n          }\n        }\n      }\n\n      /* Check we can run. Otherwise fall back or ignore */\n      if (!DOMPurify.isSupported) {\n        if (_typeof(window.toStaticHTML) === 'object' || typeof window.toStaticHTML === 'function') {\n          if (typeof dirty === 'string') {\n            return window.toStaticHTML(dirty);\n          }\n\n          if (_isNode(dirty)) {\n            return window.toStaticHTML(dirty.outerHTML);\n          }\n        }\n\n        return dirty;\n      }\n\n      /* Assign config vars */\n      if (!SET_CONFIG) {\n        _parseConfig(cfg);\n      }\n\n      /* Clean up removed elements */\n      DOMPurify.removed = [];\n\n      /* Check if dirty is correctly typed for IN_PLACE */\n      if (typeof dirty === 'string') {\n        IN_PLACE = false;\n      }\n\n      if (IN_PLACE) ; else if (dirty instanceof Node) {\n        /* If dirty is a DOM element, append to an empty document to avoid\n           elements being stripped by the parser */\n        body = _initDocument('<!---->');\n        importedNode = body.ownerDocument.importNode(dirty, true);\n        if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n          /* Node is already a body, use as is */\n          body = importedNode;\n        } else if (importedNode.nodeName === 'HTML') {\n          body = importedNode;\n        } else {\n          // eslint-disable-next-line unicorn/prefer-node-append\n          body.appendChild(importedNode);\n        }\n      } else {\n        /* Exit directly if we have nothing to do */\n        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&\n        // eslint-disable-next-line unicorn/prefer-includes\n        dirty.indexOf('<') === -1) {\n          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        }\n\n        /* Initialize the document to work on */\n        body = _initDocument(dirty);\n\n        /* Check we have a DOM node from the data */\n        if (!body) {\n          return RETURN_DOM ? null : emptyHTML;\n        }\n      }\n\n      /* Remove first element node (ours) if FORCE_BODY is set */\n      if (body && FORCE_BODY) {\n        _forceRemove(body.firstChild);\n      }\n\n      /* Get node iterator */\n      var nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n\n      /* Now start iterating over the created document */\n      while (currentNode = nodeIterator.nextNode()) {\n        /* Fix IE's strange behavior with manipulated textNodes #89 */\n        if (currentNode.nodeType === 3 && currentNode === oldNode) {\n          continue;\n        }\n\n        /* Sanitize tags and elements */\n        if (_sanitizeElements(currentNode)) {\n          continue;\n        }\n\n        /* Shadow DOM detected, sanitize it */\n        if (currentNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(currentNode.content);\n        }\n\n        /* Check attributes, sanitize if necessary */\n        _sanitizeAttributes(currentNode);\n\n        oldNode = currentNode;\n      }\n\n      oldNode = null;\n\n      /* If we sanitized `dirty` in-place, return it. */\n      if (IN_PLACE) {\n        return dirty;\n      }\n\n      /* Return sanitized string or DOM */\n      if (RETURN_DOM) {\n        if (RETURN_DOM_FRAGMENT) {\n          returnNode = createDocumentFragment.call(body.ownerDocument);\n\n          while (body.firstChild) {\n            // eslint-disable-next-line unicorn/prefer-node-append\n            returnNode.appendChild(body.firstChild);\n          }\n        } else {\n          returnNode = body;\n        }\n\n        if (RETURN_DOM_IMPORT) {\n          /*\n            AdoptNode() is not used because internal state is not reset\n            (e.g. the past names map of a HTMLFormElement), this is safe\n            in theory but we would rather not risk another attack vector.\n            The state that is cloned by importNode() is explicitly defined\n            by the specs.\n          */\n          returnNode = importNode.call(originalDocument, returnNode, true);\n        }\n\n        return returnNode;\n      }\n\n      var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n\n      /* Sanitize final string template-safe */\n      if (SAFE_FOR_TEMPLATES) {\n        serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$$1, ' ');\n        serializedHTML = stringReplace(serializedHTML, ERB_EXPR$$1, ' ');\n      }\n\n      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n    };\n\n    /**\n     * Public method to set the configuration once\n     * setConfig\n     *\n     * @param {Object} cfg configuration object\n     */\n    DOMPurify.setConfig = function (cfg) {\n      _parseConfig(cfg);\n      SET_CONFIG = true;\n    };\n\n    /**\n     * Public method to remove the configuration\n     * clearConfig\n     *\n     */\n    DOMPurify.clearConfig = function () {\n      CONFIG = null;\n      SET_CONFIG = false;\n    };\n\n    /**\n     * Public method to check if an attribute value is valid.\n     * Uses last set config, if any. Otherwise, uses config defaults.\n     * isValidAttribute\n     *\n     * @param  {string} tag Tag name of containing element.\n     * @param  {string} attr Attribute name.\n     * @param  {string} value Attribute value.\n     * @return {Boolean} Returns true if `value` is valid. Otherwise, returns false.\n     */\n    DOMPurify.isValidAttribute = function (tag, attr, value) {\n      /* Initialize shared config vars if necessary. */\n      if (!CONFIG) {\n        _parseConfig({});\n      }\n\n      var lcTag = stringToLowerCase(tag);\n      var lcName = stringToLowerCase(attr);\n      return _isValidAttribute(lcTag, lcName, value);\n    };\n\n    /**\n     * AddHook\n     * Public method to add DOMPurify hooks\n     *\n     * @param {String} entryPoint entry point for the hook to add\n     * @param {Function} hookFunction function to execute\n     */\n    DOMPurify.addHook = function (entryPoint, hookFunction) {\n      if (typeof hookFunction !== 'function') {\n        return;\n      }\n\n      hooks[entryPoint] = hooks[entryPoint] || [];\n      arrayPush(hooks[entryPoint], hookFunction);\n    };\n\n    /**\n     * RemoveHook\n     * Public method to remove a DOMPurify hook at a given entryPoint\n     * (pops it from the stack of hooks if more are present)\n     *\n     * @param {String} entryPoint entry point for the hook to remove\n     */\n    DOMPurify.removeHook = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        arrayPop(hooks[entryPoint]);\n      }\n    };\n\n    /**\n     * RemoveHooks\n     * Public method to remove all DOMPurify hooks at a given entryPoint\n     *\n     * @param  {String} entryPoint entry point for the hooks to remove\n     */\n    DOMPurify.removeHooks = function (entryPoint) {\n      if (hooks[entryPoint]) {\n        hooks[entryPoint] = [];\n      }\n    };\n\n    /**\n     * RemoveAllHooks\n     * Public method to remove all DOMPurify hooks\n     *\n     */\n    DOMPurify.removeAllHooks = function () {\n      hooks = {};\n    };\n\n    return DOMPurify;\n  }\n\n  var purify = createDOMPurify();\n\n  return purify;\n\n}));\n//# sourceMappingURL=purify.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZG9tcHVyaWZ5L2Rpc3QvcHVyaWZ5LmpzP2MwYzQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQSxFQUFFLEtBQTREO0FBQzlELEVBQUUsU0FDdUQ7QUFDekQsQ0FBQyxvQkFBb0I7O0FBRXJCLG9DQUFvQywwQkFBMEIsMENBQTBDLGdCQUFnQixPQUFPLGtCQUFrQixFQUFFLGFBQWEsRUFBRSxPQUFPLHdCQUF3QixFQUFFOztBQUVuTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qjs7QUFFN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHdGQUF3RixhQUFhO0FBQ3JHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3RUFBd0UsZUFBZTtBQUN2RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFD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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxZQUFZO0FBQzNCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUM7QUFDRCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9kb21wdXJpZnkvZGlzdC9wdXJpZnkuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgQGxpY2Vuc2UgRE9NUHVyaWZ5IHwgKGMpIEN1cmU1MyBhbmQgb3RoZXIgY29udHJpYnV0b3JzIHwgUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBsaWNlbnNlIDIuMCBhbmQgTW96aWxsYSBQdWJsaWMgTGljZW5zZSAyLjAgfCBnaXRodWIuY29tL2N1cmU1My9ET01QdXJpZnkvYmxvYi8yLjIuMi9MSUNFTlNFICovXG5cbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwuRE9NUHVyaWZ5ID0gZmFjdG9yeSgpKTtcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XG5cbiAgdmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0Lmhhc093blByb3BlcnR5LFxuICAgICAgc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YsXG4gICAgICBpc0Zyb3plbiA9IE9iamVjdC5pc0Zyb3plbixcbiAgICAgIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiAgdmFyIGZyZWV6ZSA9IE9iamVjdC5mcmVlemUsXG4gICAgICBzZWFsID0gT2JqZWN0LnNlYWwsXG4gICAgICBjcmVhdGUgPSBPYmplY3QuY3JlYXRlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGltcG9ydC9uby1tdXRhYmxlLWV4cG9ydHNcblxuICB2YXIgX3JlZiA9IHR5cGVvZiBSZWZsZWN0ICE9PSAndW5kZWZpbmVkJyAmJiBSZWZsZWN0LFxuICAgICAgYXBwbHkgPSBfcmVmLmFwcGx5LFxuICAgICAgY29uc3RydWN0ID0gX3JlZi5jb25zdHJ1Y3Q7XG5cbiAgaWYgKCFhcHBseSkge1xuICAgIGFwcGx5ID0gZnVuY3Rpb24gYXBwbHkoZnVuLCB0aGlzVmFsdWUsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBmdW4uYXBwbHkodGhpc1ZhbHVlLCBhcmdzKTtcbiAgICB9O1xuICB9XG5cbiAgaWYgKCFmcmVlemUpIHtcbiAgICBmcmVlemUgPSBmdW5jdGlvbiBmcmVlemUoeCkge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbiAgfVxuXG4gIGlmICghc2VhbCkge1xuICAgIHNlYWwgPSBmdW5jdGlvbiBzZWFsKHgpIHtcbiAgICAgIHJldHVybiB4O1xuICAgIH07XG4gIH1cblxuICBpZiAoIWNvbnN0cnVjdCkge1xuICAgIGNvbnN0cnVjdCA9IGZ1bmN0aW9uIGNvbnN0cnVjdChGdW5jLCBhcmdzKSB7XG4gICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShGdW5jLCBbbnVsbF0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShhcmdzKSkpKSgpO1xuICAgIH07XG4gIH1cblxuICB2YXIgYXJyYXlGb3JFYWNoID0gdW5hcHBseShBcnJheS5wcm90b3R5cGUuZm9yRWFjaCk7XG4gIHZhciBhcnJheVBvcCA9IHVuYXBwbHkoQXJyYXkucHJvdG90eXBlLnBvcCk7XG4gIHZhciBhcnJheVB1c2ggPSB1bmFwcGx5KEFycmF5LnByb3RvdHlwZS5wdXNoKTtcblxuICB2YXIgc3RyaW5nVG9Mb3dlckNhc2UgPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUudG9Mb3dlckNhc2UpO1xuICB2YXIgc3RyaW5nTWF0Y2ggPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUubWF0Y2gpO1xuICB2YXIgc3RyaW5nUmVwbGFjZSA9IHVuYXBwbHkoU3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlKTtcbiAgdmFyIHN0cmluZ0luZGV4T2YgPSB1bmFwcGx5KFN0cmluZy5wcm90b3R5cGUuaW5kZXhPZik7XG4gIHZhciBzdHJpbmdUcmltID0gdW5hcHBseShTdHJpbmcucHJvdG90eXBlLnRyaW0pO1xuXG4gIHZhciByZWdFeHBUZXN0ID0gdW5hcHBseShSZWdFeHAucHJvdG90eXBlLnRlc3QpO1xuXG4gIHZhciB0eXBlRXJyb3JDcmVhdGUgPSB1bmNvbnN0cnVjdChUeXBlRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIHVuYXBwbHkoZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbiAodGhpc0FyZykge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpc0FyZywgYXJncyk7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuY29uc3RydWN0KGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29uc3RydWN0KGZ1bmMsIGFyZ3MpO1xuICAgIH07XG4gIH1cblxuICAvKiBBZGQgcHJvcGVydGllcyB0byBhIGxvb2t1cCB0YWJsZSAqL1xuICBmdW5jdGlvbiBhZGRUb1NldChzZXQsIGFycmF5KSB7XG4gICAgaWYgKHNldFByb3RvdHlwZU9mKSB7XG4gICAgICAvLyBNYWtlICdpbicgYW5kIHRydXRoeSBjaGVja3MgbGlrZSBCb29sZWFuKHNldC5jb25zdHJ1Y3RvcilcbiAgICAgIC8vIGluZGVwZW5kZW50IG9mIGFueSBwcm9wZXJ0aWVzIGRlZmluZWQgb24gT2JqZWN0LnByb3RvdHlwZS5cbiAgICAgIC8vIFByZXZlbnQgcHJvdG90eXBlIHNldHRlcnMgZnJvbSBpbnRlcmNlcHRpbmcgc2V0IGFzIGEgdGhpcyB2YWx1ZS5cbiAgICAgIHNldFByb3RvdHlwZU9mKHNldCwgbnVsbCk7XG4gICAgfVxuXG4gICAgdmFyIGwgPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGwtLSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBhcnJheVtsXTtcbiAgICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGxjRWxlbWVudCA9IHN0cmluZ1RvTG93ZXJDYXNlKGVsZW1lbnQpO1xuICAgICAgICBpZiAobGNFbGVtZW50ICE9PSBlbGVtZW50KSB7XG4gICAgICAgICAgLy8gQ29uZmlnIHByZXNldHMgKGUuZy4gdGFncy5qcywgYXR0cnMuanMpIGFyZSBpbW11dGFibGUuXG4gICAgICAgICAgaWYgKCFpc0Zyb3plbihhcnJheSkpIHtcbiAgICAgICAgICAgIGFycmF5W2xdID0gbGNFbGVtZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVsZW1lbnQgPSBsY0VsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2V0W2VsZW1lbnRdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2V0O1xuICB9XG5cbiAgLyogU2hhbGxvdyBjbG9uZSBhbiBvYmplY3QgKi9cbiAgZnVuY3Rpb24gY2xvbmUob2JqZWN0KSB7XG4gICAgdmFyIG5ld09iamVjdCA9IGNyZWF0ZShudWxsKTtcblxuICAgIHZhciBwcm9wZXJ0eSA9IHZvaWQgMDtcbiAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgaWYgKGFwcGx5KGhhc093blByb3BlcnR5LCBvYmplY3QsIFtwcm9wZXJ0eV0pKSB7XG4gICAgICAgIG5ld09iamVjdFtwcm9wZXJ0eV0gPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXdPYmplY3Q7XG4gIH1cblxuICAvKiBJRTEwIGRvZXNuJ3Qgc3VwcG9ydCBfX2xvb2t1cEdldHRlcl9fIHNvIGxldHMnXG4gICAqIHNpbXVsYXRlIGl0LiBJdCBhbHNvIGF1dG9tYXRpY2FsbHkgY2hlY2tzXG4gICAqIGlmIHRoZSBwcm9wIGlzIGZ1bmN0aW9uIG9yIGdldHRlciBhbmQgYmVoYXZlc1xuICAgKiBhY2NvcmRpbmdseS4gKi9cbiAgZnVuY3Rpb24gbG9va3VwR2V0dGVyKG9iamVjdCwgcHJvcCkge1xuICAgIHdoaWxlIChvYmplY3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBkZXNjID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgcHJvcCk7XG4gICAgICBpZiAoZGVzYykge1xuICAgICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgICByZXR1cm4gdW5hcHBseShkZXNjLmdldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRlc2MudmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gdW5hcHBseShkZXNjLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBvYmplY3QgPSBnZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGh0bWwgPSBmcmVlemUoWydhJywgJ2FiYnInLCAnYWNyb255bScsICdhZGRyZXNzJywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdhdWRpbycsICdiJywgJ2JkaScsICdiZG8nLCAnYmlnJywgJ2JsaW5rJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FudmFzJywgJ2NhcHRpb24nLCAnY2VudGVyJywgJ2NpdGUnLCAnY29kZScsICdjb2wnLCAnY29sZ3JvdXAnLCAnY29udGVudCcsICdkYXRhJywgJ2RhdGFsaXN0JywgJ2RkJywgJ2RlY29yYXRvcicsICdkZWwnLCAnZGV0YWlscycsICdkZm4nLCAnZGlhbG9nJywgJ2RpcicsICdkaXYnLCAnZGwnLCAnZHQnLCAnZWxlbWVudCcsICdlbScsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb250JywgJ2Zvb3RlcicsICdmb3JtJywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2knLCAnaW1nJywgJ2lucHV0JywgJ2lucycsICdrYmQnLCAnbGFiZWwnLCAnbGVnZW5kJywgJ2xpJywgJ21haW4nLCAnbWFwJywgJ21hcmsnLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGVyJywgJ25hdicsICdub2JyJywgJ29sJywgJ29wdGdyb3VwJywgJ29wdGlvbicsICdvdXRwdXQnLCAncCcsICdwaWN0dXJlJywgJ3ByZScsICdwcm9ncmVzcycsICdxJywgJ3JwJywgJ3J0JywgJ3J1YnknLCAncycsICdzYW1wJywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NoYWRvdycsICdzbWFsbCcsICdzb3VyY2UnLCAnc3BhY2VyJywgJ3NwYW4nLCAnc3RyaWtlJywgJ3N0cm9uZycsICdzdHlsZScsICdzdWInLCAnc3VtbWFyeScsICdzdXAnLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGltZScsICd0cicsICd0cmFjaycsICd0dCcsICd1JywgJ3VsJywgJ3ZhcicsICd2aWRlbycsICd3YnInXSk7XG5cbiAgLy8gU1ZHXG4gIHZhciBzdmcgPSBmcmVlemUoWydzdmcnLCAnYScsICdhbHRnbHlwaCcsICdhbHRnbHlwaGRlZicsICdhbHRnbHlwaGl0ZW0nLCAnYW5pbWF0ZWNvbG9yJywgJ2FuaW1hdGVtb3Rpb24nLCAnYW5pbWF0ZXRyYW5zZm9ybScsICdjaXJjbGUnLCAnY2xpcHBhdGgnLCAnZGVmcycsICdkZXNjJywgJ2VsbGlwc2UnLCAnZmlsdGVyJywgJ2ZvbnQnLCAnZycsICdnbHlwaCcsICdnbHlwaHJlZicsICdoa2VybicsICdpbWFnZScsICdsaW5lJywgJ2xpbmVhcmdyYWRpZW50JywgJ21hcmtlcicsICdtYXNrJywgJ21ldGFkYXRhJywgJ21wYXRoJywgJ3BhdGgnLCAncGF0dGVybicsICdwb2x5Z29uJywgJ3BvbHlsaW5lJywgJ3JhZGlhbGdyYWRpZW50JywgJ3JlY3QnLCAnc3RvcCcsICdzdHlsZScsICdzd2l0Y2gnLCAnc3ltYm9sJywgJ3RleHQnLCAndGV4dHBhdGgnLCAndGl0bGUnLCAndHJlZicsICd0c3BhbicsICd2aWV3JywgJ3ZrZXJuJ10pO1xuXG4gIHZhciBzdmdGaWx0ZXJzID0gZnJlZXplKFsnZmVCbGVuZCcsICdmZUNvbG9yTWF0cml4JywgJ2ZlQ29tcG9uZW50VHJhbnNmZXInLCAnZmVDb21wb3NpdGUnLCAnZmVDb252b2x2ZU1hdHJpeCcsICdmZURpZmZ1c2VMaWdodGluZycsICdmZURpc3BsYWNlbWVudE1hcCcsICdmZURpc3RhbnRMaWdodCcsICdmZUZsb29kJywgJ2ZlRnVuY0EnLCAnZmVGdW5jQicsICdmZUZ1bmNHJywgJ2ZlRnVuY1InLCAnZmVHYXVzc2lhbkJsdXInLCAnZmVNZXJnZScsICdmZU1lcmdlTm9kZScsICdmZU1vcnBob2xvZ3knLCAnZmVPZmZzZXQnLCAnZmVQb2ludExpZ2h0JywgJ2ZlU3BlY3VsYXJMaWdodGluZycsICdmZVNwb3RMaWdodCcsICdmZVRpbGUnLCAnZmVUdXJidWxlbmNlJ10pO1xuXG4gIC8vIExpc3Qgb2YgU1ZHIGVsZW1lbnRzIHRoYXQgYXJlIGRpc2FsbG93ZWQgYnkgZGVmYXVsdC5cbiAgLy8gV2Ugc3RpbGwgbmVlZCB0byBrbm93IHRoZW0gc28gdGhhdCB3ZSBjYW4gZG8gbmFtZXNwYWNlXG4gIC8vIGNoZWNrcyBwcm9wZXJseSBpbiBjYXNlIG9uZSB3YW50cyB0byBhZGQgdGhlbSB0b1xuICAvLyBhbGxvdy1saXN0LlxuICB2YXIgc3ZnRGlzYWxsb3dlZCA9IGZyZWV6ZShbJ2FuaW1hdGUnLCAnY29sb3ItcHJvZmlsZScsICdjdXJzb3InLCAnZGlzY2FyZCcsICdmZWRyb3BzaGFkb3cnLCAnZmVpbWFnZScsICdmb250LWZhY2UnLCAnZm9udC1mYWNlLWZvcm1hdCcsICdmb250LWZhY2UtbmFtZScsICdmb250LWZhY2Utc3JjJywgJ2ZvbnQtZmFjZS11cmknLCAnZm9yZWlnbm9iamVjdCcsICdoYXRjaCcsICdoYXRjaHBhdGgnLCAnbWVzaCcsICdtZXNoZ3JhZGllbnQnLCAnbWVzaHBhdGNoJywgJ21lc2hyb3cnLCAnbWlzc2luZy1nbHlwaCcsICdzY3JpcHQnLCAnc2V0JywgJ3NvbGlkY29sb3InLCAndW5rbm93bicsICd1c2UnXSk7XG5cbiAgdmFyIG1hdGhNbCA9IGZyZWV6ZShbJ21hdGgnLCAnbWVuY2xvc2UnLCAnbWVycm9yJywgJ21mZW5jZWQnLCAnbWZyYWMnLCAnbWdseXBoJywgJ21pJywgJ21sYWJlbGVkdHInLCAnbW11bHRpc2NyaXB0cycsICdtbicsICdtbycsICdtb3ZlcicsICdtcGFkZGVkJywgJ21waGFudG9tJywgJ21yb290JywgJ21yb3cnLCAnbXMnLCAnbXNwYWNlJywgJ21zcXJ0JywgJ21zdHlsZScsICdtc3ViJywgJ21zdXAnLCAnbXN1YnN1cCcsICdtdGFibGUnLCAnbXRkJywgJ210ZXh0JywgJ210cicsICdtdW5kZXInLCAnbXVuZGVyb3ZlciddKTtcblxuICAvLyBTaW1pbGFybHkgdG8gU1ZHLCB3ZSB3YW50IHRvIGtub3cgYWxsIE1hdGhNTCBlbGVtZW50cyxcbiAgLy8gZXZlbiB0aG9zZSB0aGF0IHdlIGRpc2FsbG93IGJ5IGRlZmF1bHQuXG4gIHZhciBtYXRoTWxEaXNhbGxvd2VkID0gZnJlZXplKFsnbWFjdGlvbicsICdtYWxpZ25ncm91cCcsICdtYWxpZ25tYXJrJywgJ21sb25nZGl2JywgJ21zY2FycmllcycsICdtc2NhcnJ5JywgJ21zZ3JvdXAnLCAnbXN0YWNrJywgJ21zbGluZScsICdtc3JvdycsICdzZW1hbnRpY3MnLCAnYW5ub3RhdGlvbicsICdhbm5vdGF0aW9uLXhtbCcsICdtcHJlc2NyaXB0cycsICdub25lJ10pO1xuXG4gIHZhciB0ZXh0ID0gZnJlZXplKFsnI3RleHQnXSk7XG5cbiAgdmFyIGh0bWwkMSA9IGZyZWV6ZShbJ2FjY2VwdCcsICdhY3Rpb24nLCAnYWxpZ24nLCAnYWx0JywgJ2F1dG9jYXBpdGFsaXplJywgJ2F1dG9jb21wbGV0ZScsICdhdXRvcGljdHVyZWlucGljdHVyZScsICdhdXRvcGxheScsICdiYWNrZ3JvdW5kJywgJ2JnY29sb3InLCAnYm9yZGVyJywgJ2NhcHR1cmUnLCAnY2VsbHBhZGRpbmcnLCAnY2VsbHNwYWNpbmcnLCAnY2hlY2tlZCcsICdjaXRlJywgJ2NsYXNzJywgJ2NsZWFyJywgJ2NvbG9yJywgJ2NvbHMnLCAnY29sc3BhbicsICdjb250cm9scycsICdjb250cm9sc2xpc3QnLCAnY29vcmRzJywgJ2Nyb3Nzb3JpZ2luJywgJ2RhdGV0aW1lJywgJ2RlY29kaW5nJywgJ2RlZmF1bHQnLCAnZGlyJywgJ2Rpc2FibGVkJywgJ2Rpc2FibGVwaWN0dXJlaW5waWN0dXJlJywgJ2Rpc2FibGVyZW1vdGVwbGF5YmFjaycsICdkb3dubG9hZCcsICdkcmFnZ2FibGUnLCAnZW5jdHlwZScsICdlbnRlcmtleWhpbnQnLCAnZmFjZScsICdmb3InLCAnaGVhZGVycycsICdoZWlnaHQnLCAnaGlkZGVuJywgJ2hpZ2gnLCAnaHJlZicsICdocmVmbGFuZycsICdpZCcsICdpbnB1dG1vZGUnLCAnaW50ZWdyaXR5JywgJ2lzbWFwJywgJ2tpbmQnLCAnbGFiZWwnLCAnbGFuZycsICdsaXN0JywgJ2xvYWRpbmcnLCAnbG9vcCcsICdsb3cnLCAnbWF4JywgJ21heGxlbmd0aCcsICdtZWRpYScsICdtZXRob2QnLCAnbWluJywgJ21pbmxlbmd0aCcsICdtdWx0aXBsZScsICdtdXRlZCcsICduYW1lJywgJ25vc2hhZGUnLCAnbm92YWxpZGF0ZScsICdub3dyYXAnLCAnb3BlbicsICdvcHRpbXVtJywgJ3BhdHRlcm4nLCAncGxhY2Vob2xkZXInLCAncGxheXNpbmxpbmUnLCAncG9zdGVyJywgJ3ByZWxvYWQnLCAncHViZGF0ZScsICdyYWRpb2dyb3VwJywgJ3JlYWRvbmx5JywgJ3JlbCcsICdyZXF1aXJlZCcsICdyZXYnLCAncmV2ZXJzZWQnLCAncm9sZScsICdyb3dzJywgJ3Jvd3NwYW4nLCAnc3BlbGxjaGVjaycsICdzY29wZScsICdzZWxlY3RlZCcsICdzaGFwZScsICdzaXplJywgJ3NpemVzJywgJ3NwYW4nLCAnc3JjbGFuZycsICdzdGFydCcsICdzcmMnLCAnc3Jjc2V0JywgJ3N0ZXAnLCAnc3R5bGUnLCAnc3VtbWFyeScsICd0YWJpbmRleCcsICd0aXRsZScsICd0cmFuc2xhdGUnLCAndHlwZScsICd1c2VtYXAnLCAndmFsaWduJywgJ3ZhbHVlJywgJ3dpZHRoJywgJ3htbG5zJ10pO1xuXG4gIHZhciBzdmckMSA9IGZyZWV6ZShbJ2FjY2VudC1oZWlnaHQnLCAnYWNjdW11bGF0ZScsICdhZGRpdGl2ZScsICdhbGlnbm1lbnQtYmFzZWxpbmUnLCAnYXNjZW50JywgJ2F0dHJpYnV0ZW5hbWUnLCAnYXR0cmlidXRldHlwZScsICdhemltdXRoJywgJ2Jhc2VmcmVxdWVuY3knLCAnYmFzZWxpbmUtc2hpZnQnLCAnYmVnaW4nLCAnYmlhcycsICdieScsICdjbGFzcycsICdjbGlwJywgJ2NsaXBwYXRodW5pdHMnLCAnY2xpcC1wYXRoJywgJ2NsaXAtcnVsZScsICdjb2xvcicsICdjb2xvci1pbnRlcnBvbGF0aW9uJywgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdjb2xvci1wcm9maWxlJywgJ2NvbG9yLXJlbmRlcmluZycsICdjeCcsICdjeScsICdkJywgJ2R4JywgJ2R5JywgJ2RpZmZ1c2Vjb25zdGFudCcsICdkaXJlY3Rpb24nLCAnZGlzcGxheScsICdkaXZpc29yJywgJ2R1cicsICdlZGdlbW9kZScsICdlbGV2YXRpb24nLCAnZW5kJywgJ2ZpbGwnLCAnZmlsbC1vcGFjaXR5JywgJ2ZpbGwtcnVsZScsICdmaWx0ZXInLCAnZmlsdGVydW5pdHMnLCAnZmxvb2QtY29sb3InLCAnZmxvb2Qtb3BhY2l0eScsICdmb250LWZhbWlseScsICdmb250LXNpemUnLCAnZm9udC1zaXplLWFkanVzdCcsICdmb250LXN0cmV0Y2gnLCAnZm9udC1zdHlsZScsICdmb250LXZhcmlhbnQnLCAnZm9udC13ZWlnaHQnLCAnZngnLCAnZnknLCAnZzEnLCAnZzInLCAnZ2x5cGgtbmFtZScsICdnbHlwaHJlZicsICdncmFkaWVudHVuaXRzJywgJ2dyYWRpZW50dHJhbnNmb3JtJywgJ2hlaWdodCcsICdocmVmJywgJ2lkJywgJ2ltYWdlLXJlbmRlcmluZycsICdpbicsICdpbjInLCAnaycsICdrMScsICdrMicsICdrMycsICdrNCcsICdrZXJuaW5nJywgJ2tleXBvaW50cycsICdrZXlzcGxpbmVzJywgJ2tleXRpbWVzJywgJ2xhbmcnLCAnbGVuZ3RoYWRqdXN0JywgJ2xldHRlci1zcGFjaW5nJywgJ2tlcm5lbG1hdHJpeCcsICdrZXJuZWx1bml0bGVuZ3RoJywgJ2xpZ2h0aW5nLWNvbG9yJywgJ2xvY2FsJywgJ21hcmtlci1lbmQnLCAnbWFya2VyLW1pZCcsICdtYXJrZXItc3RhcnQnLCAnbWFya2VyaGVpZ2h0JywgJ21hcmtlcnVuaXRzJywgJ21hcmtlcndpZHRoJywgJ21hc2tjb250ZW50dW5pdHMnLCAnbWFza3VuaXRzJywgJ21heCcsICdtYXNrJywgJ21lZGlhJywgJ21ldGhvZCcsICdtb2RlJywgJ21pbicsICduYW1lJywgJ251bW9jdGF2ZXMnLCAnb2Zmc2V0JywgJ29wZXJhdG9yJywgJ29wYWNpdHknLCAnb3JkZXInLCAnb3JpZW50JywgJ29yaWVudGF0aW9uJywgJ29yaWdpbicsICdvdmVyZmxvdycsICdwYWludC1vcmRlcicsICdwYXRoJywgJ3BhdGhsZW5ndGgnLCAncGF0dGVybmNvbnRlbnR1bml0cycsICdwYXR0ZXJudHJhbnNmb3JtJywgJ3BhdHRlcm51bml0cycsICdwb2ludHMnLCAncHJlc2VydmVhbHBoYScsICdwcmVzZXJ2ZWFzcGVjdHJhdGlvJywgJ3ByaW1pdGl2ZXVuaXRzJywgJ3InLCAncngnLCAncnknLCAncmFkaXVzJywgJ3JlZngnLCAncmVmeScsICdyZXBlYXRjb3VudCcsICdyZXBlYXRkdXInLCAncmVzdGFydCcsICdyZXN1bHQnLCAncm90YXRlJywgJ3NjYWxlJywgJ3NlZWQnLCAnc2hhcGUtcmVuZGVyaW5nJywgJ3NwZWN1bGFyY29uc3RhbnQnLCAnc3BlY3VsYXJleHBvbmVudCcsICdzcHJlYWRtZXRob2QnLCAnc3RhcnRvZmZzZXQnLCAnc3RkZGV2aWF0aW9uJywgJ3N0aXRjaHRpbGVzJywgJ3N0b3AtY29sb3InLCAnc3RvcC1vcGFjaXR5JywgJ3N0cm9rZS1kYXNoYXJyYXknLCAnc3Ryb2tlLWRhc2hvZmZzZXQnLCAnc3Ryb2tlLWxpbmVjYXAnLCAnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cm9rZS1taXRlcmxpbWl0JywgJ3N0cm9rZS1vcGFjaXR5JywgJ3N0cm9rZScsICdzdHJva2Utd2lkdGgnLCAnc3R5bGUnLCAnc3VyZmFjZXNjYWxlJywgJ3N5c3RlbWxhbmd1YWdlJywgJ3RhYmluZGV4JywgJ3RhcmdldHgnLCAndGFyZ2V0eScsICd0cmFuc2Zvcm0nLCAndGV4dC1hbmNob3InLCAndGV4dC1kZWNvcmF0aW9uJywgJ3RleHQtcmVuZGVyaW5nJywgJ3RleHRsZW5ndGgnLCAndHlwZScsICd1MScsICd1MicsICd1bmljb2RlJywgJ3ZhbHVlcycsICd2aWV3Ym94JywgJ3Zpc2liaWxpdHknLCAndmVyc2lvbicsICd2ZXJ0LWFkdi15JywgJ3ZlcnQtb3JpZ2luLXgnLCAndmVydC1vcmlnaW4teScsICd3aWR0aCcsICd3b3JkLXNwYWNpbmcnLCAnd3JhcCcsICd3cml0aW5nLW1vZGUnLCAneGNoYW5uZWxzZWxlY3RvcicsICd5Y2hhbm5lbHNlbGVjdG9yJywgJ3gnLCAneDEnLCAneDInLCAneG1sbnMnLCAneScsICd5MScsICd5MicsICd6JywgJ3pvb21hbmRwYW4nXSk7XG5cbiAgdmFyIG1hdGhNbCQxID0gZnJlZXplKFsnYWNjZW50JywgJ2FjY2VudHVuZGVyJywgJ2FsaWduJywgJ2JldmVsbGVkJywgJ2Nsb3NlJywgJ2NvbHVtbnNhbGlnbicsICdjb2x1bW5saW5lcycsICdjb2x1bW5zcGFuJywgJ2Rlbm9tYWxpZ24nLCAnZGVwdGgnLCAnZGlyJywgJ2Rpc3BsYXknLCAnZGlzcGxheXN0eWxlJywgJ2VuY29kaW5nJywgJ2ZlbmNlJywgJ2ZyYW1lJywgJ2hlaWdodCcsICdocmVmJywgJ2lkJywgJ2xhcmdlb3AnLCAnbGVuZ3RoJywgJ2xpbmV0aGlja25lc3MnLCAnbHNwYWNlJywgJ2xxdW90ZScsICdtYXRoYmFja2dyb3VuZCcsICdtYXRoY29sb3InLCAnbWF0aHNpemUnLCAnbWF0aHZhcmlhbnQnLCAnbWF4c2l6ZScsICdtaW5zaXplJywgJ21vdmFibGVsaW1pdHMnLCAnbm90YXRpb24nLCAnbnVtYWxpZ24nLCAnb3BlbicsICdyb3dhbGlnbicsICdyb3dsaW5lcycsICdyb3dzcGFjaW5nJywgJ3Jvd3NwYW4nLCAncnNwYWNlJywgJ3JxdW90ZScsICdzY3JpcHRsZXZlbCcsICdzY3JpcHRtaW5zaXplJywgJ3NjcmlwdHNpemVtdWx0aXBsaWVyJywgJ3NlbGVjdGlvbicsICdzZXBhcmF0b3InLCAnc2VwYXJhdG9ycycsICdzdHJldGNoeScsICdzdWJzY3JpcHRzaGlmdCcsICdzdXBzY3JpcHRzaGlmdCcsICdzeW1tZXRyaWMnLCAndm9mZnNldCcsICd3aWR0aCcsICd4bWxucyddKTtcblxuICB2YXIgeG1sID0gZnJlZXplKFsneGxpbms6aHJlZicsICd4bWw6aWQnLCAneGxpbms6dGl0bGUnLCAneG1sOnNwYWNlJywgJ3htbG5zOnhsaW5rJ10pO1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL2JldHRlci1yZWdleFxuICB2YXIgTVVTVEFDSEVfRVhQUiA9IHNlYWwoL1xce1xce1tcXHNcXFNdKnxbXFxzXFxTXSpcXH1cXH0vZ20pOyAvLyBTcGVjaWZ5IHRlbXBsYXRlIGRldGVjdGlvbiByZWdleCBmb3IgU0FGRV9GT1JfVEVNUExBVEVTIG1vZGVcbiAgdmFyIEVSQl9FWFBSID0gc2VhbCgvPCVbXFxzXFxTXSp8W1xcc1xcU10qJT4vZ20pO1xuICB2YXIgREFUQV9BVFRSID0gc2VhbCgvXmRhdGEtW1xcLVxcdy5cXHUwMEI3LVxcdUZGRkZdLyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbiAgdmFyIEFSSUFfQVRUUiA9IHNlYWwoL15hcmlhLVtcXC1cXHddKyQvKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuICB2YXIgSVNfQUxMT1dFRF9VUkkgPSBzZWFsKC9eKD86KD86KD86ZnxodCl0cHM/fG1haWx0b3x0ZWx8Y2FsbHRvfGNpZHx4bXBwKTp8W15hLXpdfFthLXorLlxcLV0rKD86W15hLXorLlxcLTpdfCQpKS9pIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbiAgKTtcbiAgdmFyIElTX1NDUklQVF9PUl9EQVRBID0gc2VhbCgvXig/OlxcdytzY3JpcHR8ZGF0YSk6L2kpO1xuICB2YXIgQVRUUl9XSElURVNQQUNFID0gc2VhbCgvW1xcdTAwMDAtXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MTgwRVxcdTIwMDAtXFx1MjAyOVxcdTIwNUZcXHUzMDAwXS9nIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29udHJvbC1yZWdleFxuICApO1xuXG4gIHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuICBmdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkkMShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxuXG4gIHZhciBnZXRHbG9iYWwgPSBmdW5jdGlvbiBnZXRHbG9iYWwoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IHdpbmRvdztcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5vLW9wIHBvbGljeSBmb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG4gICAqIERvbid0IGV4cG9ydCB0aGlzIGZ1bmN0aW9uIG91dHNpZGUgdGhpcyBtb2R1bGUhXG4gICAqIEBwYXJhbSB7P1RydXN0ZWRUeXBlUG9saWN5RmFjdG9yeX0gdHJ1c3RlZFR5cGVzIFRoZSBwb2xpY3kgZmFjdG9yeS5cbiAgICogQHBhcmFtIHtEb2N1bWVudH0gZG9jdW1lbnQgVGhlIGRvY3VtZW50IG9iamVjdCAodG8gZGV0ZXJtaW5lIHBvbGljeSBuYW1lIHN1ZmZpeClcbiAgICogQHJldHVybiB7P1RydXN0ZWRUeXBlUG9saWN5fSBUaGUgcG9saWN5IGNyZWF0ZWQgKG9yIG51bGwsIGlmIFRydXN0ZWQgVHlwZXNcbiAgICogYXJlIG5vdCBzdXBwb3J0ZWQpLlxuICAgKi9cbiAgdmFyIF9jcmVhdGVUcnVzdGVkVHlwZXNQb2xpY3kgPSBmdW5jdGlvbiBfY3JlYXRlVHJ1c3RlZFR5cGVzUG9saWN5KHRydXN0ZWRUeXBlcywgZG9jdW1lbnQpIHtcbiAgICBpZiAoKHR5cGVvZiB0cnVzdGVkVHlwZXMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHRydXN0ZWRUeXBlcykpICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgdHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gQWxsb3cgdGhlIGNhbGxlcnMgdG8gY29udHJvbCB0aGUgdW5pcXVlIHBvbGljeSBuYW1lXG4gICAgLy8gYnkgYWRkaW5nIGEgZGF0YS10dC1wb2xpY3ktc3VmZml4IHRvIHRoZSBzY3JpcHQgZWxlbWVudCB3aXRoIHRoZSBET01QdXJpZnkuXG4gICAgLy8gUG9saWN5IGNyZWF0aW9uIHdpdGggZHVwbGljYXRlIG5hbWVzIHRocm93cyBpbiBUcnVzdGVkIFR5cGVzLlxuICAgIHZhciBzdWZmaXggPSBudWxsO1xuICAgIHZhciBBVFRSX05BTUUgPSAnZGF0YS10dC1wb2xpY3ktc3VmZml4JztcbiAgICBpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdCAmJiBkb2N1bWVudC5jdXJyZW50U2NyaXB0Lmhhc0F0dHJpYnV0ZShBVFRSX05BTUUpKSB7XG4gICAgICBzdWZmaXggPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LmdldEF0dHJpYnV0ZShBVFRSX05BTUUpO1xuICAgIH1cblxuICAgIHZhciBwb2xpY3lOYW1lID0gJ2RvbXB1cmlmeScgKyAoc3VmZml4ID8gJyMnICsgc3VmZml4IDogJycpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5KHBvbGljeU5hbWUsIHtcbiAgICAgICAgY3JlYXRlSFRNTDogZnVuY3Rpb24gY3JlYXRlSFRNTChodG1sJCQxKSB7XG4gICAgICAgICAgcmV0dXJuIGh0bWwkJDE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIC8vIFBvbGljeSBjcmVhdGlvbiBmYWlsZWQgKG1vc3QgbGlrZWx5IGFub3RoZXIgRE9NUHVyaWZ5IHNjcmlwdCBoYXNcbiAgICAgIC8vIGFscmVhZHkgcnVuKS4gU2tpcCBjcmVhdGluZyB0aGUgcG9saWN5LCBhcyB0aGlzIHdpbGwgb25seSBjYXVzZSBlcnJvcnNcbiAgICAgIC8vIGlmIFRUIGFyZSBlbmZvcmNlZC5cbiAgICAgIGNvbnNvbGUud2FybignVHJ1c3RlZFR5cGVzIHBvbGljeSAnICsgcG9saWN5TmFtZSArICcgY291bGQgbm90IGJlIGNyZWF0ZWQuJyk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY3JlYXRlRE9NUHVyaWZ5KCkge1xuICAgIHZhciB3aW5kb3cgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGdldEdsb2JhbCgpO1xuXG4gICAgdmFyIERPTVB1cmlmeSA9IGZ1bmN0aW9uIERPTVB1cmlmeShyb290KSB7XG4gICAgICByZXR1cm4gY3JlYXRlRE9NUHVyaWZ5KHJvb3QpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBWZXJzaW9uIGxhYmVsLCBleHBvc2VkIGZvciBlYXNpZXIgY2hlY2tzXG4gICAgICogaWYgRE9NUHVyaWZ5IGlzIHVwIHRvIGRhdGUgb3Igbm90XG4gICAgICovXG4gICAgRE9NUHVyaWZ5LnZlcnNpb24gPSAnMi4yLjYnO1xuXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgZWxlbWVudHMgdGhhdCBET01QdXJpZnkgcmVtb3ZlZCBkdXJpbmcgc2FuaXRhdGlvbi5cbiAgICAgKiBFbXB0eSBpZiBub3RoaW5nIHdhcyByZW1vdmVkLlxuICAgICAqL1xuICAgIERPTVB1cmlmeS5yZW1vdmVkID0gW107XG5cbiAgICBpZiAoIXdpbmRvdyB8fCAhd2luZG93LmRvY3VtZW50IHx8IHdpbmRvdy5kb2N1bWVudC5ub2RlVHlwZSAhPT0gOSkge1xuICAgICAgLy8gTm90IHJ1bm5pbmcgaW4gYSBicm93c2VyLCBwcm92aWRlIGEgZmFjdG9yeSBmdW5jdGlvblxuICAgICAgLy8gc28gdGhhdCB5b3UgY2FuIHBhc3MgeW91ciBvd24gV2luZG93XG4gICAgICBET01QdXJpZnkuaXNTdXBwb3J0ZWQgPSBmYWxzZTtcblxuICAgICAgcmV0dXJuIERPTVB1cmlmeTtcbiAgICB9XG5cbiAgICB2YXIgb3JpZ2luYWxEb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcblxuICAgIHZhciBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudDtcbiAgICB2YXIgRG9jdW1lbnRGcmFnbWVudCA9IHdpbmRvdy5Eb2N1bWVudEZyYWdtZW50LFxuICAgICAgICBIVE1MVGVtcGxhdGVFbGVtZW50ID0gd2luZG93LkhUTUxUZW1wbGF0ZUVsZW1lbnQsXG4gICAgICAgIE5vZGUgPSB3aW5kb3cuTm9kZSxcbiAgICAgICAgRWxlbWVudCA9IHdpbmRvdy5FbGVtZW50LFxuICAgICAgICBOb2RlRmlsdGVyID0gd2luZG93Lk5vZGVGaWx0ZXIsXG4gICAgICAgIF93aW5kb3ckTmFtZWROb2RlTWFwID0gd2luZG93Lk5hbWVkTm9kZU1hcCxcbiAgICAgICAgTmFtZWROb2RlTWFwID0gX3dpbmRvdyROYW1lZE5vZGVNYXAgPT09IHVuZGVmaW5lZCA/IHdpbmRvdy5OYW1lZE5vZGVNYXAgfHwgd2luZG93Lk1vek5hbWVkQXR0ck1hcCA6IF93aW5kb3ckTmFtZWROb2RlTWFwLFxuICAgICAgICBUZXh0ID0gd2luZG93LlRleHQsXG4gICAgICAgIENvbW1lbnQgPSB3aW5kb3cuQ29tbWVudCxcbiAgICAgICAgRE9NUGFyc2VyID0gd2luZG93LkRPTVBhcnNlcixcbiAgICAgICAgdHJ1c3RlZFR5cGVzID0gd2luZG93LnRydXN0ZWRUeXBlcztcblxuXG4gICAgdmFyIEVsZW1lbnRQcm90b3R5cGUgPSBFbGVtZW50LnByb3RvdHlwZTtcblxuICAgIHZhciBjbG9uZU5vZGUgPSBsb29rdXBHZXR0ZXIoRWxlbWVudFByb3RvdHlwZSwgJ2Nsb25lTm9kZScpO1xuICAgIHZhciBnZXROZXh0U2libGluZyA9IGxvb2t1cEdldHRlcihFbGVtZW50UHJvdG90eXBlLCAnbmV4dFNpYmxpbmcnKTtcbiAgICB2YXIgZ2V0Q2hpbGROb2RlcyA9IGxvb2t1cEdldHRlcihFbGVtZW50UHJvdG90eXBlLCAnY2hpbGROb2RlcycpO1xuICAgIHZhciBnZXRQYXJlbnROb2RlID0gbG9va3VwR2V0dGVyKEVsZW1lbnRQcm90b3R5cGUsICdwYXJlbnROb2RlJyk7XG5cbiAgICAvLyBBcyBwZXIgaXNzdWUgIzQ3LCB0aGUgd2ViLWNvbXBvbmVudHMgcmVnaXN0cnkgaXMgaW5oZXJpdGVkIGJ5IGFcbiAgICAvLyBuZXcgZG9jdW1lbnQgY3JlYXRlZCB2aWEgY3JlYXRlSFRNTERvY3VtZW50LiBBcyBwZXIgdGhlIHNwZWNcbiAgICAvLyAoaHR0cDovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL2N1c3RvbS8jY3JlYXRpbmctYW5kLXBhc3NpbmctcmVnaXN0cmllcylcbiAgICAvLyBhIG5ldyBlbXB0eSByZWdpc3RyeSBpcyB1c2VkIHdoZW4gY3JlYXRpbmcgYSB0ZW1wbGF0ZSBjb250ZW50cyBvd25lclxuICAgIC8vIGRvY3VtZW50LCBzbyB3ZSB1c2UgdGhhdCBhcyBvdXIgcGFyZW50IGRvY3VtZW50IHRvIGVuc3VyZSBub3RoaW5nXG4gICAgLy8gaXMgaW5oZXJpdGVkLlxuICAgIGlmICh0eXBlb2YgSFRNTFRlbXBsYXRlRWxlbWVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgIGlmICh0ZW1wbGF0ZS5jb250ZW50ICYmIHRlbXBsYXRlLmNvbnRlbnQub3duZXJEb2N1bWVudCkge1xuICAgICAgICBkb2N1bWVudCA9IHRlbXBsYXRlLmNvbnRlbnQub3duZXJEb2N1bWVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdHJ1c3RlZFR5cGVzUG9saWN5ID0gX2NyZWF0ZVRydXN0ZWRUeXBlc1BvbGljeSh0cnVzdGVkVHlwZXMsIG9yaWdpbmFsRG9jdW1lbnQpO1xuICAgIHZhciBlbXB0eUhUTUwgPSB0cnVzdGVkVHlwZXNQb2xpY3kgJiYgUkVUVVJOX1RSVVNURURfVFlQRSA/IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVIVE1MKCcnKSA6ICcnO1xuXG4gICAgdmFyIF9kb2N1bWVudCA9IGRvY3VtZW50LFxuICAgICAgICBpbXBsZW1lbnRhdGlvbiA9IF9kb2N1bWVudC5pbXBsZW1lbnRhdGlvbixcbiAgICAgICAgY3JlYXRlTm9kZUl0ZXJhdG9yID0gX2RvY3VtZW50LmNyZWF0ZU5vZGVJdGVyYXRvcixcbiAgICAgICAgZ2V0RWxlbWVudHNCeVRhZ05hbWUgPSBfZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUsXG4gICAgICAgIGNyZWF0ZURvY3VtZW50RnJhZ21lbnQgPSBfZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudDtcbiAgICB2YXIgaW1wb3J0Tm9kZSA9IG9yaWdpbmFsRG9jdW1lbnQuaW1wb3J0Tm9kZTtcblxuXG4gICAgdmFyIGRvY3VtZW50TW9kZSA9IHt9O1xuICAgIHRyeSB7XG4gICAgICBkb2N1bWVudE1vZGUgPSBjbG9uZShkb2N1bWVudCkuZG9jdW1lbnRNb2RlID8gZG9jdW1lbnQuZG9jdW1lbnRNb2RlIDoge307XG4gICAgfSBjYXRjaCAoXykge31cblxuICAgIHZhciBob29rcyA9IHt9O1xuXG4gICAgLyoqXG4gICAgICogRXhwb3NlIHdoZXRoZXIgdGhpcyBicm93c2VyIHN1cHBvcnRzIHJ1bm5pbmcgdGhlIGZ1bGwgRE9NUHVyaWZ5LlxuICAgICAqL1xuICAgIERPTVB1cmlmeS5pc1N1cHBvcnRlZCA9IGltcGxlbWVudGF0aW9uICYmIHR5cGVvZiBpbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50TW9kZSAhPT0gOTtcblxuICAgIHZhciBNVVNUQUNIRV9FWFBSJCQxID0gTVVTVEFDSEVfRVhQUixcbiAgICAgICAgRVJCX0VYUFIkJDEgPSBFUkJfRVhQUixcbiAgICAgICAgREFUQV9BVFRSJCQxID0gREFUQV9BVFRSLFxuICAgICAgICBBUklBX0FUVFIkJDEgPSBBUklBX0FUVFIsXG4gICAgICAgIElTX1NDUklQVF9PUl9EQVRBJCQxID0gSVNfU0NSSVBUX09SX0RBVEEsXG4gICAgICAgIEFUVFJfV0hJVEVTUEFDRSQkMSA9IEFUVFJfV0hJVEVTUEFDRTtcbiAgICB2YXIgSVNfQUxMT1dFRF9VUkkkJDEgPSBJU19BTExPV0VEX1VSSTtcblxuICAgIC8qKlxuICAgICAqIFdlIGNvbnNpZGVyIHRoZSBlbGVtZW50cyBhbmQgYXR0cmlidXRlcyBiZWxvdyB0byBiZSBzYWZlLiBJZGVhbGx5XG4gICAgICogZG9uJ3QgYWRkIGFueSBuZXcgb25lcyBidXQgZmVlbCBmcmVlIHRvIHJlbW92ZSB1bndhbnRlZCBvbmVzLlxuICAgICAqL1xuXG4gICAgLyogYWxsb3dlZCBlbGVtZW50IG5hbWVzICovXG5cbiAgICB2YXIgQUxMT1dFRF9UQUdTID0gbnVsbDtcbiAgICB2YXIgREVGQVVMVF9BTExPV0VEX1RBR1MgPSBhZGRUb1NldCh7fSwgW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSQxKGh0bWwpLCBfdG9Db25zdW1hYmxlQXJyYXkkMShzdmcpLCBfdG9Db25zdW1hYmxlQXJyYXkkMShzdmdGaWx0ZXJzKSwgX3RvQ29uc3VtYWJsZUFycmF5JDEobWF0aE1sKSwgX3RvQ29uc3VtYWJsZUFycmF5JDEodGV4dCkpKTtcblxuICAgIC8qIEFsbG93ZWQgYXR0cmlidXRlIG5hbWVzICovXG4gICAgdmFyIEFMTE9XRURfQVRUUiA9IG51bGw7XG4gICAgdmFyIERFRkFVTFRfQUxMT1dFRF9BVFRSID0gYWRkVG9TZXQoe30sIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkkMShodG1sJDEpLCBfdG9Db25zdW1hYmxlQXJyYXkkMShzdmckMSksIF90b0NvbnN1bWFibGVBcnJheSQxKG1hdGhNbCQxKSwgX3RvQ29uc3VtYWJsZUFycmF5JDEoeG1sKSkpO1xuXG4gICAgLyogRXhwbGljaXRseSBmb3JiaWRkZW4gdGFncyAob3ZlcnJpZGVzIEFMTE9XRURfVEFHUy9BRERfVEFHUykgKi9cbiAgICB2YXIgRk9SQklEX1RBR1MgPSBudWxsO1xuXG4gICAgLyogRXhwbGljaXRseSBmb3JiaWRkZW4gYXR0cmlidXRlcyAob3ZlcnJpZGVzIEFMTE9XRURfQVRUUi9BRERfQVRUUikgKi9cbiAgICB2YXIgRk9SQklEX0FUVFIgPSBudWxsO1xuXG4gICAgLyogRGVjaWRlIGlmIEFSSUEgYXR0cmlidXRlcyBhcmUgb2theSAqL1xuICAgIHZhciBBTExPV19BUklBX0FUVFIgPSB0cnVlO1xuXG4gICAgLyogRGVjaWRlIGlmIGN1c3RvbSBkYXRhIGF0dHJpYnV0ZXMgYXJlIG9rYXkgKi9cbiAgICB2YXIgQUxMT1dfREFUQV9BVFRSID0gdHJ1ZTtcblxuICAgIC8qIERlY2lkZSBpZiB1bmtub3duIHByb3RvY29scyBhcmUgb2theSAqL1xuICAgIHZhciBBTExPV19VTktOT1dOX1BST1RPQ09MUyA9IGZhbHNlO1xuXG4gICAgLyogT3V0cHV0IHNob3VsZCBiZSBzYWZlIGZvciBjb21tb24gdGVtcGxhdGUgZW5naW5lcy5cbiAgICAgKiBUaGlzIG1lYW5zLCBET01QdXJpZnkgcmVtb3ZlcyBkYXRhIGF0dHJpYnV0ZXMsIG11c3RhY2hlcyBhbmQgRVJCXG4gICAgICovXG4gICAgdmFyIFNBRkVfRk9SX1RFTVBMQVRFUyA9IGZhbHNlO1xuXG4gICAgLyogRGVjaWRlIGlmIGRvY3VtZW50IHdpdGggPGh0bWw+Li4uIHNob3VsZCBiZSByZXR1cm5lZCAqL1xuICAgIHZhciBXSE9MRV9ET0NVTUVOVCA9IGZhbHNlO1xuXG4gICAgLyogVHJhY2sgd2hldGhlciBjb25maWcgaXMgYWxyZWFkeSBzZXQgb24gdGhpcyBpbnN0YW5jZSBvZiBET01QdXJpZnkuICovXG4gICAgdmFyIFNFVF9DT05GSUcgPSBmYWxzZTtcblxuICAgIC8qIERlY2lkZSBpZiBhbGwgZWxlbWVudHMgKGUuZy4gc3R5bGUsIHNjcmlwdCkgbXVzdCBiZSBjaGlsZHJlbiBvZlxuICAgICAqIGRvY3VtZW50LmJvZHkuIEJ5IGRlZmF1bHQsIGJyb3dzZXJzIG1pZ2h0IG1vdmUgdGhlbSB0byBkb2N1bWVudC5oZWFkICovXG4gICAgdmFyIEZPUkNFX0JPRFkgPSBmYWxzZTtcblxuICAgIC8qIERlY2lkZSBpZiBhIERPTSBgSFRNTEJvZHlFbGVtZW50YCBzaG91bGQgYmUgcmV0dXJuZWQsIGluc3RlYWQgb2YgYSBodG1sXG4gICAgICogc3RyaW5nIChvciBhIFRydXN0ZWRIVE1MIG9iamVjdCBpZiBUcnVzdGVkIFR5cGVzIGFyZSBzdXBwb3J0ZWQpLlxuICAgICAqIElmIGBXSE9MRV9ET0NVTUVOVGAgaXMgZW5hYmxlZCBhIGBIVE1MSHRtbEVsZW1lbnRgIHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZFxuICAgICAqL1xuICAgIHZhciBSRVRVUk5fRE9NID0gZmFsc2U7XG5cbiAgICAvKiBEZWNpZGUgaWYgYSBET00gYERvY3VtZW50RnJhZ21lbnRgIHNob3VsZCBiZSByZXR1cm5lZCwgaW5zdGVhZCBvZiBhIGh0bWxcbiAgICAgKiBzdHJpbmcgIChvciBhIFRydXN0ZWRIVE1MIG9iamVjdCBpZiBUcnVzdGVkIFR5cGVzIGFyZSBzdXBwb3J0ZWQpICovXG4gICAgdmFyIFJFVFVSTl9ET01fRlJBR01FTlQgPSBmYWxzZTtcblxuICAgIC8qIElmIGBSRVRVUk5fRE9NYCBvciBgUkVUVVJOX0RPTV9GUkFHTUVOVGAgaXMgZW5hYmxlZCwgZGVjaWRlIGlmIHRoZSByZXR1cm5lZCBET01cbiAgICAgKiBgTm9kZWAgaXMgaW1wb3J0ZWQgaW50byB0aGUgY3VycmVudCBgRG9jdW1lbnRgLiBJZiB0aGlzIGZsYWcgaXMgbm90IGVuYWJsZWQgdGhlXG4gICAgICogYE5vZGVgIHdpbGwgYmVsb25nIChpdHMgb3duZXJEb2N1bWVudCkgdG8gYSBmcmVzaCBgSFRNTERvY3VtZW50YCwgY3JlYXRlZCBieVxuICAgICAqIERPTVB1cmlmeS5cbiAgICAgKlxuICAgICAqIFRoaXMgZGVmYXVsdHMgdG8gYHRydWVgIHN0YXJ0aW5nIERPTVB1cmlmeSAyLjIuMC4gTm90ZSB0aGF0IHNldHRpbmcgaXQgdG8gYGZhbHNlYFxuICAgICAqIG1pZ2h0IGNhdXNlIFhTUyBmcm9tIGF0dGFja3MgaGlkZGVuIGluIGNsb3NlZCBzaGFkb3dyb290cyBpbiBjYXNlIHRoZSBicm93c2VyXG4gICAgICogc3VwcG9ydHMgRGVjbGFyYXRpdmUgU2hhZG93OiBET00gaHR0cHM6Ly93ZWIuZGV2L2RlY2xhcmF0aXZlLXNoYWRvdy1kb20vXG4gICAgICovXG4gICAgdmFyIFJFVFVSTl9ET01fSU1QT1JUID0gdHJ1ZTtcblxuICAgIC8qIFRyeSB0byByZXR1cm4gYSBUcnVzdGVkIFR5cGUgb2JqZWN0IGluc3RlYWQgb2YgYSBzdHJpbmcsIHJldHVybiBhIHN0cmluZyBpblxuICAgICAqIGNhc2UgVHJ1c3RlZCBUeXBlcyBhcmUgbm90IHN1cHBvcnRlZCAgKi9cbiAgICB2YXIgUkVUVVJOX1RSVVNURURfVFlQRSA9IGZhbHNlO1xuXG4gICAgLyogT3V0cHV0IHNob3VsZCBiZSBmcmVlIGZyb20gRE9NIGNsb2JiZXJpbmcgYXR0YWNrcz8gKi9cbiAgICB2YXIgU0FOSVRJWkVfRE9NID0gdHJ1ZTtcblxuICAgIC8qIEtlZXAgZWxlbWVudCBjb250ZW50IHdoZW4gcmVtb3ZpbmcgZWxlbWVudD8gKi9cbiAgICB2YXIgS0VFUF9DT05URU5UID0gdHJ1ZTtcblxuICAgIC8qIElmIGEgYE5vZGVgIGlzIHBhc3NlZCB0byBzYW5pdGl6ZSgpLCB0aGVuIHBlcmZvcm1zIHNhbml0aXphdGlvbiBpbi1wbGFjZSBpbnN0ZWFkXG4gICAgICogb2YgaW1wb3J0aW5nIGl0IGludG8gYSBuZXcgRG9jdW1lbnQgYW5kIHJldHVybmluZyBhIHNhbml0aXplZCBjb3B5ICovXG4gICAgdmFyIElOX1BMQUNFID0gZmFsc2U7XG5cbiAgICAvKiBBbGxvdyB1c2FnZSBvZiBwcm9maWxlcyBsaWtlIGh0bWwsIHN2ZyBhbmQgbWF0aE1sICovXG4gICAgdmFyIFVTRV9QUk9GSUxFUyA9IHt9O1xuXG4gICAgLyogVGFncyB0byBpZ25vcmUgY29udGVudCBvZiB3aGVuIEtFRVBfQ09OVEVOVCBpcyB0cnVlICovXG4gICAgdmFyIEZPUkJJRF9DT05URU5UUyA9IGFkZFRvU2V0KHt9LCBbJ2Fubm90YXRpb24teG1sJywgJ2F1ZGlvJywgJ2NvbGdyb3VwJywgJ2Rlc2MnLCAnZm9yZWlnbm9iamVjdCcsICdoZWFkJywgJ2lmcmFtZScsICdtYXRoJywgJ21pJywgJ21uJywgJ21vJywgJ21zJywgJ210ZXh0JywgJ25vZW1iZWQnLCAnbm9mcmFtZXMnLCAnbm9zY3JpcHQnLCAncGxhaW50ZXh0JywgJ3NjcmlwdCcsICdzdHlsZScsICdzdmcnLCAndGVtcGxhdGUnLCAndGhlYWQnLCAndGl0bGUnLCAndmlkZW8nLCAneG1wJ10pO1xuXG4gICAgLyogVGFncyB0aGF0IGFyZSBzYWZlIGZvciBkYXRhOiBVUklzICovXG4gICAgdmFyIERBVEFfVVJJX1RBR1MgPSBudWxsO1xuICAgIHZhciBERUZBVUxUX0RBVEFfVVJJX1RBR1MgPSBhZGRUb1NldCh7fSwgWydhdWRpbycsICd2aWRlbycsICdpbWcnLCAnc291cmNlJywgJ2ltYWdlJywgJ3RyYWNrJ10pO1xuXG4gICAgLyogQXR0cmlidXRlcyBzYWZlIGZvciB2YWx1ZXMgbGlrZSBcImphdmFzY3JpcHQ6XCIgKi9cbiAgICB2YXIgVVJJX1NBRkVfQVRUUklCVVRFUyA9IG51bGw7XG4gICAgdmFyIERFRkFVTFRfVVJJX1NBRkVfQVRUUklCVVRFUyA9IGFkZFRvU2V0KHt9LCBbJ2FsdCcsICdjbGFzcycsICdmb3InLCAnaWQnLCAnbGFiZWwnLCAnbmFtZScsICdwYXR0ZXJuJywgJ3BsYWNlaG9sZGVyJywgJ3N1bW1hcnknLCAndGl0bGUnLCAndmFsdWUnLCAnc3R5bGUnLCAneG1sbnMnXSk7XG5cbiAgICAvKiBLZWVwIGEgcmVmZXJlbmNlIHRvIGNvbmZpZyB0byBwYXNzIHRvIGhvb2tzICovXG4gICAgdmFyIENPTkZJRyA9IG51bGw7XG5cbiAgICAvKiBJZGVhbGx5LCBkbyBub3QgdG91Y2ggYW55dGhpbmcgYmVsb3cgdGhpcyBsaW5lICovXG4gICAgLyogX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fX19fXyAqL1xuXG4gICAgdmFyIGZvcm1FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuXG4gICAgLyoqXG4gICAgICogX3BhcnNlQ29uZmlnXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGNmZyBvcHRpb25hbCBjb25maWcgbGl0ZXJhbFxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgdmFyIF9wYXJzZUNvbmZpZyA9IGZ1bmN0aW9uIF9wYXJzZUNvbmZpZyhjZmcpIHtcbiAgICAgIGlmIChDT05GSUcgJiYgQ09ORklHID09PSBjZmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvKiBTaGllbGQgY29uZmlndXJhdGlvbiBvYmplY3QgZnJvbSB0YW1wZXJpbmcgKi9cbiAgICAgIGlmICghY2ZnIHx8ICh0eXBlb2YgY2ZnID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjZmcpKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgY2ZnID0ge307XG4gICAgICB9XG5cbiAgICAgIC8qIFNoaWVsZCBjb25maWd1cmF0aW9uIG9iamVjdCBmcm9tIHByb3RvdHlwZSBwb2xsdXRpb24gKi9cbiAgICAgIGNmZyA9IGNsb25lKGNmZyk7XG5cbiAgICAgIC8qIFNldCBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgKi9cbiAgICAgIEFMTE9XRURfVEFHUyA9ICdBTExPV0VEX1RBR1MnIGluIGNmZyA/IGFkZFRvU2V0KHt9LCBjZmcuQUxMT1dFRF9UQUdTKSA6IERFRkFVTFRfQUxMT1dFRF9UQUdTO1xuICAgICAgQUxMT1dFRF9BVFRSID0gJ0FMTE9XRURfQVRUUicgaW4gY2ZnID8gYWRkVG9TZXQoe30sIGNmZy5BTExPV0VEX0FUVFIpIDogREVGQVVMVF9BTExPV0VEX0FUVFI7XG4gICAgICBVUklfU0FGRV9BVFRSSUJVVEVTID0gJ0FERF9VUklfU0FGRV9BVFRSJyBpbiBjZmcgPyBhZGRUb1NldChjbG9uZShERUZBVUxUX1VSSV9TQUZFX0FUVFJJQlVURVMpLCBjZmcuQUREX1VSSV9TQUZFX0FUVFIpIDogREVGQVVMVF9VUklfU0FGRV9BVFRSSUJVVEVTO1xuICAgICAgREFUQV9VUklfVEFHUyA9ICdBRERfREFUQV9VUklfVEFHUycgaW4gY2ZnID8gYWRkVG9TZXQoY2xvbmUoREVGQVVMVF9EQVRBX1VSSV9UQUdTKSwgY2ZnLkFERF9EQVRBX1VSSV9UQUdTKSA6IERFRkFVTFRfREFUQV9VUklfVEFHUztcbiAgICAgIEZPUkJJRF9UQUdTID0gJ0ZPUkJJRF9UQUdTJyBpbiBjZmcgPyBhZGRUb1NldCh7fSwgY2ZnLkZPUkJJRF9UQUdTKSA6IHt9O1xuICAgICAgRk9SQklEX0FUVFIgPSAnRk9SQklEX0FUVFInIGluIGNmZyA/IGFkZFRvU2V0KHt9LCBjZmcuRk9SQklEX0FUVFIpIDoge307XG4gICAgICBVU0VfUFJPRklMRVMgPSAnVVNFX1BST0ZJTEVTJyBpbiBjZmcgPyBjZmcuVVNFX1BST0ZJTEVTIDogZmFsc2U7XG4gICAgICBBTExPV19BUklBX0FUVFIgPSBjZmcuQUxMT1dfQVJJQV9BVFRSICE9PSBmYWxzZTsgLy8gRGVmYXVsdCB0cnVlXG4gICAgICBBTExPV19EQVRBX0FUVFIgPSBjZmcuQUxMT1dfREFUQV9BVFRSICE9PSBmYWxzZTsgLy8gRGVmYXVsdCB0cnVlXG4gICAgICBBTExPV19VTktOT1dOX1BST1RPQ09MUyA9IGNmZy5BTExPV19VTktOT1dOX1BST1RPQ09MUyB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgICAgU0FGRV9GT1JfVEVNUExBVEVTID0gY2ZnLlNBRkVfRk9SX1RFTVBMQVRFUyB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgICAgV0hPTEVfRE9DVU1FTlQgPSBjZmcuV0hPTEVfRE9DVU1FTlQgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICAgIFJFVFVSTl9ET00gPSBjZmcuUkVUVVJOX0RPTSB8fCBmYWxzZTsgLy8gRGVmYXVsdCBmYWxzZVxuICAgICAgUkVUVVJOX0RPTV9GUkFHTUVOVCA9IGNmZy5SRVRVUk5fRE9NX0ZSQUdNRU5UIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgICBSRVRVUk5fRE9NX0lNUE9SVCA9IGNmZy5SRVRVUk5fRE9NX0lNUE9SVCAhPT0gZmFsc2U7IC8vIERlZmF1bHQgdHJ1ZVxuICAgICAgUkVUVVJOX1RSVVNURURfVFlQRSA9IGNmZy5SRVRVUk5fVFJVU1RFRF9UWVBFIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgICBGT1JDRV9CT0RZID0gY2ZnLkZPUkNFX0JPRFkgfHwgZmFsc2U7IC8vIERlZmF1bHQgZmFsc2VcbiAgICAgIFNBTklUSVpFX0RPTSA9IGNmZy5TQU5JVElaRV9ET00gIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICAgIEtFRVBfQ09OVEVOVCA9IGNmZy5LRUVQX0NPTlRFTlQgIT09IGZhbHNlOyAvLyBEZWZhdWx0IHRydWVcbiAgICAgIElOX1BMQUNFID0gY2ZnLklOX1BMQUNFIHx8IGZhbHNlOyAvLyBEZWZhdWx0IGZhbHNlXG4gICAgICBJU19BTExPV0VEX1VSSSQkMSA9IGNmZy5BTExPV0VEX1VSSV9SRUdFWFAgfHwgSVNfQUxMT1dFRF9VUkkkJDE7XG4gICAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTKSB7XG4gICAgICAgIEFMTE9XX0RBVEFfQVRUUiA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoUkVUVVJOX0RPTV9GUkFHTUVOVCkge1xuICAgICAgICBSRVRVUk5fRE9NID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyogUGFyc2UgcHJvZmlsZSBpbmZvICovXG4gICAgICBpZiAoVVNFX1BST0ZJTEVTKSB7XG4gICAgICAgIEFMTE9XRURfVEFHUyA9IGFkZFRvU2V0KHt9LCBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5JDEodGV4dCkpKTtcbiAgICAgICAgQUxMT1dFRF9BVFRSID0gW107XG4gICAgICAgIGlmIChVU0VfUFJPRklMRVMuaHRtbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgaHRtbCk7XG4gICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBodG1sJDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFVTRV9QUk9GSUxFUy5zdmcgPT09IHRydWUpIHtcbiAgICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIHN2Zyk7XG4gICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCBzdmckMSk7XG4gICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9BVFRSLCB4bWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFVTRV9QUk9GSUxFUy5zdmdGaWx0ZXJzID09PSB0cnVlKSB7XG4gICAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBzdmdGaWx0ZXJzKTtcbiAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHN2ZyQxKTtcbiAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoVVNFX1BST0ZJTEVTLm1hdGhNbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgbWF0aE1sKTtcbiAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIG1hdGhNbCQxKTtcbiAgICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIHhtbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyogTWVyZ2UgY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzICovXG4gICAgICBpZiAoY2ZnLkFERF9UQUdTKSB7XG4gICAgICAgIGlmIChBTExPV0VEX1RBR1MgPT09IERFRkFVTFRfQUxMT1dFRF9UQUdTKSB7XG4gICAgICAgICAgQUxMT1dFRF9UQUdTID0gY2xvbmUoQUxMT1dFRF9UQUdTKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkZFRvU2V0KEFMTE9XRURfVEFHUywgY2ZnLkFERF9UQUdTKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNmZy5BRERfQVRUUikge1xuICAgICAgICBpZiAoQUxMT1dFRF9BVFRSID09PSBERUZBVUxUX0FMTE9XRURfQVRUUikge1xuICAgICAgICAgIEFMTE9XRURfQVRUUiA9IGNsb25lKEFMTE9XRURfQVRUUik7XG4gICAgICAgIH1cblxuICAgICAgICBhZGRUb1NldChBTExPV0VEX0FUVFIsIGNmZy5BRERfQVRUUik7XG4gICAgICB9XG5cbiAgICAgIGlmIChjZmcuQUREX1VSSV9TQUZFX0FUVFIpIHtcbiAgICAgICAgYWRkVG9TZXQoVVJJX1NBRkVfQVRUUklCVVRFUywgY2ZnLkFERF9VUklfU0FGRV9BVFRSKTtcbiAgICAgIH1cblxuICAgICAgLyogQWRkICN0ZXh0IGluIGNhc2UgS0VFUF9DT05URU5UIGlzIHNldCB0byB0cnVlICovXG4gICAgICBpZiAoS0VFUF9DT05URU5UKSB7XG4gICAgICAgIEFMTE9XRURfVEFHU1snI3RleHQnXSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qIEFkZCBodG1sLCBoZWFkIGFuZCBib2R5IHRvIEFMTE9XRURfVEFHUyBpbiBjYXNlIFdIT0xFX0RPQ1VNRU5UIGlzIHRydWUgKi9cbiAgICAgIGlmIChXSE9MRV9ET0NVTUVOVCkge1xuICAgICAgICBhZGRUb1NldChBTExPV0VEX1RBR1MsIFsnaHRtbCcsICdoZWFkJywgJ2JvZHknXSk7XG4gICAgICB9XG5cbiAgICAgIC8qIEFkZCB0Ym9keSB0byBBTExPV0VEX1RBR1MgaW4gY2FzZSB0YWJsZXMgYXJlIHBlcm1pdHRlZCwgc2VlICMyODYsICMzNjUgKi9cbiAgICAgIGlmIChBTExPV0VEX1RBR1MudGFibGUpIHtcbiAgICAgICAgYWRkVG9TZXQoQUxMT1dFRF9UQUdTLCBbJ3Rib2R5J10pO1xuICAgICAgICBkZWxldGUgRk9SQklEX1RBR1MudGJvZHk7XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXZlbnQgZnVydGhlciBtYW5pcHVsYXRpb24gb2YgY29uZmlndXJhdGlvbi5cbiAgICAgIC8vIE5vdCBhdmFpbGFibGUgaW4gSUU4LCBTYWZhcmkgNSwgZXRjLlxuICAgICAgaWYgKGZyZWV6ZSkge1xuICAgICAgICBmcmVlemUoY2ZnKTtcbiAgICAgIH1cblxuICAgICAgQ09ORklHID0gY2ZnO1xuICAgIH07XG5cbiAgICB2YXIgTUFUSE1MX1RFWFRfSU5URUdSQVRJT05fUE9JTlRTID0gYWRkVG9TZXQoe30sIFsnbWknLCAnbW8nLCAnbW4nLCAnbXMnLCAnbXRleHQnXSk7XG5cbiAgICB2YXIgSFRNTF9JTlRFR1JBVElPTl9QT0lOVFMgPSBhZGRUb1NldCh7fSwgWydmb3JlaWdub2JqZWN0JywgJ2Rlc2MnLCAndGl0bGUnLCAnYW5ub3RhdGlvbi14bWwnXSk7XG5cbiAgICAvKiBLZWVwIHRyYWNrIG9mIGFsbCBwb3NzaWJsZSBTVkcgYW5kIE1hdGhNTCB0YWdzXG4gICAgICogc28gdGhhdCB3ZSBjYW4gcGVyZm9ybSB0aGUgbmFtZXNwYWNlIGNoZWNrc1xuICAgICAqIGNvcnJlY3RseS4gKi9cbiAgICB2YXIgQUxMX1NWR19UQUdTID0gYWRkVG9TZXQoe30sIHN2Zyk7XG4gICAgYWRkVG9TZXQoQUxMX1NWR19UQUdTLCBzdmdGaWx0ZXJzKTtcbiAgICBhZGRUb1NldChBTExfU1ZHX1RBR1MsIHN2Z0Rpc2FsbG93ZWQpO1xuXG4gICAgdmFyIEFMTF9NQVRITUxfVEFHUyA9IGFkZFRvU2V0KHt9LCBtYXRoTWwpO1xuICAgIGFkZFRvU2V0KEFMTF9NQVRITUxfVEFHUywgbWF0aE1sRGlzYWxsb3dlZCk7XG5cbiAgICB2YXIgTUFUSE1MX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbiAgICB2YXIgU1ZHX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG4gICAgdmFyIEhUTUxfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0VsZW1lbnR9IGVsZW1lbnQgYSBET00gZWxlbWVudCB3aG9zZSBuYW1lc3BhY2UgaXMgYmVpbmcgY2hlY2tlZFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm4gZmFsc2UgaWYgdGhlIGVsZW1lbnQgaGFzIGFcbiAgICAgKiAgbmFtZXNwYWNlIHRoYXQgYSBzcGVjLWNvbXBsaWFudCBwYXJzZXIgd291bGQgbmV2ZXJcbiAgICAgKiAgcmV0dXJuLiBSZXR1cm4gdHJ1ZSBvdGhlcndpc2UuXG4gICAgICovXG4gICAgdmFyIF9jaGVja1ZhbGlkTmFtZXNwYWNlID0gZnVuY3Rpb24gX2NoZWNrVmFsaWROYW1lc3BhY2UoZWxlbWVudCkge1xuICAgICAgdmFyIHBhcmVudCA9IGdldFBhcmVudE5vZGUoZWxlbWVudCk7XG5cbiAgICAgIC8vIEluIEpTRE9NLCBpZiB3ZSdyZSBpbnNpZGUgc2hhZG93IERPTSwgdGhlbiBwYXJlbnROb2RlXG4gICAgICAvLyBjYW4gYmUgbnVsbC4gV2UganVzdCBzaW11bGF0ZSBwYXJlbnQgaW4gdGhpcyBjYXNlLlxuICAgICAgaWYgKCFwYXJlbnQgfHwgIXBhcmVudC50YWdOYW1lKSB7XG4gICAgICAgIHBhcmVudCA9IHtcbiAgICAgICAgICBuYW1lc3BhY2VVUkk6IEhUTUxfTkFNRVNQQUNFLFxuICAgICAgICAgIHRhZ05hbWU6ICd0ZW1wbGF0ZSdcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRhZ05hbWUgPSBzdHJpbmdUb0xvd2VyQ2FzZShlbGVtZW50LnRhZ05hbWUpO1xuICAgICAgdmFyIHBhcmVudFRhZ05hbWUgPSBzdHJpbmdUb0xvd2VyQ2FzZShwYXJlbnQudGFnTmFtZSk7XG5cbiAgICAgIGlmIChlbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRSkge1xuICAgICAgICAvLyBUaGUgb25seSB3YXkgdG8gc3dpdGNoIGZyb20gSFRNTCBuYW1lc3BhY2UgdG8gU1ZHXG4gICAgICAgIC8vIGlzIHZpYSA8c3ZnPi4gSWYgaXQgaGFwcGVucyB2aWEgYW55IG90aGVyIHRhZywgdGhlblxuICAgICAgICAvLyBpdCBzaG91bGQgYmUga2lsbGVkLlxuICAgICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICByZXR1cm4gdGFnTmFtZSA9PT0gJ3N2Zyc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgb25seSB3YXkgdG8gc3dpdGNoIGZyb20gTWF0aE1MIHRvIFNWRyBpcyB2aWFcbiAgICAgICAgLy8gc3ZnIGlmIHBhcmVudCBpcyBlaXRoZXIgPGFubm90YXRpb24teG1sPiBvciBNYXRoTUxcbiAgICAgICAgLy8gdGV4dCBpbnRlZ3JhdGlvbiBwb2ludHMuXG4gICAgICAgIGlmIChwYXJlbnQubmFtZXNwYWNlVVJJID09PSBNQVRITUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgcmV0dXJuIHRhZ05hbWUgPT09ICdzdmcnICYmIChwYXJlbnRUYWdOYW1lID09PSAnYW5ub3RhdGlvbi14bWwnIHx8IE1BVEhNTF9URVhUX0lOVEVHUkFUSU9OX1BPSU5UU1twYXJlbnRUYWdOYW1lXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXZSBvbmx5IGFsbG93IGVsZW1lbnRzIHRoYXQgYXJlIGRlZmluZWQgaW4gU1ZHXG4gICAgICAgIC8vIHNwZWMuIEFsbCBvdGhlcnMgYXJlIGRpc2FsbG93ZWQgaW4gU1ZHIG5hbWVzcGFjZS5cbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oQUxMX1NWR19UQUdTW3RhZ05hbWVdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQubmFtZXNwYWNlVVJJID09PSBNQVRITUxfTkFNRVNQQUNFKSB7XG4gICAgICAgIC8vIFRoZSBvbmx5IHdheSB0byBzd2l0Y2ggZnJvbSBIVE1MIG5hbWVzcGFjZSB0byBNYXRoTUxcbiAgICAgICAgLy8gaXMgdmlhIDxtYXRoPi4gSWYgaXQgaGFwcGVucyB2aWEgYW55IG90aGVyIHRhZywgdGhlblxuICAgICAgICAvLyBpdCBzaG91bGQgYmUga2lsbGVkLlxuICAgICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICByZXR1cm4gdGFnTmFtZSA9PT0gJ21hdGgnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIG9ubHkgd2F5IHRvIHN3aXRjaCBmcm9tIFNWRyB0byBNYXRoTUwgaXMgdmlhXG4gICAgICAgIC8vIDxtYXRoPiBhbmQgSFRNTCBpbnRlZ3JhdGlvbiBwb2ludHNcbiAgICAgICAgaWYgKHBhcmVudC5uYW1lc3BhY2VVUkkgPT09IFNWR19OQU1FU1BBQ0UpIHtcbiAgICAgICAgICByZXR1cm4gdGFnTmFtZSA9PT0gJ21hdGgnICYmIEhUTUxfSU5URUdSQVRJT05fUE9JTlRTW3BhcmVudFRhZ05hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2Ugb25seSBhbGxvdyBlbGVtZW50cyB0aGF0IGFyZSBkZWZpbmVkIGluIE1hdGhNTFxuICAgICAgICAvLyBzcGVjLiBBbGwgb3RoZXJzIGFyZSBkaXNhbGxvd2VkIGluIE1hdGhNTCBuYW1lc3BhY2UuXG4gICAgICAgIHJldHVybiBCb29sZWFuKEFMTF9NQVRITUxfVEFHU1t0YWdOYW1lXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50Lm5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgLy8gVGhlIG9ubHkgd2F5IHRvIHN3aXRjaCBmcm9tIFNWRyB0byBIVE1MIGlzIHZpYVxuICAgICAgICAvLyBIVE1MIGludGVncmF0aW9uIHBvaW50cywgYW5kIGZyb20gTWF0aE1MIHRvIEhUTUxcbiAgICAgICAgLy8gaXMgdmlhIE1hdGhNTCB0ZXh0IGludGVncmF0aW9uIHBvaW50c1xuICAgICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gU1ZHX05BTUVTUEFDRSAmJiAhSFRNTF9JTlRFR1JBVElPTl9QT0lOVFNbcGFyZW50VGFnTmFtZV0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gTUFUSE1MX05BTUVTUEFDRSAmJiAhTUFUSE1MX1RFWFRfSU5URUdSQVRJT05fUE9JTlRTW3BhcmVudFRhZ05hbWVdKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2VydGFpbiBlbGVtZW50cyBhcmUgYWxsb3dlZCBpbiBib3RoIFNWRyBhbmQgSFRNTFxuICAgICAgICAvLyBuYW1lc3BhY2UuIFdlIG5lZWQgdG8gc3BlY2lmeSB0aGVtIGV4cGxpY2l0bHlcbiAgICAgICAgLy8gc28gdGhhdCB0aGV5IGRvbid0IGdldCBlcnJvbm91c2x5IGRlbGV0ZWQgZnJvbVxuICAgICAgICAvLyBIVE1MIG5hbWVzcGFjZS5cbiAgICAgICAgdmFyIGNvbW1vblN2Z0FuZEhUTUxFbGVtZW50cyA9IGFkZFRvU2V0KHt9LCBbJ3RpdGxlJywgJ3N0eWxlJywgJ2ZvbnQnLCAnYScsICdzY3JpcHQnXSk7XG5cbiAgICAgICAgLy8gV2UgZGlzYWxsb3cgdGFncyB0aGF0IGFyZSBzcGVjaWZpYyBmb3IgTWF0aE1MXG4gICAgICAgIC8vIG9yIFNWRyBhbmQgc2hvdWxkIG5ldmVyIGFwcGVhciBpbiBIVE1MIG5hbWVzcGFjZVxuICAgICAgICByZXR1cm4gIUFMTF9NQVRITUxfVEFHU1t0YWdOYW1lXSAmJiAoY29tbW9uU3ZnQW5kSFRNTEVsZW1lbnRzW3RhZ05hbWVdIHx8ICFBTExfU1ZHX1RBR1NbdGFnTmFtZV0pO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29kZSBzaG91bGQgbmV2ZXIgcmVhY2ggdGhpcyBwbGFjZSAodGhpcyBtZWFuc1xuICAgICAgLy8gdGhhdCB0aGUgZWxlbWVudCBzb21laG93IGdvdCBuYW1lc3BhY2UgdGhhdCBpcyBub3RcbiAgICAgIC8vIEhUTUwsIFNWRyBvciBNYXRoTUwpLiBSZXR1cm4gZmFsc2UganVzdCBpbiBjYXNlLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBfZm9yY2VSZW1vdmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge05vZGV9IG5vZGUgYSBET00gbm9kZVxuICAgICAqL1xuICAgIHZhciBfZm9yY2VSZW1vdmUgPSBmdW5jdGlvbiBfZm9yY2VSZW1vdmUobm9kZSkge1xuICAgICAgYXJyYXlQdXNoKERPTVB1cmlmeS5yZW1vdmVkLCB7IGVsZW1lbnQ6IG5vZGUgfSk7XG4gICAgICB0cnkge1xuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbm9kZS5vdXRlckhUTUwgPSBlbXB0eUhUTUw7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIF9yZW1vdmVBdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSBhbiBBdHRyaWJ1dGUgbmFtZVxuICAgICAqIEBwYXJhbSAge05vZGV9IG5vZGUgYSBET00gbm9kZVxuICAgICAqL1xuICAgIHZhciBfcmVtb3ZlQXR0cmlidXRlID0gZnVuY3Rpb24gX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBub2RlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHtcbiAgICAgICAgICBhdHRyaWJ1dGU6IG5vZGUuZ2V0QXR0cmlidXRlTm9kZShuYW1lKSxcbiAgICAgICAgICBmcm9tOiBub2RlXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoXykge1xuICAgICAgICBhcnJheVB1c2goRE9NUHVyaWZ5LnJlbW92ZWQsIHtcbiAgICAgICAgICBhdHRyaWJ1dGU6IG51bGwsXG4gICAgICAgICAgZnJvbTogbm9kZVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIF9pbml0RG9jdW1lbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZGlydHkgYSBzdHJpbmcgb2YgZGlydHkgbWFya3VwXG4gICAgICogQHJldHVybiB7RG9jdW1lbnR9IGEgRE9NLCBmaWxsZWQgd2l0aCB0aGUgZGlydHkgbWFya3VwXG4gICAgICovXG4gICAgdmFyIF9pbml0RG9jdW1lbnQgPSBmdW5jdGlvbiBfaW5pdERvY3VtZW50KGRpcnR5KSB7XG4gICAgICAvKiBDcmVhdGUgYSBIVE1MIGRvY3VtZW50ICovXG4gICAgICB2YXIgZG9jID0gdm9pZCAwO1xuICAgICAgdmFyIGxlYWRpbmdXaGl0ZXNwYWNlID0gdm9pZCAwO1xuXG4gICAgICBpZiAoRk9SQ0VfQk9EWSkge1xuICAgICAgICBkaXJ0eSA9ICc8cmVtb3ZlPjwvcmVtb3ZlPicgKyBkaXJ0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIElmIEZPUkNFX0JPRFkgaXNuJ3QgdXNlZCwgbGVhZGluZyB3aGl0ZXNwYWNlIG5lZWRzIHRvIGJlIHByZXNlcnZlZCBtYW51YWxseSAqL1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IHN0cmluZ01hdGNoKGRpcnR5LCAvXltcXHJcXG5cXHQgXSsvKTtcbiAgICAgICAgbGVhZGluZ1doaXRlc3BhY2UgPSBtYXRjaGVzICYmIG1hdGNoZXNbMF07XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXJ0eVBheWxvYWQgPSB0cnVzdGVkVHlwZXNQb2xpY3kgPyB0cnVzdGVkVHlwZXNQb2xpY3kuY3JlYXRlSFRNTChkaXJ0eSkgOiBkaXJ0eTtcbiAgICAgIC8qIFVzZSB0aGUgRE9NUGFyc2VyIEFQSSBieSBkZWZhdWx0LCBmYWxsYmFjayBsYXRlciBpZiBuZWVkcyBiZSAqL1xuICAgICAgdHJ5IHtcbiAgICAgICAgZG9jID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhkaXJ0eVBheWxvYWQsICd0ZXh0L2h0bWwnKTtcbiAgICAgIH0gY2F0Y2ggKF8pIHt9XG5cbiAgICAgIC8qIFVzZSBjcmVhdGVIVE1MRG9jdW1lbnQgaW4gY2FzZSBET01QYXJzZXIgaXMgbm90IGF2YWlsYWJsZSAqL1xuICAgICAgaWYgKCFkb2MgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgZG9jID0gaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCcnKTtcbiAgICAgICAgdmFyIF9kb2MgPSBkb2MsXG4gICAgICAgICAgICBib2R5ID0gX2RvYy5ib2R5O1xuXG4gICAgICAgIGJvZHkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChib2R5LnBhcmVudE5vZGUuZmlyc3RFbGVtZW50Q2hpbGQpO1xuICAgICAgICBib2R5Lm91dGVySFRNTCA9IGRpcnR5UGF5bG9hZDtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpcnR5ICYmIGxlYWRpbmdXaGl0ZXNwYWNlKSB7XG4gICAgICAgIGRvYy5ib2R5Lmluc2VydEJlZm9yZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsZWFkaW5nV2hpdGVzcGFjZSksIGRvYy5ib2R5LmNoaWxkTm9kZXNbMF0gfHwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIC8qIFdvcmsgb24gd2hvbGUgZG9jdW1lbnQgb3IganVzdCBpdHMgYm9keSAqL1xuICAgICAgcmV0dXJuIGdldEVsZW1lbnRzQnlUYWdOYW1lLmNhbGwoZG9jLCBXSE9MRV9ET0NVTUVOVCA/ICdodG1sJyA6ICdib2R5JylbMF07XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIF9jcmVhdGVJdGVyYXRvclxuICAgICAqXG4gICAgICogQHBhcmFtICB7RG9jdW1lbnR9IHJvb3QgZG9jdW1lbnQvZnJhZ21lbnQgdG8gY3JlYXRlIGl0ZXJhdG9yIGZvclxuICAgICAqIEByZXR1cm4ge0l0ZXJhdG9yfSBpdGVyYXRvciBpbnN0YW5jZVxuICAgICAqL1xuICAgIHZhciBfY3JlYXRlSXRlcmF0b3IgPSBmdW5jdGlvbiBfY3JlYXRlSXRlcmF0b3Iocm9vdCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZU5vZGVJdGVyYXRvci5jYWxsKHJvb3Qub3duZXJEb2N1bWVudCB8fCByb290LCByb290LCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCB8IE5vZGVGaWx0ZXIuU0hPV19DT01NRU5UIHwgTm9kZUZpbHRlci5TSE9XX1RFWFQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVDtcbiAgICAgIH0sIGZhbHNlKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogX2lzQ2xvYmJlcmVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOb2RlfSBlbG0gZWxlbWVudCB0byBjaGVjayBmb3IgY2xvYmJlcmluZyBhdHRhY2tzXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiBjbG9iYmVyZWQsIGZhbHNlIGlmIHNhZmVcbiAgICAgKi9cbiAgICB2YXIgX2lzQ2xvYmJlcmVkID0gZnVuY3Rpb24gX2lzQ2xvYmJlcmVkKGVsbSkge1xuICAgICAgaWYgKGVsbSBpbnN0YW5jZW9mIFRleHQgfHwgZWxtIGluc3RhbmNlb2YgQ29tbWVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZWxtLm5vZGVOYW1lICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxtLnRleHRDb250ZW50ICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxtLnJlbW92ZUNoaWxkICE9PSAnZnVuY3Rpb24nIHx8ICEoZWxtLmF0dHJpYnV0ZXMgaW5zdGFuY2VvZiBOYW1lZE5vZGVNYXApIHx8IHR5cGVvZiBlbG0ucmVtb3ZlQXR0cmlidXRlICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBlbG0uc2V0QXR0cmlidXRlICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBlbG0ubmFtZXNwYWNlVVJJICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgZWxtLmluc2VydEJlZm9yZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBfaXNOb2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtOb2RlfSBvYmogb2JqZWN0IHRvIGNoZWNrIHdoZXRoZXIgaXQncyBhIERPTSBub2RlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpcyBvYmplY3QgaXMgYSBET00gbm9kZVxuICAgICAqL1xuICAgIHZhciBfaXNOb2RlID0gZnVuY3Rpb24gX2lzTm9kZShvYmplY3QpIHtcbiAgICAgIHJldHVybiAodHlwZW9mIE5vZGUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKE5vZGUpKSA9PT0gJ29iamVjdCcgPyBvYmplY3QgaW5zdGFuY2VvZiBOb2RlIDogb2JqZWN0ICYmICh0eXBlb2Ygb2JqZWN0ID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvYmplY3QpKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iamVjdC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZyc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIF9leGVjdXRlSG9va1xuICAgICAqIEV4ZWN1dGUgdXNlciBjb25maWd1cmFibGUgaG9va3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZW50cnlQb2ludCAgTmFtZSBvZiB0aGUgaG9vaydzIGVudHJ5IHBvaW50XG4gICAgICogQHBhcmFtICB7Tm9kZX0gY3VycmVudE5vZGUgbm9kZSB0byB3b3JrIG9uIHdpdGggdGhlIGhvb2tcbiAgICAgKiBAcGFyYW0gIHtPYmplY3R9IGRhdGEgYWRkaXRpb25hbCBob29rIHBhcmFtZXRlcnNcbiAgICAgKi9cbiAgICB2YXIgX2V4ZWN1dGVIb29rID0gZnVuY3Rpb24gX2V4ZWN1dGVIb29rKGVudHJ5UG9pbnQsIGN1cnJlbnROb2RlLCBkYXRhKSB7XG4gICAgICBpZiAoIWhvb2tzW2VudHJ5UG9pbnRdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYXJyYXlGb3JFYWNoKGhvb2tzW2VudHJ5UG9pbnRdLCBmdW5jdGlvbiAoaG9vaykge1xuICAgICAgICBob29rLmNhbGwoRE9NUHVyaWZ5LCBjdXJyZW50Tm9kZSwgZGF0YSwgQ09ORklHKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBfc2FuaXRpemVFbGVtZW50c1xuICAgICAqXG4gICAgICogQHByb3RlY3Qgbm9kZU5hbWVcbiAgICAgKiBAcHJvdGVjdCB0ZXh0Q29udGVudFxuICAgICAqIEBwcm90ZWN0IHJlbW92ZUNoaWxkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICB7Tm9kZX0gY3VycmVudE5vZGUgdG8gY2hlY2sgZm9yIHBlcm1pc3Npb24gdG8gZXhpc3RcbiAgICAgKiBAcmV0dXJuICB7Qm9vbGVhbn0gdHJ1ZSBpZiBub2RlIHdhcyBraWxsZWQsIGZhbHNlIGlmIGxlZnQgYWxpdmVcbiAgICAgKi9cbiAgICB2YXIgX3Nhbml0aXplRWxlbWVudHMgPSBmdW5jdGlvbiBfc2FuaXRpemVFbGVtZW50cyhjdXJyZW50Tm9kZSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSB2b2lkIDA7XG5cbiAgICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICAgIF9leGVjdXRlSG9vaygnYmVmb3JlU2FuaXRpemVFbGVtZW50cycsIGN1cnJlbnROb2RlLCBudWxsKTtcblxuICAgICAgLyogQ2hlY2sgaWYgZWxlbWVudCBpcyBjbG9iYmVyZWQgb3IgY2FuIGNsb2JiZXIgKi9cbiAgICAgIGlmIChfaXNDbG9iYmVyZWQoY3VycmVudE5vZGUpKSB7XG4gICAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvKiBDaGVjayBpZiB0YWduYW1lIGNvbnRhaW5zIFVuaWNvZGUgKi9cbiAgICAgIGlmIChzdHJpbmdNYXRjaChjdXJyZW50Tm9kZS5ub2RlTmFtZSwgL1tcXHUwMDgwLVxcdUZGRkZdLykpIHtcbiAgICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qIE5vdyBsZXQncyBjaGVjayB0aGUgZWxlbWVudCdzIHR5cGUgYW5kIG5hbWUgKi9cbiAgICAgIHZhciB0YWdOYW1lID0gc3RyaW5nVG9Mb3dlckNhc2UoY3VycmVudE5vZGUubm9kZU5hbWUpO1xuXG4gICAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgICBfZXhlY3V0ZUhvb2soJ3Vwb25TYW5pdGl6ZUVsZW1lbnQnLCBjdXJyZW50Tm9kZSwge1xuICAgICAgICB0YWdOYW1lOiB0YWdOYW1lLFxuICAgICAgICBhbGxvd2VkVGFnczogQUxMT1dFRF9UQUdTXG4gICAgICB9KTtcblxuICAgICAgLyogRGV0ZWN0IG1YU1MgYXR0ZW1wdHMgYWJ1c2luZyBuYW1lc3BhY2UgY29uZnVzaW9uICovXG4gICAgICBpZiAoIV9pc05vZGUoY3VycmVudE5vZGUuZmlyc3RFbGVtZW50Q2hpbGQpICYmICghX2lzTm9kZShjdXJyZW50Tm9kZS5jb250ZW50KSB8fCAhX2lzTm9kZShjdXJyZW50Tm9kZS5jb250ZW50LmZpcnN0RWxlbWVudENoaWxkKSkgJiYgcmVnRXhwVGVzdCgvPFsvXFx3XS9nLCBjdXJyZW50Tm9kZS5pbm5lckhUTUwpICYmIHJlZ0V4cFRlc3QoLzxbL1xcd10vZywgY3VycmVudE5vZGUudGV4dENvbnRlbnQpKSB7XG4gICAgICAgIF9mb3JjZVJlbW92ZShjdXJyZW50Tm9kZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvKiBSZW1vdmUgZWxlbWVudCBpZiBhbnl0aGluZyBmb3JiaWRzIGl0cyBwcmVzZW5jZSAqL1xuICAgICAgaWYgKCFBTExPV0VEX1RBR1NbdGFnTmFtZV0gfHwgRk9SQklEX1RBR1NbdGFnTmFtZV0pIHtcbiAgICAgICAgLyogS2VlcCBjb250ZW50IGV4Y2VwdCBmb3IgYmFkLWxpc3RlZCBlbGVtZW50cyAqL1xuICAgICAgICBpZiAoS0VFUF9DT05URU5UICYmICFGT1JCSURfQ09OVEVOVFNbdGFnTmFtZV0pIHtcbiAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoY3VycmVudE5vZGUpO1xuICAgICAgICAgIHZhciBjaGlsZE5vZGVzID0gZ2V0Q2hpbGROb2RlcyhjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgdmFyIGNoaWxkQ291bnQgPSBjaGlsZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKHZhciBpID0gY2hpbGRDb3VudCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShjbG9uZU5vZGUoY2hpbGROb2Rlc1tpXSwgdHJ1ZSksIGdldE5leHRTaWJsaW5nKGN1cnJlbnROb2RlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX2ZvcmNlUmVtb3ZlKGN1cnJlbnROb2RlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8qIENoZWNrIHdoZXRoZXIgZWxlbWVudCBoYXMgYSB2YWxpZCBuYW1lc3BhY2UgKi9cbiAgICAgIGlmIChjdXJyZW50Tm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgIV9jaGVja1ZhbGlkTmFtZXNwYWNlKGN1cnJlbnROb2RlKSkge1xuICAgICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCh0YWdOYW1lID09PSAnbm9zY3JpcHQnIHx8IHRhZ05hbWUgPT09ICdub2VtYmVkJykgJiYgcmVnRXhwVGVzdCgvPFxcL25vKHNjcmlwdHxlbWJlZCkvaSwgY3VycmVudE5vZGUuaW5uZXJIVE1MKSkge1xuICAgICAgICBfZm9yY2VSZW1vdmUoY3VycmVudE5vZGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLyogU2FuaXRpemUgZWxlbWVudCBjb250ZW50IHRvIGJlIHRlbXBsYXRlLXNhZmUgKi9cbiAgICAgIGlmIChTQUZFX0ZPUl9URU1QTEFURVMgJiYgY3VycmVudE5vZGUubm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgLyogR2V0IHRoZSBlbGVtZW50J3MgdGV4dCBjb250ZW50ICovXG4gICAgICAgIGNvbnRlbnQgPSBjdXJyZW50Tm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgY29udGVudCA9IHN0cmluZ1JlcGxhY2UoY29udGVudCwgTVVTVEFDSEVfRVhQUiQkMSwgJyAnKTtcbiAgICAgICAgY29udGVudCA9IHN0cmluZ1JlcGxhY2UoY29udGVudCwgRVJCX0VYUFIkJDEsICcgJyk7XG4gICAgICAgIGlmIChjdXJyZW50Tm9kZS50ZXh0Q29udGVudCAhPT0gY29udGVudCkge1xuICAgICAgICAgIGFycmF5UHVzaChET01QdXJpZnkucmVtb3ZlZCwgeyBlbGVtZW50OiBjdXJyZW50Tm9kZS5jbG9uZU5vZGUoKSB9KTtcbiAgICAgICAgICBjdXJyZW50Tm9kZS50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgICAgX2V4ZWN1dGVIb29rKCdhZnRlclNhbml0aXplRWxlbWVudHMnLCBjdXJyZW50Tm9kZSwgbnVsbCk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogX2lzVmFsaWRBdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gbGNUYWcgTG93ZXJjYXNlIHRhZyBuYW1lIG9mIGNvbnRhaW5pbmcgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGxjTmFtZSBMb3dlcmNhc2UgYXR0cmlidXRlIG5hbWUuXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSB2YWx1ZSBBdHRyaWJ1dGUgdmFsdWUuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgdmFsaWQsIG90aGVyd2lzZSBmYWxzZS5cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuICAgIHZhciBfaXNWYWxpZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIF9pc1ZhbGlkQXR0cmlidXRlKGxjVGFnLCBsY05hbWUsIHZhbHVlKSB7XG4gICAgICAvKiBNYWtlIHN1cmUgYXR0cmlidXRlIGNhbm5vdCBjbG9iYmVyICovXG4gICAgICBpZiAoU0FOSVRJWkVfRE9NICYmIChsY05hbWUgPT09ICdpZCcgfHwgbGNOYW1lID09PSAnbmFtZScpICYmICh2YWx1ZSBpbiBkb2N1bWVudCB8fCB2YWx1ZSBpbiBmb3JtRWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvKiBBbGxvdyB2YWxpZCBkYXRhLSogYXR0cmlidXRlczogQXQgbGVhc3Qgb25lIGNoYXJhY3RlciBhZnRlciBcIi1cIlxuICAgICAgICAgIChodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCNlbWJlZGRpbmctY3VzdG9tLW5vbi12aXNpYmxlLWRhdGEtd2l0aC10aGUtZGF0YS0qLWF0dHJpYnV0ZXMpXG4gICAgICAgICAgWE1MLWNvbXBhdGlibGUgKGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2luZnJhc3RydWN0dXJlLmh0bWwjeG1sLWNvbXBhdGlibGUgYW5kIGh0dHA6Ly93d3cudzMub3JnL1RSL3htbC8jZDBlODA0KVxuICAgICAgICAgIFdlIGRvbid0IG5lZWQgdG8gY2hlY2sgdGhlIHZhbHVlOyBpdCdzIGFsd2F5cyBVUkkgc2FmZS4gKi9cbiAgICAgIGlmIChBTExPV19EQVRBX0FUVFIgJiYgcmVnRXhwVGVzdChEQVRBX0FUVFIkJDEsIGxjTmFtZSkpIDsgZWxzZSBpZiAoQUxMT1dfQVJJQV9BVFRSICYmIHJlZ0V4cFRlc3QoQVJJQV9BVFRSJCQxLCBsY05hbWUpKSA7IGVsc2UgaWYgKCFBTExPV0VEX0FUVFJbbGNOYW1lXSB8fCBGT1JCSURfQVRUUltsY05hbWVdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICAvKiBDaGVjayB2YWx1ZSBpcyBzYWZlLiBGaXJzdCwgaXMgYXR0ciBpbmVydD8gSWYgc28sIGlzIHNhZmUgKi9cbiAgICAgIH0gZWxzZSBpZiAoVVJJX1NBRkVfQVRUUklCVVRFU1tsY05hbWVdKSA7IGVsc2UgaWYgKHJlZ0V4cFRlc3QoSVNfQUxMT1dFRF9VUkkkJDEsIHN0cmluZ1JlcGxhY2UodmFsdWUsIEFUVFJfV0hJVEVTUEFDRSQkMSwgJycpKSkgOyBlbHNlIGlmICgobGNOYW1lID09PSAnc3JjJyB8fCBsY05hbWUgPT09ICd4bGluazpocmVmJyB8fCBsY05hbWUgPT09ICdocmVmJykgJiYgbGNUYWcgIT09ICdzY3JpcHQnICYmIHN0cmluZ0luZGV4T2YodmFsdWUsICdkYXRhOicpID09PSAwICYmIERBVEFfVVJJX1RBR1NbbGNUYWddKSA7IGVsc2UgaWYgKEFMTE9XX1VOS05PV05fUFJPVE9DT0xTICYmICFyZWdFeHBUZXN0KElTX1NDUklQVF9PUl9EQVRBJCQxLCBzdHJpbmdSZXBsYWNlKHZhbHVlLCBBVFRSX1dISVRFU1BBQ0UkJDEsICcnKSkpIDsgZWxzZSBpZiAoIXZhbHVlKSA7IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBfc2FuaXRpemVBdHRyaWJ1dGVzXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdCBhdHRyaWJ1dGVzXG4gICAgICogQHByb3RlY3Qgbm9kZU5hbWVcbiAgICAgKiBAcHJvdGVjdCByZW1vdmVBdHRyaWJ1dGVcbiAgICAgKiBAcHJvdGVjdCBzZXRBdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge05vZGV9IGN1cnJlbnROb2RlIHRvIHNhbml0aXplXG4gICAgICovXG4gICAgdmFyIF9zYW5pdGl6ZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBfc2FuaXRpemVBdHRyaWJ1dGVzKGN1cnJlbnROb2RlKSB7XG4gICAgICB2YXIgYXR0ciA9IHZvaWQgMDtcbiAgICAgIHZhciB2YWx1ZSA9IHZvaWQgMDtcbiAgICAgIHZhciBsY05hbWUgPSB2b2lkIDA7XG4gICAgICB2YXIgbCA9IHZvaWQgMDtcbiAgICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICAgIF9leGVjdXRlSG9vaygnYmVmb3JlU2FuaXRpemVBdHRyaWJ1dGVzJywgY3VycmVudE5vZGUsIG51bGwpO1xuXG4gICAgICB2YXIgYXR0cmlidXRlcyA9IGN1cnJlbnROb2RlLmF0dHJpYnV0ZXM7XG5cbiAgICAgIC8qIENoZWNrIGlmIHdlIGhhdmUgYXR0cmlidXRlczsgaWYgbm90IHdlIG1pZ2h0IGhhdmUgYSB0ZXh0IG5vZGUgKi9cblxuICAgICAgaWYgKCFhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGhvb2tFdmVudCA9IHtcbiAgICAgICAgYXR0ck5hbWU6ICcnLFxuICAgICAgICBhdHRyVmFsdWU6ICcnLFxuICAgICAgICBrZWVwQXR0cjogdHJ1ZSxcbiAgICAgICAgYWxsb3dlZEF0dHJpYnV0ZXM6IEFMTE9XRURfQVRUUlxuICAgICAgfTtcbiAgICAgIGwgPSBhdHRyaWJ1dGVzLmxlbmd0aDtcblxuICAgICAgLyogR28gYmFja3dhcmRzIG92ZXIgYWxsIGF0dHJpYnV0ZXM7IHNhZmVseSByZW1vdmUgYmFkIG9uZXMgKi9cbiAgICAgIHdoaWxlIChsLS0pIHtcbiAgICAgICAgYXR0ciA9IGF0dHJpYnV0ZXNbbF07XG4gICAgICAgIHZhciBfYXR0ciA9IGF0dHIsXG4gICAgICAgICAgICBuYW1lID0gX2F0dHIubmFtZSxcbiAgICAgICAgICAgIG5hbWVzcGFjZVVSSSA9IF9hdHRyLm5hbWVzcGFjZVVSSTtcblxuICAgICAgICB2YWx1ZSA9IHN0cmluZ1RyaW0oYXR0ci52YWx1ZSk7XG4gICAgICAgIGxjTmFtZSA9IHN0cmluZ1RvTG93ZXJDYXNlKG5hbWUpO1xuXG4gICAgICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICAgICAgaG9va0V2ZW50LmF0dHJOYW1lID0gbGNOYW1lO1xuICAgICAgICBob29rRXZlbnQuYXR0clZhbHVlID0gdmFsdWU7XG4gICAgICAgIGhvb2tFdmVudC5rZWVwQXR0ciA9IHRydWU7XG4gICAgICAgIGhvb2tFdmVudC5mb3JjZUtlZXBBdHRyID0gdW5kZWZpbmVkOyAvLyBBbGxvd3MgZGV2ZWxvcGVycyB0byBzZWUgdGhpcyBpcyBhIHByb3BlcnR5IHRoZXkgY2FuIHNldFxuICAgICAgICBfZXhlY3V0ZUhvb2soJ3Vwb25TYW5pdGl6ZUF0dHJpYnV0ZScsIGN1cnJlbnROb2RlLCBob29rRXZlbnQpO1xuICAgICAgICB2YWx1ZSA9IGhvb2tFdmVudC5hdHRyVmFsdWU7XG4gICAgICAgIC8qIERpZCB0aGUgaG9va3MgYXBwcm92ZSBvZiB0aGUgYXR0cmlidXRlPyAqL1xuICAgICAgICBpZiAoaG9va0V2ZW50LmZvcmNlS2VlcEF0dHIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIFJlbW92ZSBhdHRyaWJ1dGUgKi9cbiAgICAgICAgX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBjdXJyZW50Tm9kZSk7XG5cbiAgICAgICAgLyogRGlkIHRoZSBob29rcyBhcHByb3ZlIG9mIHRoZSBhdHRyaWJ1dGU/ICovXG4gICAgICAgIGlmICghaG9va0V2ZW50LmtlZXBBdHRyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBXb3JrIGFyb3VuZCBhIHNlY3VyaXR5IGlzc3VlIGluIGpRdWVyeSAzLjAgKi9cbiAgICAgICAgaWYgKHJlZ0V4cFRlc3QoL1xcLz4vaSwgdmFsdWUpKSB7XG4gICAgICAgICAgX3JlbW92ZUF0dHJpYnV0ZShuYW1lLCBjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBTYW5pdGl6ZSBhdHRyaWJ1dGUgY29udGVudCB0byBiZSB0ZW1wbGF0ZS1zYWZlICovXG4gICAgICAgIGlmIChTQUZFX0ZPUl9URU1QTEFURVMpIHtcbiAgICAgICAgICB2YWx1ZSA9IHN0cmluZ1JlcGxhY2UodmFsdWUsIE1VU1RBQ0hFX0VYUFIkJDEsICcgJyk7XG4gICAgICAgICAgdmFsdWUgPSBzdHJpbmdSZXBsYWNlKHZhbHVlLCBFUkJfRVhQUiQkMSwgJyAnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIElzIGB2YWx1ZWAgdmFsaWQgZm9yIHRoaXMgYXR0cmlidXRlPyAqL1xuICAgICAgICB2YXIgbGNUYWcgPSBjdXJyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoIV9pc1ZhbGlkQXR0cmlidXRlKGxjVGFnLCBsY05hbWUsIHZhbHVlKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogSGFuZGxlIGludmFsaWQgZGF0YS0qIGF0dHJpYnV0ZSBzZXQgYnkgdHJ5LWNhdGNoaW5nIGl0ICovXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKG5hbWVzcGFjZVVSSSkge1xuICAgICAgICAgICAgY3VycmVudE5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlVVJJLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIEZhbGxiYWNrIHRvIHNldEF0dHJpYnV0ZSgpIGZvciBicm93c2VyLXVucmVjb2duaXplZCBuYW1lc3BhY2VzIGUuZy4gXCJ4LXNjaGVtYVwiLiAqL1xuICAgICAgICAgICAgY3VycmVudE5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBhcnJheVBvcChET01QdXJpZnkucmVtb3ZlZCk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHt9XG4gICAgICB9XG5cbiAgICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICAgIF9leGVjdXRlSG9vaygnYWZ0ZXJTYW5pdGl6ZUF0dHJpYnV0ZXMnLCBjdXJyZW50Tm9kZSwgbnVsbCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIF9zYW5pdGl6ZVNoYWRvd0RPTVxuICAgICAqXG4gICAgICogQHBhcmFtICB7RG9jdW1lbnRGcmFnbWVudH0gZnJhZ21lbnQgdG8gaXRlcmF0ZSBvdmVyIHJlY3Vyc2l2ZWx5XG4gICAgICovXG4gICAgdmFyIF9zYW5pdGl6ZVNoYWRvd0RPTSA9IGZ1bmN0aW9uIF9zYW5pdGl6ZVNoYWRvd0RPTShmcmFnbWVudCkge1xuICAgICAgdmFyIHNoYWRvd05vZGUgPSB2b2lkIDA7XG4gICAgICB2YXIgc2hhZG93SXRlcmF0b3IgPSBfY3JlYXRlSXRlcmF0b3IoZnJhZ21lbnQpO1xuXG4gICAgICAvKiBFeGVjdXRlIGEgaG9vayBpZiBwcmVzZW50ICovXG4gICAgICBfZXhlY3V0ZUhvb2soJ2JlZm9yZVNhbml0aXplU2hhZG93RE9NJywgZnJhZ21lbnQsIG51bGwpO1xuXG4gICAgICB3aGlsZSAoc2hhZG93Tm9kZSA9IHNoYWRvd0l0ZXJhdG9yLm5leHROb2RlKCkpIHtcbiAgICAgICAgLyogRXhlY3V0ZSBhIGhvb2sgaWYgcHJlc2VudCAqL1xuICAgICAgICBfZXhlY3V0ZUhvb2soJ3Vwb25TYW5pdGl6ZVNoYWRvd05vZGUnLCBzaGFkb3dOb2RlLCBudWxsKTtcblxuICAgICAgICAvKiBTYW5pdGl6ZSB0YWdzIGFuZCBlbGVtZW50cyAqL1xuICAgICAgICBpZiAoX3Nhbml0aXplRWxlbWVudHMoc2hhZG93Tm9kZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIERlZXAgc2hhZG93IERPTSBkZXRlY3RlZCAqL1xuICAgICAgICBpZiAoc2hhZG93Tm9kZS5jb250ZW50IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICAgIF9zYW5pdGl6ZVNoYWRvd0RPTShzaGFkb3dOb2RlLmNvbnRlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyogQ2hlY2sgYXR0cmlidXRlcywgc2FuaXRpemUgaWYgbmVjZXNzYXJ5ICovXG4gICAgICAgIF9zYW5pdGl6ZUF0dHJpYnV0ZXMoc2hhZG93Tm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8qIEV4ZWN1dGUgYSBob29rIGlmIHByZXNlbnQgKi9cbiAgICAgIF9leGVjdXRlSG9vaygnYWZ0ZXJTYW5pdGl6ZVNoYWRvd0RPTScsIGZyYWdtZW50LCBudWxsKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU2FuaXRpemVcbiAgICAgKiBQdWJsaWMgbWV0aG9kIHByb3ZpZGluZyBjb3JlIHNhbml0YXRpb24gZnVuY3Rpb25hbGl0eVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8Tm9kZX0gZGlydHkgc3RyaW5nIG9yIERPTSBub2RlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgICBET01QdXJpZnkuc2FuaXRpemUgPSBmdW5jdGlvbiAoZGlydHksIGNmZykge1xuICAgICAgdmFyIGJvZHkgPSB2b2lkIDA7XG4gICAgICB2YXIgaW1wb3J0ZWROb2RlID0gdm9pZCAwO1xuICAgICAgdmFyIGN1cnJlbnROb2RlID0gdm9pZCAwO1xuICAgICAgdmFyIG9sZE5vZGUgPSB2b2lkIDA7XG4gICAgICB2YXIgcmV0dXJuTm9kZSA9IHZvaWQgMDtcbiAgICAgIC8qIE1ha2Ugc3VyZSB3ZSBoYXZlIGEgc3RyaW5nIHRvIHNhbml0aXplLlxuICAgICAgICBETyBOT1QgcmV0dXJuIGVhcmx5LCBhcyB0aGlzIHdpbGwgcmV0dXJuIHRoZSB3cm9uZyB0eXBlIGlmXG4gICAgICAgIHRoZSB1c2VyIGhhcyByZXF1ZXN0ZWQgYSBET00gb2JqZWN0IHJhdGhlciB0aGFuIGEgc3RyaW5nICovXG4gICAgICBpZiAoIWRpcnR5KSB7XG4gICAgICAgIGRpcnR5ID0gJzwhLS0+JztcbiAgICAgIH1cblxuICAgICAgLyogU3RyaW5naWZ5LCBpbiBjYXNlIGRpcnR5IGlzIGFuIG9iamVjdCAqL1xuICAgICAgaWYgKHR5cGVvZiBkaXJ0eSAhPT0gJ3N0cmluZycgJiYgIV9pc05vZGUoZGlydHkpKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZWdhdGVkLWNvbmRpdGlvblxuICAgICAgICBpZiAodHlwZW9mIGRpcnR5LnRvU3RyaW5nICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgdHlwZUVycm9yQ3JlYXRlKCd0b1N0cmluZyBpcyBub3QgYSBmdW5jdGlvbicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpcnR5ID0gZGlydHkudG9TdHJpbmcoKTtcbiAgICAgICAgICBpZiAodHlwZW9mIGRpcnR5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgdHlwZUVycm9yQ3JlYXRlKCdkaXJ0eSBpcyBub3QgYSBzdHJpbmcsIGFib3J0aW5nJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qIENoZWNrIHdlIGNhbiBydW4uIE90aGVyd2lzZSBmYWxsIGJhY2sgb3IgaWdub3JlICovXG4gICAgICBpZiAoIURPTVB1cmlmeS5pc1N1cHBvcnRlZCkge1xuICAgICAgICBpZiAoX3R5cGVvZih3aW5kb3cudG9TdGF0aWNIVE1MKSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHdpbmRvdy50b1N0YXRpY0hUTUwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGRpcnR5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy50b1N0YXRpY0hUTUwoZGlydHkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfaXNOb2RlKGRpcnR5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy50b1N0YXRpY0hUTUwoZGlydHkub3V0ZXJIVE1MKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGlydHk7XG4gICAgICB9XG5cbiAgICAgIC8qIEFzc2lnbiBjb25maWcgdmFycyAqL1xuICAgICAgaWYgKCFTRVRfQ09ORklHKSB7XG4gICAgICAgIF9wYXJzZUNvbmZpZyhjZmcpO1xuICAgICAgfVxuXG4gICAgICAvKiBDbGVhbiB1cCByZW1vdmVkIGVsZW1lbnRzICovXG4gICAgICBET01QdXJpZnkucmVtb3ZlZCA9IFtdO1xuXG4gICAgICAvKiBDaGVjayBpZiBkaXJ0eSBpcyBjb3JyZWN0bHkgdHlwZWQgZm9yIElOX1BMQUNFICovXG4gICAgICBpZiAodHlwZW9mIGRpcnR5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBJTl9QTEFDRSA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoSU5fUExBQ0UpIDsgZWxzZSBpZiAoZGlydHkgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgIC8qIElmIGRpcnR5IGlzIGEgRE9NIGVsZW1lbnQsIGFwcGVuZCB0byBhbiBlbXB0eSBkb2N1bWVudCB0byBhdm9pZFxuICAgICAgICAgICBlbGVtZW50cyBiZWluZyBzdHJpcHBlZCBieSB0aGUgcGFyc2VyICovXG4gICAgICAgIGJvZHkgPSBfaW5pdERvY3VtZW50KCc8IS0tLS0+Jyk7XG4gICAgICAgIGltcG9ydGVkTm9kZSA9IGJvZHkub3duZXJEb2N1bWVudC5pbXBvcnROb2RlKGRpcnR5LCB0cnVlKTtcbiAgICAgICAgaWYgKGltcG9ydGVkTm9kZS5ub2RlVHlwZSA9PT0gMSAmJiBpbXBvcnRlZE5vZGUubm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgICAgICAgIC8qIE5vZGUgaXMgYWxyZWFkeSBhIGJvZHksIHVzZSBhcyBpcyAqL1xuICAgICAgICAgIGJvZHkgPSBpbXBvcnRlZE5vZGU7XG4gICAgICAgIH0gZWxzZSBpZiAoaW1wb3J0ZWROb2RlLm5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICAgICAgICBib2R5ID0gaW1wb3J0ZWROb2RlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1ub2RlLWFwcGVuZFxuICAgICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoaW1wb3J0ZWROb2RlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogRXhpdCBkaXJlY3RseSBpZiB3ZSBoYXZlIG5vdGhpbmcgdG8gZG8gKi9cbiAgICAgICAgaWYgKCFSRVRVUk5fRE9NICYmICFTQUZFX0ZPUl9URU1QTEFURVMgJiYgIVdIT0xFX0RPQ1VNRU5UICYmXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1pbmNsdWRlc1xuICAgICAgICBkaXJ0eS5pbmRleE9mKCc8JykgPT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIHRydXN0ZWRUeXBlc1BvbGljeSAmJiBSRVRVUk5fVFJVU1RFRF9UWVBFID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoZGlydHkpIDogZGlydHk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBJbml0aWFsaXplIHRoZSBkb2N1bWVudCB0byB3b3JrIG9uICovXG4gICAgICAgIGJvZHkgPSBfaW5pdERvY3VtZW50KGRpcnR5KTtcblxuICAgICAgICAvKiBDaGVjayB3ZSBoYXZlIGEgRE9NIG5vZGUgZnJvbSB0aGUgZGF0YSAqL1xuICAgICAgICBpZiAoIWJvZHkpIHtcbiAgICAgICAgICByZXR1cm4gUkVUVVJOX0RPTSA/IG51bGwgOiBlbXB0eUhUTUw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyogUmVtb3ZlIGZpcnN0IGVsZW1lbnQgbm9kZSAob3VycykgaWYgRk9SQ0VfQk9EWSBpcyBzZXQgKi9cbiAgICAgIGlmIChib2R5ICYmIEZPUkNFX0JPRFkpIHtcbiAgICAgICAgX2ZvcmNlUmVtb3ZlKGJvZHkuZmlyc3RDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIC8qIEdldCBub2RlIGl0ZXJhdG9yICovXG4gICAgICB2YXIgbm9kZUl0ZXJhdG9yID0gX2NyZWF0ZUl0ZXJhdG9yKElOX1BMQUNFID8gZGlydHkgOiBib2R5KTtcblxuICAgICAgLyogTm93IHN0YXJ0IGl0ZXJhdGluZyBvdmVyIHRoZSBjcmVhdGVkIGRvY3VtZW50ICovXG4gICAgICB3aGlsZSAoY3VycmVudE5vZGUgPSBub2RlSXRlcmF0b3IubmV4dE5vZGUoKSkge1xuICAgICAgICAvKiBGaXggSUUncyBzdHJhbmdlIGJlaGF2aW9yIHdpdGggbWFuaXB1bGF0ZWQgdGV4dE5vZGVzICM4OSAqL1xuICAgICAgICBpZiAoY3VycmVudE5vZGUubm9kZVR5cGUgPT09IDMgJiYgY3VycmVudE5vZGUgPT09IG9sZE5vZGUpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIFNhbml0aXplIHRhZ3MgYW5kIGVsZW1lbnRzICovXG4gICAgICAgIGlmIChfc2FuaXRpemVFbGVtZW50cyhjdXJyZW50Tm9kZSkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIFNoYWRvdyBET00gZGV0ZWN0ZWQsIHNhbml0aXplIGl0ICovXG4gICAgICAgIGlmIChjdXJyZW50Tm9kZS5jb250ZW50IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICAgIF9zYW5pdGl6ZVNoYWRvd0RPTShjdXJyZW50Tm9kZS5jb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIENoZWNrIGF0dHJpYnV0ZXMsIHNhbml0aXplIGlmIG5lY2Vzc2FyeSAqL1xuICAgICAgICBfc2FuaXRpemVBdHRyaWJ1dGVzKGN1cnJlbnROb2RlKTtcblxuICAgICAgICBvbGROb2RlID0gY3VycmVudE5vZGU7XG4gICAgICB9XG5cbiAgICAgIG9sZE5vZGUgPSBudWxsO1xuXG4gICAgICAvKiBJZiB3ZSBzYW5pdGl6ZWQgYGRpcnR5YCBpbi1wbGFjZSwgcmV0dXJuIGl0LiAqL1xuICAgICAgaWYgKElOX1BMQUNFKSB7XG4gICAgICAgIHJldHVybiBkaXJ0eTtcbiAgICAgIH1cblxuICAgICAgLyogUmV0dXJuIHNhbml0aXplZCBzdHJpbmcgb3IgRE9NICovXG4gICAgICBpZiAoUkVUVVJOX0RPTSkge1xuICAgICAgICBpZiAoUkVUVVJOX0RPTV9GUkFHTUVOVCkge1xuICAgICAgICAgIHJldHVybk5vZGUgPSBjcmVhdGVEb2N1bWVudEZyYWdtZW50LmNhbGwoYm9keS5vd25lckRvY3VtZW50KTtcblxuICAgICAgICAgIHdoaWxlIChib2R5LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1ub2RlLWFwcGVuZFxuICAgICAgICAgICAgcmV0dXJuTm9kZS5hcHBlbmRDaGlsZChib2R5LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm5Ob2RlID0gYm9keTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChSRVRVUk5fRE9NX0lNUE9SVCkge1xuICAgICAgICAgIC8qXG4gICAgICAgICAgICBBZG9wdE5vZGUoKSBpcyBub3QgdXNlZCBiZWNhdXNlIGludGVybmFsIHN0YXRlIGlzIG5vdCByZXNldFxuICAgICAgICAgICAgKGUuZy4gdGhlIHBhc3QgbmFtZXMgbWFwIG9mIGEgSFRNTEZvcm1FbGVtZW50KSwgdGhpcyBpcyBzYWZlXG4gICAgICAgICAgICBpbiB0aGVvcnkgYnV0IHdlIHdvdWxkIHJhdGhlciBub3QgcmlzayBhbm90aGVyIGF0dGFjayB2ZWN0b3IuXG4gICAgICAgICAgICBUaGUgc3RhdGUgdGhhdCBpcyBjbG9uZWQgYnkgaW1wb3J0Tm9kZSgpIGlzIGV4cGxpY2l0bHkgZGVmaW5lZFxuICAgICAgICAgICAgYnkgdGhlIHNwZWNzLlxuICAgICAgICAgICovXG4gICAgICAgICAgcmV0dXJuTm9kZSA9IGltcG9ydE5vZGUuY2FsbChvcmlnaW5hbERvY3VtZW50LCByZXR1cm5Ob2RlLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXR1cm5Ob2RlO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VyaWFsaXplZEhUTUwgPSBXSE9MRV9ET0NVTUVOVCA/IGJvZHkub3V0ZXJIVE1MIDogYm9keS5pbm5lckhUTUw7XG5cbiAgICAgIC8qIFNhbml0aXplIGZpbmFsIHN0cmluZyB0ZW1wbGF0ZS1zYWZlICovXG4gICAgICBpZiAoU0FGRV9GT1JfVEVNUExBVEVTKSB7XG4gICAgICAgIHNlcmlhbGl6ZWRIVE1MID0gc3RyaW5nUmVwbGFjZShzZXJpYWxpemVkSFRNTCwgTVVTVEFDSEVfRVhQUiQkMSwgJyAnKTtcbiAgICAgICAgc2VyaWFsaXplZEhUTUwgPSBzdHJpbmdSZXBsYWNlKHNlcmlhbGl6ZWRIVE1MLCBFUkJfRVhQUiQkMSwgJyAnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydXN0ZWRUeXBlc1BvbGljeSAmJiBSRVRVUk5fVFJVU1RFRF9UWVBFID8gdHJ1c3RlZFR5cGVzUG9saWN5LmNyZWF0ZUhUTUwoc2VyaWFsaXplZEhUTUwpIDogc2VyaWFsaXplZEhUTUw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFB1YmxpYyBtZXRob2QgdG8gc2V0IHRoZSBjb25maWd1cmF0aW9uIG9uY2VcbiAgICAgKiBzZXRDb25maWdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICAgKi9cbiAgICBET01QdXJpZnkuc2V0Q29uZmlnID0gZnVuY3Rpb24gKGNmZykge1xuICAgICAgX3BhcnNlQ29uZmlnKGNmZyk7XG4gICAgICBTRVRfQ09ORklHID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHVibGljIG1ldGhvZCB0byByZW1vdmUgdGhlIGNvbmZpZ3VyYXRpb25cbiAgICAgKiBjbGVhckNvbmZpZ1xuICAgICAqXG4gICAgICovXG4gICAgRE9NUHVyaWZ5LmNsZWFyQ29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgICAgQ09ORklHID0gbnVsbDtcbiAgICAgIFNFVF9DT05GSUcgPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUHVibGljIG1ldGhvZCB0byBjaGVjayBpZiBhbiBhdHRyaWJ1dGUgdmFsdWUgaXMgdmFsaWQuXG4gICAgICogVXNlcyBsYXN0IHNldCBjb25maWcsIGlmIGFueS4gT3RoZXJ3aXNlLCB1c2VzIGNvbmZpZyBkZWZhdWx0cy5cbiAgICAgKiBpc1ZhbGlkQXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IHRhZyBUYWcgbmFtZSBvZiBjb250YWluaW5nIGVsZW1lbnQuXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBhdHRyIEF0dHJpYnV0ZSBuYW1lLlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gdmFsdWUgQXR0cmlidXRlIHZhbHVlLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIHZhbGlkLiBPdGhlcndpc2UsIHJldHVybnMgZmFsc2UuXG4gICAgICovXG4gICAgRE9NUHVyaWZ5LmlzVmFsaWRBdHRyaWJ1dGUgPSBmdW5jdGlvbiAodGFnLCBhdHRyLCB2YWx1ZSkge1xuICAgICAgLyogSW5pdGlhbGl6ZSBzaGFyZWQgY29uZmlnIHZhcnMgaWYgbmVjZXNzYXJ5LiAqL1xuICAgICAgaWYgKCFDT05GSUcpIHtcbiAgICAgICAgX3BhcnNlQ29uZmlnKHt9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxjVGFnID0gc3RyaW5nVG9Mb3dlckNhc2UodGFnKTtcbiAgICAgIHZhciBsY05hbWUgPSBzdHJpbmdUb0xvd2VyQ2FzZShhdHRyKTtcbiAgICAgIHJldHVybiBfaXNWYWxpZEF0dHJpYnV0ZShsY1RhZywgbGNOYW1lLCB2YWx1ZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEFkZEhvb2tcbiAgICAgKiBQdWJsaWMgbWV0aG9kIHRvIGFkZCBET01QdXJpZnkgaG9va3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBlbnRyeVBvaW50IGVudHJ5IHBvaW50IGZvciB0aGUgaG9vayB0byBhZGRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBob29rRnVuY3Rpb24gZnVuY3Rpb24gdG8gZXhlY3V0ZVxuICAgICAqL1xuICAgIERPTVB1cmlmeS5hZGRIb29rID0gZnVuY3Rpb24gKGVudHJ5UG9pbnQsIGhvb2tGdW5jdGlvbikge1xuICAgICAgaWYgKHR5cGVvZiBob29rRnVuY3Rpb24gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBob29rc1tlbnRyeVBvaW50XSA9IGhvb2tzW2VudHJ5UG9pbnRdIHx8IFtdO1xuICAgICAgYXJyYXlQdXNoKGhvb2tzW2VudHJ5UG9pbnRdLCBob29rRnVuY3Rpb24pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVIb29rXG4gICAgICogUHVibGljIG1ldGhvZCB0byByZW1vdmUgYSBET01QdXJpZnkgaG9vayBhdCBhIGdpdmVuIGVudHJ5UG9pbnRcbiAgICAgKiAocG9wcyBpdCBmcm9tIHRoZSBzdGFjayBvZiBob29rcyBpZiBtb3JlIGFyZSBwcmVzZW50KVxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGVudHJ5UG9pbnQgZW50cnkgcG9pbnQgZm9yIHRoZSBob29rIHRvIHJlbW92ZVxuICAgICAqL1xuICAgIERPTVB1cmlmeS5yZW1vdmVIb29rID0gZnVuY3Rpb24gKGVudHJ5UG9pbnQpIHtcbiAgICAgIGlmIChob29rc1tlbnRyeVBvaW50XSkge1xuICAgICAgICBhcnJheVBvcChob29rc1tlbnRyeVBvaW50XSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZUhvb2tzXG4gICAgICogUHVibGljIG1ldGhvZCB0byByZW1vdmUgYWxsIERPTVB1cmlmeSBob29rcyBhdCBhIGdpdmVuIGVudHJ5UG9pbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge1N0cmluZ30gZW50cnlQb2ludCBlbnRyeSBwb2ludCBmb3IgdGhlIGhvb2tzIHRvIHJlbW92ZVxuICAgICAqL1xuICAgIERPTVB1cmlmeS5yZW1vdmVIb29rcyA9IGZ1bmN0aW9uIChlbnRyeVBvaW50KSB7XG4gICAgICBpZiAoaG9va3NbZW50cnlQb2ludF0pIHtcbiAgICAgICAgaG9va3NbZW50cnlQb2ludF0gPSBbXTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlQWxsSG9va3NcbiAgICAgKiBQdWJsaWMgbWV0aG9kIHRvIHJlbW92ZSBhbGwgRE9NUHVyaWZ5IGhvb2tzXG4gICAgICpcbiAgICAgKi9cbiAgICBET01QdXJpZnkucmVtb3ZlQWxsSG9va3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBob29rcyA9IHt9O1xuICAgIH07XG5cbiAgICByZXR1cm4gRE9NUHVyaWZ5O1xuICB9XG5cbiAgdmFyIHB1cmlmeSA9IGNyZWF0ZURPTVB1cmlmeSgpO1xuXG4gIHJldHVybiBwdXJpZnk7XG5cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXB1cmlmeS5qcy5tYXBcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/dompurify/dist/purify.js\n");

/***/ }),

/***/ "./node_modules/lodash.startswith/index.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash.startswith/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0,\n    MAX_INTEGER = 1.7976931348623157e+308,\n    NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * The base implementation of `_.clamp` which doesn't coerce arguments.\n *\n * @private\n * @param {number} number The number to clamp.\n * @param {number} [lower] The lower bound.\n * @param {number} upper The upper bound.\n * @returns {number} Returns the clamped number.\n */\nfunction baseClamp(number, lower, upper) {\n  if (number === number) {\n    if (upper !== undefined) {\n      number = number <= upper ? number : upper;\n    }\n    if (lower !== undefined) {\n      number = number >= lower ? number : lower;\n    }\n  }\n  return number;\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a finite number.\n *\n * @static\n * @memberOf _\n * @since 4.12.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted number.\n * @example\n *\n * _.toFinite(3.2);\n * // => 3.2\n *\n * _.toFinite(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toFinite(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toFinite('3.2');\n * // => 3.2\n */\nfunction toFinite(value) {\n  if (!value) {\n    return value === 0 ? value : 0;\n  }\n  value = toNumber(value);\n  if (value === INFINITY || value === -INFINITY) {\n    var sign = (value < 0 ? -1 : 1);\n    return sign * MAX_INTEGER;\n  }\n  return value === value ? value : 0;\n}\n\n/**\n * Converts `value` to an integer.\n *\n * **Note:** This method is loosely based on\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {number} Returns the converted integer.\n * @example\n *\n * _.toInteger(3.2);\n * // => 3\n *\n * _.toInteger(Number.MIN_VALUE);\n * // => 0\n *\n * _.toInteger(Infinity);\n * // => 1.7976931348623157e+308\n *\n * _.toInteger('3.2');\n * // => 3\n */\nfunction toInteger(value) {\n  var result = toFinite(value),\n      remainder = result % 1;\n\n  return result === result ? (remainder ? result - remainder : result) : 0;\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Checks if `string` starts with the given target string.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category String\n * @param {string} [string=''] The string to inspect.\n * @param {string} [target] The string to search for.\n * @param {number} [position=0] The position to search from.\n * @returns {boolean} Returns `true` if `string` starts with `target`,\n *  else `false`.\n * @example\n *\n * _.startsWith('abc', 'a');\n * // => true\n *\n * _.startsWith('abc', 'b');\n * // => false\n *\n * _.startsWith('abc', 'b', 1);\n * // => true\n */\nfunction startsWith(string, target, position) {\n  string = toString(string);\n  position = baseClamp(toInteger(position), 0, string.length);\n  target = baseToString(target);\n  return string.slice(position, position + target.length) == target;\n}\n\nmodule.exports = startsWith;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbG9kYXNoLnN0YXJ0c3dpdGgvaW5kZXguanM/ZjM3ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2xvZGFzaC5zdGFydHN3aXRoL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDAsXG4gICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOCxcbiAgICBOQU4gPSAwIC8gMDtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbSA9IC9eXFxzK3xcXHMrJC9nO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNsYW1wYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjbGFtcC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXJdIFRoZSBsb3dlciBib3VuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjbGFtcGVkIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gYmFzZUNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XG4gIGlmIChudW1iZXIgPT09IG51bWJlcikge1xuICAgIGlmICh1cHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBudW1iZXIgPSBudW1iZXIgPD0gdXBwZXIgPyBudW1iZXIgOiB1cHBlcjtcbiAgICB9XG4gICAgaWYgKGxvd2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG51bWJlciA9IG51bWJlciA+PSBsb3dlciA/IG51bWJlciA6IGxvd2VyO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVtYmVyO1xufVxuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvU3RyaW5nYCB3aGljaCBkb2Vzbid0IGNvbnZlcnQgbnVsbGlzaFxuICogdmFsdWVzIHRvIGVtcHR5IHN0cmluZ3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUb1N0cmluZyh2YWx1ZSkge1xuICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGVcbiAqIFtsYW5ndWFnZSB0eXBlXShodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1sYW5ndWFnZS10eXBlcylcbiAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdCh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIHJldHVybiAhIXZhbHVlICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFwib2JqZWN0XCIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc09iamVjdExpa2Uoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc09iamVjdExpa2UobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdExpa2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBmaW5pdGUgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMi4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9GaW5pdGUoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9GaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvRmluaXRlKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0Zpbml0ZSgnMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9GaW5pdGUodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMDtcbiAgfVxuICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgaWYgKHZhbHVlID09PSBJTkZJTklUWSB8fCB2YWx1ZSA9PT0gLUlORklOSVRZKSB7XG4gICAgdmFyIHNpZ24gPSAodmFsdWUgPCAwID8gLTEgOiAxKTtcbiAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSO1xuICB9XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyB2YWx1ZSA6IDA7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvSW50ZWdlcmBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2ludGVnZXIpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9JbnRlZ2VyKDMuMik7XG4gKiAvLyA9PiAzXG4gKlxuICogXy50b0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiAwXG4gKlxuICogXy50b0ludGVnZXIoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvSW50ZWdlcignMy4yJyk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gdG9GaW5pdGUodmFsdWUpLFxuICAgICAgcmVtYWluZGVyID0gcmVzdWx0ICUgMTtcblxuICByZXR1cm4gcmVzdWx0ID09PSByZXN1bHQgPyAocmVtYWluZGVyID8gcmVzdWx0IC0gcmVtYWluZGVyIDogcmVzdWx0KSA6IDA7XG59XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKHJlVHJpbSwgJycpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9TdHJpbmcobnVsbCk7XG4gKiAvLyA9PiAnJ1xuICpcbiAqIF8udG9TdHJpbmcoLTApO1xuICogLy8gPT4gJy0wJ1xuICpcbiAqIF8udG9TdHJpbmcoWzEsIDIsIDNdKTtcbiAqIC8vID0+ICcxLDIsMydcbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyAnJyA6IGJhc2VUb1N0cmluZyh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIHRoZSBnaXZlbiB0YXJnZXQgc3RyaW5nLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj0wXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2Agc3RhcnRzIHdpdGggYHRhcmdldGAsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5zdGFydHNXaXRoKCdhYmMnLCAnYicpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJywgMSk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gIHBvc2l0aW9uID0gYmFzZUNsYW1wKHRvSW50ZWdlcihwb3NpdGlvbiksIDAsIHN0cmluZy5sZW5ndGgpO1xuICB0YXJnZXQgPSBiYXNlVG9TdHJpbmcodGFyZ2V0KTtcbiAgcmV0dXJuIHN0cmluZy5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyB0YXJnZXQubGVuZ3RoKSA9PSB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhcnRzV2l0aDtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lodash.startswith/index.js\n");

/***/ }),

/***/ "./node_modules/marked-images/marked-images.js":
/*!*****************************************************!*\
  !*** ./node_modules/marked-images/marked-images.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * marked-images.js\n *\n * marked.js plugin renderer for images\n * generate width=\"a\" and height=\"b\" attributes from axb pattern in title string E.g ![](src \"100x50\")\n *          attr=\"x\" from attr=x (with no \"\") e.g. ![](src \"width=100 height=50 align=right\")\n *          vimeo standard <iframe.. ></iframe> from ![](vimeo/nnn) where nnn is the vimeo id\n *\n * usage: marked.use(markedImages(opts))\n *\n * original function: copyright Christopher Jeffrey -- https://github.com/markedjs/marked (MIT License)\n * extension copyright 2015-2020, Jürgen Leschner - github.com/jldec/ - MIT license\n *\n**/\n\nvar startsWith = __webpack_require__(/*! lodash.startswith */ \"./node_modules/lodash.startswith/index.js\");\n\nmodule.exports = function markedImages(opts) {\n\n  opts = opts || {};\n  var imgRoute = opts.fqImages && (opts.fqImages.route || '/images/');\n  var imgPrefix = opts.fqImages && opts.fqImages.url;\n  var linkPrefix = opts.fqLinks || opts.relPath;\n  var xhtml = opts.xhtml;\n\n  return { renderer: {image: renderImage} };\n\n  function renderImage(href, title, text) {\n\n    var out, iframe;\n\n    if (imgPrefix && startsWith(href, imgRoute)) { href = imgPrefix + href; }\n    else if (linkPrefix && /^\\/([^/]|$)/.test(href)) { href = linkPrefix + href; }\n\n    if (href && (m = href.match(/vimeo\\/(\\d+)/i))) {\n      iframe = true;\n      out = '<iframe src=\"//player.vimeo.com/video/' + m[1] + '\"' +\n              ' frameborder=\"0\" webkitAllowFullScreen mozallowfullscreen allowFullScreen';\n    }\n    else {\n      out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\n    }\n\n    var a = (title && title.split(/\\s+/)) || [];\n    var b = [];\n    var m;\n    a.forEach(function(w) {\n      if ((m = w.match(/^(\\d+)x(\\d+)$/))) return (out += ' width=\"' + m[1] + '\" height=\"' + m[2] + '\"');\n      if ((m = w.match(/^(\\w+)=([\\w-]+)$/))) return (out += ' ' + m[1] + '=\"' + m[2] + '\"');\n      if (w) return b.push(w);\n    });\n    title = b.join(' ');\n\n    if (title) {\n      out += ' title=\"' + title + '\"';\n    }\n\n    out += iframe ? '></iframe>' :\n           xhtml ? '/>' :\n           '>';\n\n    return out;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2VkLWltYWdlcy9tYXJrZWQtaW1hZ2VzLmpzP2ViMTEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsbUJBQU8sQ0FBQyxvRUFBbUI7O0FBRTVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxZQUFZLG1CQUFtQjs7QUFFekM7O0FBRUE7O0FBRUEsa0RBQWtELHlCQUF5QjtBQUMzRSxzREFBc0QsMEJBQTBCOztBQUVoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL21hcmtlZC1pbWFnZXMvbWFya2VkLWltYWdlcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbWFya2VkLWltYWdlcy5qc1xuICpcbiAqIG1hcmtlZC5qcyBwbHVnaW4gcmVuZGVyZXIgZm9yIGltYWdlc1xuICogZ2VuZXJhdGUgd2lkdGg9XCJhXCIgYW5kIGhlaWdodD1cImJcIiBhdHRyaWJ1dGVzIGZyb20gYXhiIHBhdHRlcm4gaW4gdGl0bGUgc3RyaW5nIEUuZyAhW10oc3JjIFwiMTAweDUwXCIpXG4gKiAgICAgICAgICBhdHRyPVwieFwiIGZyb20gYXR0cj14ICh3aXRoIG5vIFwiXCIpIGUuZy4gIVtdKHNyYyBcIndpZHRoPTEwMCBoZWlnaHQ9NTAgYWxpZ249cmlnaHRcIilcbiAqICAgICAgICAgIHZpbWVvIHN0YW5kYXJkIDxpZnJhbWUuLiA+PC9pZnJhbWU+IGZyb20gIVtdKHZpbWVvL25ubikgd2hlcmUgbm5uIGlzIHRoZSB2aW1lbyBpZFxuICpcbiAqIHVzYWdlOiBtYXJrZWQudXNlKG1hcmtlZEltYWdlcyhvcHRzKSlcbiAqXG4gKiBvcmlnaW5hbCBmdW5jdGlvbjogY29weXJpZ2h0IENocmlzdG9waGVyIEplZmZyZXkgLS0gaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZCAoTUlUIExpY2Vuc2UpXG4gKiBleHRlbnNpb24gY29weXJpZ2h0IDIwMTUtMjAyMCwgSsO8cmdlbiBMZXNjaG5lciAtIGdpdGh1Yi5jb20vamxkZWMvIC0gTUlUIGxpY2Vuc2VcbiAqXG4qKi9cblxudmFyIHN0YXJ0c1dpdGggPSByZXF1aXJlKCdsb2Rhc2guc3RhcnRzd2l0aCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1hcmtlZEltYWdlcyhvcHRzKSB7XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHZhciBpbWdSb3V0ZSA9IG9wdHMuZnFJbWFnZXMgJiYgKG9wdHMuZnFJbWFnZXMucm91dGUgfHwgJy9pbWFnZXMvJyk7XG4gIHZhciBpbWdQcmVmaXggPSBvcHRzLmZxSW1hZ2VzICYmIG9wdHMuZnFJbWFnZXMudXJsO1xuICB2YXIgbGlua1ByZWZpeCA9IG9wdHMuZnFMaW5rcyB8fCBvcHRzLnJlbFBhdGg7XG4gIHZhciB4aHRtbCA9IG9wdHMueGh0bWw7XG5cbiAgcmV0dXJuIHsgcmVuZGVyZXI6IHtpbWFnZTogcmVuZGVySW1hZ2V9IH07XG5cbiAgZnVuY3Rpb24gcmVuZGVySW1hZ2UoaHJlZiwgdGl0bGUsIHRleHQpIHtcblxuICAgIHZhciBvdXQsIGlmcmFtZTtcblxuICAgIGlmIChpbWdQcmVmaXggJiYgc3RhcnRzV2l0aChocmVmLCBpbWdSb3V0ZSkpIHsgaHJlZiA9IGltZ1ByZWZpeCArIGhyZWY7IH1cbiAgICBlbHNlIGlmIChsaW5rUHJlZml4ICYmIC9eXFwvKFteL118JCkvLnRlc3QoaHJlZikpIHsgaHJlZiA9IGxpbmtQcmVmaXggKyBocmVmOyB9XG5cbiAgICBpZiAoaHJlZiAmJiAobSA9IGhyZWYubWF0Y2goL3ZpbWVvXFwvKFxcZCspL2kpKSkge1xuICAgICAgaWZyYW1lID0gdHJ1ZTtcbiAgICAgIG91dCA9ICc8aWZyYW1lIHNyYz1cIi8vcGxheWVyLnZpbWVvLmNvbS92aWRlby8nICsgbVsxXSArICdcIicgK1xuICAgICAgICAgICAgICAnIGZyYW1lYm9yZGVyPVwiMFwiIHdlYmtpdEFsbG93RnVsbFNjcmVlbiBtb3phbGxvd2Z1bGxzY3JlZW4gYWxsb3dGdWxsU2NyZWVuJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBvdXQgPSAnPGltZyBzcmM9XCInICsgaHJlZiArICdcIiBhbHQ9XCInICsgdGV4dCArICdcIic7XG4gICAgfVxuXG4gICAgdmFyIGEgPSAodGl0bGUgJiYgdGl0bGUuc3BsaXQoL1xccysvKSkgfHwgW107XG4gICAgdmFyIGIgPSBbXTtcbiAgICB2YXIgbTtcbiAgICBhLmZvckVhY2goZnVuY3Rpb24odykge1xuICAgICAgaWYgKChtID0gdy5tYXRjaCgvXihcXGQrKXgoXFxkKykkLykpKSByZXR1cm4gKG91dCArPSAnIHdpZHRoPVwiJyArIG1bMV0gKyAnXCIgaGVpZ2h0PVwiJyArIG1bMl0gKyAnXCInKTtcbiAgICAgIGlmICgobSA9IHcubWF0Y2goL14oXFx3Kyk9KFtcXHctXSspJC8pKSkgcmV0dXJuIChvdXQgKz0gJyAnICsgbVsxXSArICc9XCInICsgbVsyXSArICdcIicpO1xuICAgICAgaWYgKHcpIHJldHVybiBiLnB1c2godyk7XG4gICAgfSk7XG4gICAgdGl0bGUgPSBiLmpvaW4oJyAnKTtcblxuICAgIGlmICh0aXRsZSkge1xuICAgICAgb3V0ICs9ICcgdGl0bGU9XCInICsgdGl0bGUgKyAnXCInO1xuICAgIH1cblxuICAgIG91dCArPSBpZnJhbWUgPyAnPjwvaWZyYW1lPicgOlxuICAgICAgICAgICB4aHRtbCA/ICcvPicgOlxuICAgICAgICAgICAnPic7XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/marked-images/marked-images.js\n");

/***/ }),

/***/ "./node_modules/marked/lib/marked.js":
/*!*******************************************!*\
  !*** ./node_modules/marked/lib/marked.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * marked - a markdown parser\n * Copyright (c) 2011-2021, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n/**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */\n\n(function (global, factory) {\n   true ? module.exports = factory() :\n  undefined;\n}(this, (function () { 'use strict';\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _createForOfIteratorHelperLoose(o, allowArrayLike) {\n    var it;\n\n    if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        return function () {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        };\n      }\n\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n\n    it = o[Symbol.iterator]();\n    return it.next.bind(it);\n  }\n\n  function createCommonjsModule(fn) {\n    var module = { exports: {} };\n  \treturn fn(module, module.exports), module.exports;\n  }\n\n  var defaults = createCommonjsModule(function (module) {\n    function getDefaults() {\n      return {\n        baseUrl: null,\n        breaks: false,\n        gfm: true,\n        headerIds: true,\n        headerPrefix: '',\n        highlight: null,\n        langPrefix: 'language-',\n        mangle: true,\n        pedantic: false,\n        renderer: null,\n        sanitize: false,\n        sanitizer: null,\n        silent: false,\n        smartLists: false,\n        smartypants: false,\n        tokenizer: null,\n        walkTokens: null,\n        xhtml: false\n      };\n    }\n\n    function changeDefaults(newDefaults) {\n      module.exports.defaults = newDefaults;\n    }\n\n    module.exports = {\n      defaults: getDefaults(),\n      getDefaults: getDefaults,\n      changeDefaults: changeDefaults\n    };\n  });\n\n  /**\n   * Helpers\n   */\n  var escapeTest = /[&<>\"']/;\n  var escapeReplace = /[&<>\"']/g;\n  var escapeTestNoEncode = /[<>\"']|&(?!#?\\w+;)/;\n  var escapeReplaceNoEncode = /[<>\"']|&(?!#?\\w+;)/g;\n  var escapeReplacements = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#39;'\n  };\n\n  var getEscapeReplacement = function getEscapeReplacement(ch) {\n    return escapeReplacements[ch];\n  };\n\n  function escape(html, encode) {\n    if (encode) {\n      if (escapeTest.test(html)) {\n        return html.replace(escapeReplace, getEscapeReplacement);\n      }\n    } else {\n      if (escapeTestNoEncode.test(html)) {\n        return html.replace(escapeReplaceNoEncode, getEscapeReplacement);\n      }\n    }\n\n    return html;\n  }\n\n  var unescapeTest = /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig;\n\n  function unescape(html) {\n    // explicitly match decimal, hex, and named HTML entities\n    return html.replace(unescapeTest, function (_, n) {\n      n = n.toLowerCase();\n      if (n === 'colon') return ':';\n\n      if (n.charAt(0) === '#') {\n        return n.charAt(1) === 'x' ? String.fromCharCode(parseInt(n.substring(2), 16)) : String.fromCharCode(+n.substring(1));\n      }\n\n      return '';\n    });\n  }\n\n  var caret = /(^|[^\\[])\\^/g;\n\n  function edit(regex, opt) {\n    regex = regex.source || regex;\n    opt = opt || '';\n    var obj = {\n      replace: function replace(name, val) {\n        val = val.source || val;\n        val = val.replace(caret, '$1');\n        regex = regex.replace(name, val);\n        return obj;\n      },\n      getRegex: function getRegex() {\n        return new RegExp(regex, opt);\n      }\n    };\n    return obj;\n  }\n\n  var nonWordAndColonTest = /[^\\w:]/g;\n  var originIndependentUrl = /^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;\n\n  function cleanUrl(sanitize, base, href) {\n    if (sanitize) {\n      var prot;\n\n      try {\n        prot = decodeURIComponent(unescape(href)).replace(nonWordAndColonTest, '').toLowerCase();\n      } catch (e) {\n        return null;\n      }\n\n      if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {\n        return null;\n      }\n    }\n\n    if (base && !originIndependentUrl.test(href)) {\n      href = resolveUrl(base, href);\n    }\n\n    try {\n      href = encodeURI(href).replace(/%25/g, '%');\n    } catch (e) {\n      return null;\n    }\n\n    return href;\n  }\n\n  var baseUrls = {};\n  var justDomain = /^[^:]+:\\/*[^/]*$/;\n  var protocol = /^([^:]+:)[\\s\\S]*$/;\n  var domain = /^([^:]+:\\/*[^/]*)[\\s\\S]*$/;\n\n  function resolveUrl(base, href) {\n    if (!baseUrls[' ' + base]) {\n      // we can ignore everything in base after the last slash of its path component,\n      // but we might need to add _that_\n      // https://tools.ietf.org/html/rfc3986#section-3\n      if (justDomain.test(base)) {\n        baseUrls[' ' + base] = base + '/';\n      } else {\n        baseUrls[' ' + base] = rtrim(base, '/', true);\n      }\n    }\n\n    base = baseUrls[' ' + base];\n    var relativeBase = base.indexOf(':') === -1;\n\n    if (href.substring(0, 2) === '//') {\n      if (relativeBase) {\n        return href;\n      }\n\n      return base.replace(protocol, '$1') + href;\n    } else if (href.charAt(0) === '/') {\n      if (relativeBase) {\n        return href;\n      }\n\n      return base.replace(domain, '$1') + href;\n    } else {\n      return base + href;\n    }\n  }\n\n  var noopTest = {\n    exec: function noopTest() {}\n  };\n\n  function merge(obj) {\n    var i = 1,\n        target,\n        key;\n\n    for (; i < arguments.length; i++) {\n      target = arguments[i];\n\n      for (key in target) {\n        if (Object.prototype.hasOwnProperty.call(target, key)) {\n          obj[key] = target[key];\n        }\n      }\n    }\n\n    return obj;\n  }\n\n  function splitCells(tableRow, count) {\n    // ensure that every cell-delimiting pipe has a space\n    // before it to distinguish it from an escaped pipe\n    var row = tableRow.replace(/\\|/g, function (match, offset, str) {\n      var escaped = false,\n          curr = offset;\n\n      while (--curr >= 0 && str[curr] === '\\\\') {\n        escaped = !escaped;\n      }\n\n      if (escaped) {\n        // odd number of slashes means | is escaped\n        // so we leave it alone\n        return '|';\n      } else {\n        // add space before unescaped |\n        return ' |';\n      }\n    }),\n        cells = row.split(/ \\|/);\n    var i = 0;\n\n    if (cells.length > count) {\n      cells.splice(count);\n    } else {\n      while (cells.length < count) {\n        cells.push('');\n      }\n    }\n\n    for (; i < cells.length; i++) {\n      // leading or trailing whitespace is ignored per the gfm spec\n      cells[i] = cells[i].trim().replace(/\\\\\\|/g, '|');\n    }\n\n    return cells;\n  } // Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n  // /c*$/ is vulnerable to REDOS.\n  // invert: Remove suffix of non-c chars instead. Default falsey.\n\n\n  function rtrim(str, c, invert) {\n    var l = str.length;\n\n    if (l === 0) {\n      return '';\n    } // Length of suffix matching the invert condition.\n\n\n    var suffLen = 0; // Step left until we fail to match the invert condition.\n\n    while (suffLen < l) {\n      var currChar = str.charAt(l - suffLen - 1);\n\n      if (currChar === c && !invert) {\n        suffLen++;\n      } else if (currChar !== c && invert) {\n        suffLen++;\n      } else {\n        break;\n      }\n    }\n\n    return str.substr(0, l - suffLen);\n  }\n\n  function findClosingBracket(str, b) {\n    if (str.indexOf(b[1]) === -1) {\n      return -1;\n    }\n\n    var l = str.length;\n    var level = 0,\n        i = 0;\n\n    for (; i < l; i++) {\n      if (str[i] === '\\\\') {\n        i++;\n      } else if (str[i] === b[0]) {\n        level++;\n      } else if (str[i] === b[1]) {\n        level--;\n\n        if (level < 0) {\n          return i;\n        }\n      }\n    }\n\n    return -1;\n  }\n\n  function checkSanitizeDeprecation(opt) {\n    if (opt && opt.sanitize && !opt.silent) {\n      console.warn('marked(): sanitize and sanitizer parameters are deprecated since version 0.7.0, should not be used and will be removed in the future. Read more here: https://marked.js.org/#/USING_ADVANCED.md#options');\n    }\n  } // copied from https://stackoverflow.com/a/5450113/806777\n\n\n  function repeatString(pattern, count) {\n    if (count < 1) {\n      return '';\n    }\n\n    var result = '';\n\n    while (count > 1) {\n      if (count & 1) {\n        result += pattern;\n      }\n\n      count >>= 1;\n      pattern += pattern;\n    }\n\n    return result + pattern;\n  }\n\n  var helpers = {\n    escape: escape,\n    unescape: unescape,\n    edit: edit,\n    cleanUrl: cleanUrl,\n    resolveUrl: resolveUrl,\n    noopTest: noopTest,\n    merge: merge,\n    splitCells: splitCells,\n    rtrim: rtrim,\n    findClosingBracket: findClosingBracket,\n    checkSanitizeDeprecation: checkSanitizeDeprecation,\n    repeatString: repeatString\n  };\n\n  var defaults$1 = defaults.defaults;\n  var rtrim$1 = helpers.rtrim,\n      splitCells$1 = helpers.splitCells,\n      _escape = helpers.escape,\n      findClosingBracket$1 = helpers.findClosingBracket;\n\n  function outputLink(cap, link, raw) {\n    var href = link.href;\n    var title = link.title ? _escape(link.title) : null;\n    var text = cap[1].replace(/\\\\([\\[\\]])/g, '$1');\n\n    if (cap[0].charAt(0) !== '!') {\n      return {\n        type: 'link',\n        raw: raw,\n        href: href,\n        title: title,\n        text: text\n      };\n    } else {\n      return {\n        type: 'image',\n        raw: raw,\n        href: href,\n        title: title,\n        text: _escape(text)\n      };\n    }\n  }\n\n  function indentCodeCompensation(raw, text) {\n    var matchIndentToCode = raw.match(/^(\\s+)(?:```)/);\n\n    if (matchIndentToCode === null) {\n      return text;\n    }\n\n    var indentToCode = matchIndentToCode[1];\n    return text.split('\\n').map(function (node) {\n      var matchIndentInNode = node.match(/^\\s+/);\n\n      if (matchIndentInNode === null) {\n        return node;\n      }\n\n      var indentInNode = matchIndentInNode[0];\n\n      if (indentInNode.length >= indentToCode.length) {\n        return node.slice(indentToCode.length);\n      }\n\n      return node;\n    }).join('\\n');\n  }\n  /**\n   * Tokenizer\n   */\n\n\n  var Tokenizer_1 = /*#__PURE__*/function () {\n    function Tokenizer(options) {\n      this.options = options || defaults$1;\n    }\n\n    var _proto = Tokenizer.prototype;\n\n    _proto.space = function space(src) {\n      var cap = this.rules.block.newline.exec(src);\n\n      if (cap) {\n        if (cap[0].length > 1) {\n          return {\n            type: 'space',\n            raw: cap[0]\n          };\n        }\n\n        return {\n          raw: '\\n'\n        };\n      }\n    };\n\n    _proto.code = function code(src, tokens) {\n      var cap = this.rules.block.code.exec(src);\n\n      if (cap) {\n        var lastToken = tokens[tokens.length - 1]; // An indented code block cannot interrupt a paragraph.\n\n        if (lastToken && lastToken.type === 'paragraph') {\n          return {\n            raw: cap[0],\n            text: cap[0].trimRight()\n          };\n        }\n\n        var text = cap[0].replace(/^ {1,4}/gm, '');\n        return {\n          type: 'code',\n          raw: cap[0],\n          codeBlockStyle: 'indented',\n          text: !this.options.pedantic ? rtrim$1(text, '\\n') : text\n        };\n      }\n    };\n\n    _proto.fences = function fences(src) {\n      var cap = this.rules.block.fences.exec(src);\n\n      if (cap) {\n        var raw = cap[0];\n        var text = indentCodeCompensation(raw, cap[3] || '');\n        return {\n          type: 'code',\n          raw: raw,\n          lang: cap[2] ? cap[2].trim() : cap[2],\n          text: text\n        };\n      }\n    };\n\n    _proto.heading = function heading(src) {\n      var cap = this.rules.block.heading.exec(src);\n\n      if (cap) {\n        var text = cap[2].trim(); // remove trailing #s\n\n        if (/#$/.test(text)) {\n          var trimmed = rtrim$1(text, '#');\n\n          if (this.options.pedantic) {\n            text = trimmed.trim();\n          } else if (!trimmed || / $/.test(trimmed)) {\n            // CommonMark requires space before trailing #s\n            text = trimmed.trim();\n          }\n        }\n\n        return {\n          type: 'heading',\n          raw: cap[0],\n          depth: cap[1].length,\n          text: text\n        };\n      }\n    };\n\n    _proto.nptable = function nptable(src) {\n      var cap = this.rules.block.nptable.exec(src);\n\n      if (cap) {\n        var item = {\n          type: 'table',\n          header: splitCells$1(cap[1].replace(/^ *| *\\| *$/g, '')),\n          align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n          cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : [],\n          raw: cap[0]\n        };\n\n        if (item.header.length === item.align.length) {\n          var l = item.align.length;\n          var i;\n\n          for (i = 0; i < l; i++) {\n            if (/^ *-+: *$/.test(item.align[i])) {\n              item.align[i] = 'right';\n            } else if (/^ *:-+: *$/.test(item.align[i])) {\n              item.align[i] = 'center';\n            } else if (/^ *:-+ *$/.test(item.align[i])) {\n              item.align[i] = 'left';\n            } else {\n              item.align[i] = null;\n            }\n          }\n\n          l = item.cells.length;\n\n          for (i = 0; i < l; i++) {\n            item.cells[i] = splitCells$1(item.cells[i], item.header.length);\n          }\n\n          return item;\n        }\n      }\n    };\n\n    _proto.hr = function hr(src) {\n      var cap = this.rules.block.hr.exec(src);\n\n      if (cap) {\n        return {\n          type: 'hr',\n          raw: cap[0]\n        };\n      }\n    };\n\n    _proto.blockquote = function blockquote(src) {\n      var cap = this.rules.block.blockquote.exec(src);\n\n      if (cap) {\n        var text = cap[0].replace(/^ *> ?/gm, '');\n        return {\n          type: 'blockquote',\n          raw: cap[0],\n          text: text\n        };\n      }\n    };\n\n    _proto.list = function list(src) {\n      var cap = this.rules.block.list.exec(src);\n\n      if (cap) {\n        var raw = cap[0];\n        var bull = cap[2];\n        var isordered = bull.length > 1;\n        var list = {\n          type: 'list',\n          raw: raw,\n          ordered: isordered,\n          start: isordered ? +bull.slice(0, -1) : '',\n          loose: false,\n          items: []\n        }; // Get each top-level item.\n\n        var itemMatch = cap[0].match(this.rules.block.item);\n        var next = false,\n            item,\n            space,\n            bcurr,\n            bnext,\n            addBack,\n            loose,\n            istask,\n            ischecked;\n        var l = itemMatch.length;\n        bcurr = this.rules.block.listItemStart.exec(itemMatch[0]);\n\n        for (var i = 0; i < l; i++) {\n          item = itemMatch[i];\n          raw = item; // Determine whether the next list item belongs here.\n          // Backpedal if it does not belong in this list.\n\n          if (i !== l - 1) {\n            bnext = this.rules.block.listItemStart.exec(itemMatch[i + 1]);\n\n            if (!this.options.pedantic ? bnext[1].length > bcurr[0].length || bnext[1].length > 3 : bnext[1].length > bcurr[1].length) {\n              // nested list\n              itemMatch.splice(i, 2, itemMatch[i] + '\\n' + itemMatch[i + 1]);\n              i--;\n              l--;\n              continue;\n            } else {\n              if ( // different bullet style\n              !this.options.pedantic || this.options.smartLists ? bnext[2][bnext[2].length - 1] !== bull[bull.length - 1] : isordered === (bnext[2].length === 1)) {\n                addBack = itemMatch.slice(i + 1).join('\\n');\n                list.raw = list.raw.substring(0, list.raw.length - addBack.length);\n                i = l - 1;\n              }\n            }\n\n            bcurr = bnext;\n          } // Remove the list item's bullet\n          // so it is seen as the next token.\n\n\n          space = item.length;\n          item = item.replace(/^ *([*+-]|\\d+[.)]) ?/, ''); // Outdent whatever the\n          // list item contains. Hacky.\n\n          if (~item.indexOf('\\n ')) {\n            space -= item.length;\n            item = !this.options.pedantic ? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '') : item.replace(/^ {1,4}/gm, '');\n          } // Determine whether item is loose or not.\n          // Use: /(^|\\n)(?! )[^\\n]+\\n\\n(?!\\s*$)/\n          // for discount behavior.\n\n\n          loose = next || /\\n\\n(?!\\s*$)/.test(item);\n\n          if (i !== l - 1) {\n            next = item.charAt(item.length - 1) === '\\n';\n            if (!loose) loose = next;\n          }\n\n          if (loose) {\n            list.loose = true;\n          } // Check for task list items\n\n\n          if (this.options.gfm) {\n            istask = /^\\[[ xX]\\] /.test(item);\n            ischecked = undefined;\n\n            if (istask) {\n              ischecked = item[1] !== ' ';\n              item = item.replace(/^\\[[ xX]\\] +/, '');\n            }\n          }\n\n          list.items.push({\n            type: 'list_item',\n            raw: raw,\n            task: istask,\n            checked: ischecked,\n            loose: loose,\n            text: item\n          });\n        }\n\n        return list;\n      }\n    };\n\n    _proto.html = function html(src) {\n      var cap = this.rules.block.html.exec(src);\n\n      if (cap) {\n        return {\n          type: this.options.sanitize ? 'paragraph' : 'html',\n          raw: cap[0],\n          pre: !this.options.sanitizer && (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),\n          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]\n        };\n      }\n    };\n\n    _proto.def = function def(src) {\n      var cap = this.rules.block.def.exec(src);\n\n      if (cap) {\n        if (cap[3]) cap[3] = cap[3].substring(1, cap[3].length - 1);\n        var tag = cap[1].toLowerCase().replace(/\\s+/g, ' ');\n        return {\n          tag: tag,\n          raw: cap[0],\n          href: cap[2],\n          title: cap[3]\n        };\n      }\n    };\n\n    _proto.table = function table(src) {\n      var cap = this.rules.block.table.exec(src);\n\n      if (cap) {\n        var item = {\n          type: 'table',\n          header: splitCells$1(cap[1].replace(/^ *| *\\| *$/g, '')),\n          align: cap[2].replace(/^ *|\\| *$/g, '').split(/ *\\| */),\n          cells: cap[3] ? cap[3].replace(/\\n$/, '').split('\\n') : []\n        };\n\n        if (item.header.length === item.align.length) {\n          item.raw = cap[0];\n          var l = item.align.length;\n          var i;\n\n          for (i = 0; i < l; i++) {\n            if (/^ *-+: *$/.test(item.align[i])) {\n              item.align[i] = 'right';\n            } else if (/^ *:-+: *$/.test(item.align[i])) {\n              item.align[i] = 'center';\n            } else if (/^ *:-+ *$/.test(item.align[i])) {\n              item.align[i] = 'left';\n            } else {\n              item.align[i] = null;\n            }\n          }\n\n          l = item.cells.length;\n\n          for (i = 0; i < l; i++) {\n            item.cells[i] = splitCells$1(item.cells[i].replace(/^ *\\| *| *\\| *$/g, ''), item.header.length);\n          }\n\n          return item;\n        }\n      }\n    };\n\n    _proto.lheading = function lheading(src) {\n      var cap = this.rules.block.lheading.exec(src);\n\n      if (cap) {\n        return {\n          type: 'heading',\n          raw: cap[0],\n          depth: cap[2].charAt(0) === '=' ? 1 : 2,\n          text: cap[1]\n        };\n      }\n    };\n\n    _proto.paragraph = function paragraph(src) {\n      var cap = this.rules.block.paragraph.exec(src);\n\n      if (cap) {\n        return {\n          type: 'paragraph',\n          raw: cap[0],\n          text: cap[1].charAt(cap[1].length - 1) === '\\n' ? cap[1].slice(0, -1) : cap[1]\n        };\n      }\n    };\n\n    _proto.text = function text(src, tokens) {\n      var cap = this.rules.block.text.exec(src);\n\n      if (cap) {\n        var lastToken = tokens[tokens.length - 1];\n\n        if (lastToken && lastToken.type === 'text') {\n          return {\n            raw: cap[0],\n            text: cap[0]\n          };\n        }\n\n        return {\n          type: 'text',\n          raw: cap[0],\n          text: cap[0]\n        };\n      }\n    };\n\n    _proto.escape = function escape(src) {\n      var cap = this.rules.inline.escape.exec(src);\n\n      if (cap) {\n        return {\n          type: 'escape',\n          raw: cap[0],\n          text: _escape(cap[1])\n        };\n      }\n    };\n\n    _proto.tag = function tag(src, inLink, inRawBlock) {\n      var cap = this.rules.inline.tag.exec(src);\n\n      if (cap) {\n        if (!inLink && /^<a /i.test(cap[0])) {\n          inLink = true;\n        } else if (inLink && /^<\\/a>/i.test(cap[0])) {\n          inLink = false;\n        }\n\n        if (!inRawBlock && /^<(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n          inRawBlock = true;\n        } else if (inRawBlock && /^<\\/(pre|code|kbd|script)(\\s|>)/i.test(cap[0])) {\n          inRawBlock = false;\n        }\n\n        return {\n          type: this.options.sanitize ? 'text' : 'html',\n          raw: cap[0],\n          inLink: inLink,\n          inRawBlock: inRawBlock,\n          text: this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0]\n        };\n      }\n    };\n\n    _proto.link = function link(src) {\n      var cap = this.rules.inline.link.exec(src);\n\n      if (cap) {\n        var trimmedUrl = cap[2].trim();\n\n        if (!this.options.pedantic && /^</.test(trimmedUrl)) {\n          // commonmark requires matching angle brackets\n          if (!/>$/.test(trimmedUrl)) {\n            return;\n          } // ending angle bracket cannot be escaped\n\n\n          var rtrimSlash = rtrim$1(trimmedUrl.slice(0, -1), '\\\\');\n\n          if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n            return;\n          }\n        } else {\n          // find closing parenthesis\n          var lastParenIndex = findClosingBracket$1(cap[2], '()');\n\n          if (lastParenIndex > -1) {\n            var start = cap[0].indexOf('!') === 0 ? 5 : 4;\n            var linkLen = start + cap[1].length + lastParenIndex;\n            cap[2] = cap[2].substring(0, lastParenIndex);\n            cap[0] = cap[0].substring(0, linkLen).trim();\n            cap[3] = '';\n          }\n        }\n\n        var href = cap[2];\n        var title = '';\n\n        if (this.options.pedantic) {\n          // split pedantic href and title\n          var link = /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/.exec(href);\n\n          if (link) {\n            href = link[1];\n            title = link[3];\n          }\n        } else {\n          title = cap[3] ? cap[3].slice(1, -1) : '';\n        }\n\n        href = href.trim();\n\n        if (/^</.test(href)) {\n          if (this.options.pedantic && !/>$/.test(trimmedUrl)) {\n            // pedantic allows starting angle bracket without ending angle bracket\n            href = href.slice(1);\n          } else {\n            href = href.slice(1, -1);\n          }\n        }\n\n        return outputLink(cap, {\n          href: href ? href.replace(this.rules.inline._escapes, '$1') : href,\n          title: title ? title.replace(this.rules.inline._escapes, '$1') : title\n        }, cap[0]);\n      }\n    };\n\n    _proto.reflink = function reflink(src, links) {\n      var cap;\n\n      if ((cap = this.rules.inline.reflink.exec(src)) || (cap = this.rules.inline.nolink.exec(src))) {\n        var link = (cap[2] || cap[1]).replace(/\\s+/g, ' ');\n        link = links[link.toLowerCase()];\n\n        if (!link || !link.href) {\n          var text = cap[0].charAt(0);\n          return {\n            type: 'text',\n            raw: text,\n            text: text\n          };\n        }\n\n        return outputLink(cap, link, cap[0]);\n      }\n    };\n\n    _proto.strong = function strong(src, maskedSrc, prevChar) {\n      if (prevChar === void 0) {\n        prevChar = '';\n      }\n\n      var match = this.rules.inline.strong.start.exec(src);\n\n      if (match && (!match[1] || match[1] && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar)))) {\n        maskedSrc = maskedSrc.slice(-1 * src.length);\n        var endReg = match[0] === '**' ? this.rules.inline.strong.endAst : this.rules.inline.strong.endUnd;\n        endReg.lastIndex = 0;\n        var cap;\n\n        while ((match = endReg.exec(maskedSrc)) != null) {\n          cap = this.rules.inline.strong.middle.exec(maskedSrc.slice(0, match.index + 3));\n\n          if (cap) {\n            return {\n              type: 'strong',\n              raw: src.slice(0, cap[0].length),\n              text: src.slice(2, cap[0].length - 2)\n            };\n          }\n        }\n      }\n    };\n\n    _proto.em = function em(src, maskedSrc, prevChar) {\n      if (prevChar === void 0) {\n        prevChar = '';\n      }\n\n      var match = this.rules.inline.em.start.exec(src);\n\n      if (match && (!match[1] || match[1] && (prevChar === '' || this.rules.inline.punctuation.exec(prevChar)))) {\n        maskedSrc = maskedSrc.slice(-1 * src.length);\n        var endReg = match[0] === '*' ? this.rules.inline.em.endAst : this.rules.inline.em.endUnd;\n        endReg.lastIndex = 0;\n        var cap;\n\n        while ((match = endReg.exec(maskedSrc)) != null) {\n          cap = this.rules.inline.em.middle.exec(maskedSrc.slice(0, match.index + 2));\n\n          if (cap) {\n            return {\n              type: 'em',\n              raw: src.slice(0, cap[0].length),\n              text: src.slice(1, cap[0].length - 1)\n            };\n          }\n        }\n      }\n    };\n\n    _proto.codespan = function codespan(src) {\n      var cap = this.rules.inline.code.exec(src);\n\n      if (cap) {\n        var text = cap[2].replace(/\\n/g, ' ');\n        var hasNonSpaceChars = /[^ ]/.test(text);\n        var hasSpaceCharsOnBothEnds = /^ /.test(text) && / $/.test(text);\n\n        if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n          text = text.substring(1, text.length - 1);\n        }\n\n        text = _escape(text, true);\n        return {\n          type: 'codespan',\n          raw: cap[0],\n          text: text\n        };\n      }\n    };\n\n    _proto.br = function br(src) {\n      var cap = this.rules.inline.br.exec(src);\n\n      if (cap) {\n        return {\n          type: 'br',\n          raw: cap[0]\n        };\n      }\n    };\n\n    _proto.del = function del(src) {\n      var cap = this.rules.inline.del.exec(src);\n\n      if (cap) {\n        return {\n          type: 'del',\n          raw: cap[0],\n          text: cap[2]\n        };\n      }\n    };\n\n    _proto.autolink = function autolink(src, mangle) {\n      var cap = this.rules.inline.autolink.exec(src);\n\n      if (cap) {\n        var text, href;\n\n        if (cap[2] === '@') {\n          text = _escape(this.options.mangle ? mangle(cap[1]) : cap[1]);\n          href = 'mailto:' + text;\n        } else {\n          text = _escape(cap[1]);\n          href = text;\n        }\n\n        return {\n          type: 'link',\n          raw: cap[0],\n          text: text,\n          href: href,\n          tokens: [{\n            type: 'text',\n            raw: text,\n            text: text\n          }]\n        };\n      }\n    };\n\n    _proto.url = function url(src, mangle) {\n      var cap;\n\n      if (cap = this.rules.inline.url.exec(src)) {\n        var text, href;\n\n        if (cap[2] === '@') {\n          text = _escape(this.options.mangle ? mangle(cap[0]) : cap[0]);\n          href = 'mailto:' + text;\n        } else {\n          // do extended autolink path validation\n          var prevCapZero;\n\n          do {\n            prevCapZero = cap[0];\n            cap[0] = this.rules.inline._backpedal.exec(cap[0])[0];\n          } while (prevCapZero !== cap[0]);\n\n          text = _escape(cap[0]);\n\n          if (cap[1] === 'www.') {\n            href = 'http://' + text;\n          } else {\n            href = text;\n          }\n        }\n\n        return {\n          type: 'link',\n          raw: cap[0],\n          text: text,\n          href: href,\n          tokens: [{\n            type: 'text',\n            raw: text,\n            text: text\n          }]\n        };\n      }\n    };\n\n    _proto.inlineText = function inlineText(src, inRawBlock, smartypants) {\n      var cap = this.rules.inline.text.exec(src);\n\n      if (cap) {\n        var text;\n\n        if (inRawBlock) {\n          text = this.options.sanitize ? this.options.sanitizer ? this.options.sanitizer(cap[0]) : _escape(cap[0]) : cap[0];\n        } else {\n          text = _escape(this.options.smartypants ? smartypants(cap[0]) : cap[0]);\n        }\n\n        return {\n          type: 'text',\n          raw: cap[0],\n          text: text\n        };\n      }\n    };\n\n    return Tokenizer;\n  }();\n\n  var noopTest$1 = helpers.noopTest,\n      edit$1 = helpers.edit,\n      merge$1 = helpers.merge;\n  /**\n   * Block-Level Grammar\n   */\n\n  var block = {\n    newline: /^(?: *(?:\\n|$))+/,\n    code: /^( {4}[^\\n]+(?:\\n(?: *(?:\\n|$))*)?)+/,\n    fences: /^ {0,3}(`{3,}(?=[^`\\n]*\\n)|~{3,})([^\\n]*)\\n(?:|([\\s\\S]*?)\\n)(?: {0,3}\\1[~`]* *(?:\\n+|$)|$)/,\n    hr: /^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)/,\n    heading: /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/,\n    blockquote: /^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/,\n    list: /^( {0,3})(bull) [\\s\\S]+?(?:hr|def|\\n{2,}(?! )(?! {0,3}bull )\\n*|\\s*$)/,\n    html: '^ {0,3}(?:' // optional indentation\n    + '<(script|pre|style)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n    + '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n    + '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n    + '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n    + '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n    + '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (6)\n    + '|<(?!script|pre|style)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (7) open tag\n    + '|</(?!script|pre|style)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:\\\\n{2,}|$)' // (7) closing tag\n    + ')',\n    def: /^ {0,3}\\[(label)\\]: *\\n? *<?([^\\s>]+)>?(?:(?: +\\n? *| *\\n *)(title))? *(?:\\n+|$)/,\n    nptable: noopTest$1,\n    table: noopTest$1,\n    lheading: /^([^\\n]+)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n    // regex template, placeholders will be replaced according to different paragraph\n    // interruption rules of commonmark and the original markdown spec:\n    _paragraph: /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html| +\\n)[^\\n]+)*)/,\n    text: /^[^\\n]+/\n  };\n  block._label = /(?!\\s*\\])(?:\\\\[\\[\\]]|[^\\[\\]])+/;\n  block._title = /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/;\n  block.def = edit$1(block.def).replace('label', block._label).replace('title', block._title).getRegex();\n  block.bullet = /(?:[*+-]|\\d{1,9}[.)])/;\n  block.item = /^( *)(bull) ?[^\\n]*(?:\\n(?! *bull ?)[^\\n]*)*/;\n  block.item = edit$1(block.item, 'gm').replace(/bull/g, block.bullet).getRegex();\n  block.listItemStart = edit$1(/^( *)(bull)/).replace('bull', block.bullet).getRegex();\n  block.list = edit$1(block.list).replace(/bull/g, block.bullet).replace('hr', '\\\\n+(?=\\\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$))').replace('def', '\\\\n+(?=' + block.def.source + ')').getRegex();\n  block._tag = 'address|article|aside|base|basefont|blockquote|body|caption' + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption' + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe' + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option' + '|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr' + '|track|ul';\n  block._comment = /<!--(?!-?>)[\\s\\S]*?(?:-->|$)/;\n  block.html = edit$1(block.html, 'i').replace('comment', block._comment).replace('tag', block._tag).replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex();\n  block.paragraph = edit$1(block._paragraph).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('|lheading', '') // setex headings don't interrupt commonmark paragraphs\n  .replace('blockquote', ' {0,3}>').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|!--)').replace('tag', block._tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n  block.blockquote = edit$1(block.blockquote).replace('paragraph', block.paragraph).getRegex();\n  /**\n   * Normal Block Grammar\n   */\n\n  block.normal = merge$1({}, block);\n  /**\n   * GFM Block Grammar\n   */\n\n  block.gfm = merge$1({}, block.normal, {\n    nptable: '^ *([^|\\\\n ].*\\\\|.*)\\\\n' // Header\n    + ' {0,3}([-:]+ *\\\\|[-| :]*)' // Align\n    + '(?:\\\\n((?:(?!\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)',\n    // Cells\n    table: '^ *\\\\|(.+)\\\\n' // Header\n    + ' {0,3}\\\\|?( *[-:]+[-| :]*)' // Align\n    + '(?:\\\\n *((?:(?!\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)' // Cells\n\n  });\n  block.gfm.nptable = edit$1(block.gfm.nptable).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|!--)').replace('tag', block._tag) // tables can be interrupted by type (6) html blocks\n  .getRegex();\n  block.gfm.table = edit$1(block.gfm.table).replace('hr', block.hr).replace('heading', ' {0,3}#{1,6} ').replace('blockquote', ' {0,3}>').replace('code', ' {4}[^\\\\n]').replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n').replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|!--)').replace('tag', block._tag) // tables can be interrupted by type (6) html blocks\n  .getRegex();\n  /**\n   * Pedantic grammar (original John Gruber's loose markdown specification)\n   */\n\n  block.pedantic = merge$1({}, block.normal, {\n    html: edit$1('^ *(?:comment *(?:\\\\n|\\\\s*$)' + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n    + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))').replace('comment', block._comment).replace(/tag/g, '(?!(?:' + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub' + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)' + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b').getRegex(),\n    def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n    heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n    fences: noopTest$1,\n    // fences not supported\n    paragraph: edit$1(block.normal._paragraph).replace('hr', block.hr).replace('heading', ' *#{1,6} *[^\\n]').replace('lheading', block.lheading).replace('blockquote', ' {0,3}>').replace('|fences', '').replace('|list', '').replace('|html', '').getRegex()\n  });\n  /**\n   * Inline-Level Grammar\n   */\n\n  var inline = {\n    escape: /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,\n    autolink: /^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/,\n    url: noopTest$1,\n    tag: '^comment' + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>',\n    // CDATA section\n    link: /^!?\\[(label)\\]\\(\\s*(href)(?:\\s+(title))?\\s*\\)/,\n    reflink: /^!?\\[(label)\\]\\[(?!\\s*\\])((?:\\\\[\\[\\]]?|[^\\[\\]\\\\])+)\\]/,\n    nolink: /^!?\\[(?!\\s*\\])((?:\\[[^\\[\\]]*\\]|\\\\[\\[\\]]|[^\\[\\]])*)\\](?:\\[\\])?/,\n    reflinkSearch: 'reflink|nolink(?!\\\\()',\n    strong: {\n      start: /^(?:(\\*\\*(?=[*punctuation]))|\\*\\*)(?![\\s])|__/,\n      // (1) returns if starts w/ punctuation\n      middle: /^\\*\\*(?:(?:(?!overlapSkip)(?:[^*]|\\\\\\*)|overlapSkip)|\\*(?:(?!overlapSkip)(?:[^*]|\\\\\\*)|overlapSkip)*?\\*)+?\\*\\*$|^__(?![\\s])((?:(?:(?!overlapSkip)(?:[^_]|\\\\_)|overlapSkip)|_(?:(?!overlapSkip)(?:[^_]|\\\\_)|overlapSkip)*?_)+?)__$/,\n      endAst: /[^punctuation\\s]\\*\\*(?!\\*)|[punctuation]\\*\\*(?!\\*)(?:(?=[punctuation_\\s]|$))/,\n      // last char can't be punct, or final * must also be followed by punct (or endline)\n      endUnd: /[^\\s]__(?!_)(?:(?=[punctuation*\\s])|$)/ // last char can't be a space, and final _ must preceed punct or \\s (or endline)\n\n    },\n    em: {\n      start: /^(?:(\\*(?=[punctuation]))|\\*)(?![*\\s])|_/,\n      // (1) returns if starts w/ punctuation\n      middle: /^\\*(?:(?:(?!overlapSkip)(?:[^*]|\\\\\\*)|overlapSkip)|\\*(?:(?!overlapSkip)(?:[^*]|\\\\\\*)|overlapSkip)*?\\*)+?\\*$|^_(?![_\\s])(?:(?:(?!overlapSkip)(?:[^_]|\\\\_)|overlapSkip)|_(?:(?!overlapSkip)(?:[^_]|\\\\_)|overlapSkip)*?_)+?_$/,\n      endAst: /[^punctuation\\s]\\*(?!\\*)|[punctuation]\\*(?!\\*)(?:(?=[punctuation_\\s]|$))/,\n      // last char can't be punct, or final * must also be followed by punct (or endline)\n      endUnd: /[^\\s]_(?!_)(?:(?=[punctuation*\\s])|$)/ // last char can't be a space, and final _ must preceed punct or \\s (or endline)\n\n    },\n    code: /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/,\n    br: /^( {2,}|\\\\)\\n(?!\\s*$)/,\n    del: noopTest$1,\n    text: /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*]|\\b_|$)|[^ ](?= {2,}\\n)))/,\n    punctuation: /^([\\s*punctuation])/\n  }; // list of punctuation marks from common mark spec\n  // without * and _ to workaround cases with double emphasis\n\n  inline._punctuation = '!\"#$%&\\'()+\\\\-.,/:;<=>?@\\\\[\\\\]`^{|}~';\n  inline.punctuation = edit$1(inline.punctuation).replace(/punctuation/g, inline._punctuation).getRegex(); // sequences em should skip over [title](link), `code`, <html>\n\n  inline._blockSkip = '\\\\[[^\\\\]]*?\\\\]\\\\([^\\\\)]*?\\\\)|`[^`]*?`|<[^>]*?>';\n  inline._overlapSkip = '__[^_]*?__|\\\\*\\\\*\\\\[^\\\\*\\\\]*?\\\\*\\\\*';\n  inline._comment = edit$1(block._comment).replace('(?:-->|$)', '-->').getRegex();\n  inline.em.start = edit$1(inline.em.start).replace(/punctuation/g, inline._punctuation).getRegex();\n  inline.em.middle = edit$1(inline.em.middle).replace(/punctuation/g, inline._punctuation).replace(/overlapSkip/g, inline._overlapSkip).getRegex();\n  inline.em.endAst = edit$1(inline.em.endAst, 'g').replace(/punctuation/g, inline._punctuation).getRegex();\n  inline.em.endUnd = edit$1(inline.em.endUnd, 'g').replace(/punctuation/g, inline._punctuation).getRegex();\n  inline.strong.start = edit$1(inline.strong.start).replace(/punctuation/g, inline._punctuation).getRegex();\n  inline.strong.middle = edit$1(inline.strong.middle).replace(/punctuation/g, inline._punctuation).replace(/overlapSkip/g, inline._overlapSkip).getRegex();\n  inline.strong.endAst = edit$1(inline.strong.endAst, 'g').replace(/punctuation/g, inline._punctuation).getRegex();\n  inline.strong.endUnd = edit$1(inline.strong.endUnd, 'g').replace(/punctuation/g, inline._punctuation).getRegex();\n  inline.blockSkip = edit$1(inline._blockSkip, 'g').getRegex();\n  inline.overlapSkip = edit$1(inline._overlapSkip, 'g').getRegex();\n  inline._escapes = /\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/g;\n  inline._scheme = /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/;\n  inline._email = /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/;\n  inline.autolink = edit$1(inline.autolink).replace('scheme', inline._scheme).replace('email', inline._email).getRegex();\n  inline._attribute = /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/;\n  inline.tag = edit$1(inline.tag).replace('comment', inline._comment).replace('attribute', inline._attribute).getRegex();\n  inline._label = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\n  inline._href = /<(?:\\\\.|[^\\n<>\\\\])+>|[^\\s\\x00-\\x1f]*/;\n  inline._title = /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/;\n  inline.link = edit$1(inline.link).replace('label', inline._label).replace('href', inline._href).replace('title', inline._title).getRegex();\n  inline.reflink = edit$1(inline.reflink).replace('label', inline._label).getRegex();\n  inline.reflinkSearch = edit$1(inline.reflinkSearch, 'g').replace('reflink', inline.reflink).replace('nolink', inline.nolink).getRegex();\n  /**\n   * Normal Inline Grammar\n   */\n\n  inline.normal = merge$1({}, inline);\n  /**\n   * Pedantic Inline Grammar\n   */\n\n  inline.pedantic = merge$1({}, inline.normal, {\n    strong: {\n      start: /^__|\\*\\*/,\n      middle: /^__(?=\\S)([\\s\\S]*?\\S)__(?!_)|^\\*\\*(?=\\S)([\\s\\S]*?\\S)\\*\\*(?!\\*)/,\n      endAst: /\\*\\*(?!\\*)/g,\n      endUnd: /__(?!_)/g\n    },\n    em: {\n      start: /^_|\\*/,\n      middle: /^()\\*(?=\\S)([\\s\\S]*?\\S)\\*(?!\\*)|^_(?=\\S)([\\s\\S]*?\\S)_(?!_)/,\n      endAst: /\\*(?!\\*)/g,\n      endUnd: /_(?!_)/g\n    },\n    link: edit$1(/^!?\\[(label)\\]\\((.*?)\\)/).replace('label', inline._label).getRegex(),\n    reflink: edit$1(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace('label', inline._label).getRegex()\n  });\n  /**\n   * GFM Inline Grammar\n   */\n\n  inline.gfm = merge$1({}, inline.normal, {\n    escape: edit$1(inline.escape).replace('])', '~|])').getRegex(),\n    _extended_email: /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,\n    url: /^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/,\n    _backpedal: /(?:[^?!.,:;*_~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,\n    del: /^(~~?)(?=[^\\s~])([\\s\\S]*?[^\\s~])\\1(?=[^~]|$)/,\n    text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@))|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@))/\n  });\n  inline.gfm.url = edit$1(inline.gfm.url, 'i').replace('email', inline.gfm._extended_email).getRegex();\n  /**\n   * GFM + Line Breaks Inline Grammar\n   */\n\n  inline.breaks = merge$1({}, inline.gfm, {\n    br: edit$1(inline.br).replace('{2,}', '*').getRegex(),\n    text: edit$1(inline.gfm.text).replace('\\\\b_', '\\\\b_| {2,}\\\\n').replace(/\\{2,\\}/g, '*').getRegex()\n  });\n  var rules = {\n    block: block,\n    inline: inline\n  };\n\n  var defaults$2 = defaults.defaults;\n  var block$1 = rules.block,\n      inline$1 = rules.inline;\n  var repeatString$1 = helpers.repeatString;\n  /**\n   * smartypants text replacement\n   */\n\n  function smartypants(text) {\n    return text // em-dashes\n    .replace(/---/g, \"\\u2014\") // en-dashes\n    .replace(/--/g, \"\\u2013\") // opening singles\n    .replace(/(^|[-\\u2014/(\\[{\"\\s])'/g, \"$1\\u2018\") // closing singles & apostrophes\n    .replace(/'/g, \"\\u2019\") // opening doubles\n    .replace(/(^|[-\\u2014/(\\[{\\u2018\\s])\"/g, \"$1\\u201C\") // closing doubles\n    .replace(/\"/g, \"\\u201D\") // ellipses\n    .replace(/\\.{3}/g, \"\\u2026\");\n  }\n  /**\n   * mangle email addresses\n   */\n\n\n  function mangle(text) {\n    var out = '',\n        i,\n        ch;\n    var l = text.length;\n\n    for (i = 0; i < l; i++) {\n      ch = text.charCodeAt(i);\n\n      if (Math.random() > 0.5) {\n        ch = 'x' + ch.toString(16);\n      }\n\n      out += '&#' + ch + ';';\n    }\n\n    return out;\n  }\n  /**\n   * Block Lexer\n   */\n\n\n  var Lexer_1 = /*#__PURE__*/function () {\n    function Lexer(options) {\n      this.tokens = [];\n      this.tokens.links = Object.create(null);\n      this.options = options || defaults$2;\n      this.options.tokenizer = this.options.tokenizer || new Tokenizer_1();\n      this.tokenizer = this.options.tokenizer;\n      this.tokenizer.options = this.options;\n      var rules = {\n        block: block$1.normal,\n        inline: inline$1.normal\n      };\n\n      if (this.options.pedantic) {\n        rules.block = block$1.pedantic;\n        rules.inline = inline$1.pedantic;\n      } else if (this.options.gfm) {\n        rules.block = block$1.gfm;\n\n        if (this.options.breaks) {\n          rules.inline = inline$1.breaks;\n        } else {\n          rules.inline = inline$1.gfm;\n        }\n      }\n\n      this.tokenizer.rules = rules;\n    }\n    /**\n     * Expose Rules\n     */\n\n\n    /**\n     * Static Lex Method\n     */\n    Lexer.lex = function lex(src, options) {\n      var lexer = new Lexer(options);\n      return lexer.lex(src);\n    }\n    /**\n     * Static Lex Inline Method\n     */\n    ;\n\n    Lexer.lexInline = function lexInline(src, options) {\n      var lexer = new Lexer(options);\n      return lexer.inlineTokens(src);\n    }\n    /**\n     * Preprocessing\n     */\n    ;\n\n    var _proto = Lexer.prototype;\n\n    _proto.lex = function lex(src) {\n      src = src.replace(/\\r\\n|\\r/g, '\\n').replace(/\\t/g, '    ');\n      this.blockTokens(src, this.tokens, true);\n      this.inline(this.tokens);\n      return this.tokens;\n    }\n    /**\n     * Lexing\n     */\n    ;\n\n    _proto.blockTokens = function blockTokens(src, tokens, top) {\n      if (tokens === void 0) {\n        tokens = [];\n      }\n\n      if (top === void 0) {\n        top = true;\n      }\n\n      if (this.options.pedantic) {\n        src = src.replace(/^ +$/gm, '');\n      }\n\n      var token, i, l, lastToken;\n\n      while (src) {\n        // newline\n        if (token = this.tokenizer.space(src)) {\n          src = src.substring(token.raw.length);\n\n          if (token.type) {\n            tokens.push(token);\n          }\n\n          continue;\n        } // code\n\n\n        if (token = this.tokenizer.code(src, tokens)) {\n          src = src.substring(token.raw.length);\n\n          if (token.type) {\n            tokens.push(token);\n          } else {\n            lastToken = tokens[tokens.length - 1];\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.text;\n          }\n\n          continue;\n        } // fences\n\n\n        if (token = this.tokenizer.fences(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // heading\n\n\n        if (token = this.tokenizer.heading(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // table no leading pipe (gfm)\n\n\n        if (token = this.tokenizer.nptable(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // hr\n\n\n        if (token = this.tokenizer.hr(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // blockquote\n\n\n        if (token = this.tokenizer.blockquote(src)) {\n          src = src.substring(token.raw.length);\n          token.tokens = this.blockTokens(token.text, [], top);\n          tokens.push(token);\n          continue;\n        } // list\n\n\n        if (token = this.tokenizer.list(src)) {\n          src = src.substring(token.raw.length);\n          l = token.items.length;\n\n          for (i = 0; i < l; i++) {\n            token.items[i].tokens = this.blockTokens(token.items[i].text, [], false);\n          }\n\n          tokens.push(token);\n          continue;\n        } // html\n\n\n        if (token = this.tokenizer.html(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // def\n\n\n        if (top && (token = this.tokenizer.def(src))) {\n          src = src.substring(token.raw.length);\n\n          if (!this.tokens.links[token.tag]) {\n            this.tokens.links[token.tag] = {\n              href: token.href,\n              title: token.title\n            };\n          }\n\n          continue;\n        } // table (gfm)\n\n\n        if (token = this.tokenizer.table(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // lheading\n\n\n        if (token = this.tokenizer.lheading(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // top-level paragraph\n\n\n        if (top && (token = this.tokenizer.paragraph(src))) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // text\n\n\n        if (token = this.tokenizer.text(src, tokens)) {\n          src = src.substring(token.raw.length);\n\n          if (token.type) {\n            tokens.push(token);\n          } else {\n            lastToken = tokens[tokens.length - 1];\n            lastToken.raw += '\\n' + token.raw;\n            lastToken.text += '\\n' + token.text;\n          }\n\n          continue;\n        }\n\n        if (src) {\n          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n\n          if (this.options.silent) {\n            console.error(errMsg);\n            break;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n\n      return tokens;\n    };\n\n    _proto.inline = function inline(tokens) {\n      var i, j, k, l2, row, token;\n      var l = tokens.length;\n\n      for (i = 0; i < l; i++) {\n        token = tokens[i];\n\n        switch (token.type) {\n          case 'paragraph':\n          case 'text':\n          case 'heading':\n            {\n              token.tokens = [];\n              this.inlineTokens(token.text, token.tokens);\n              break;\n            }\n\n          case 'table':\n            {\n              token.tokens = {\n                header: [],\n                cells: []\n              }; // header\n\n              l2 = token.header.length;\n\n              for (j = 0; j < l2; j++) {\n                token.tokens.header[j] = [];\n                this.inlineTokens(token.header[j], token.tokens.header[j]);\n              } // cells\n\n\n              l2 = token.cells.length;\n\n              for (j = 0; j < l2; j++) {\n                row = token.cells[j];\n                token.tokens.cells[j] = [];\n\n                for (k = 0; k < row.length; k++) {\n                  token.tokens.cells[j][k] = [];\n                  this.inlineTokens(row[k], token.tokens.cells[j][k]);\n                }\n              }\n\n              break;\n            }\n\n          case 'blockquote':\n            {\n              this.inline(token.tokens);\n              break;\n            }\n\n          case 'list':\n            {\n              l2 = token.items.length;\n\n              for (j = 0; j < l2; j++) {\n                this.inline(token.items[j].tokens);\n              }\n\n              break;\n            }\n        }\n      }\n\n      return tokens;\n    }\n    /**\n     * Lexing/Compiling\n     */\n    ;\n\n    _proto.inlineTokens = function inlineTokens(src, tokens, inLink, inRawBlock) {\n      if (tokens === void 0) {\n        tokens = [];\n      }\n\n      if (inLink === void 0) {\n        inLink = false;\n      }\n\n      if (inRawBlock === void 0) {\n        inRawBlock = false;\n      }\n\n      var token; // String with links masked to avoid interference with em and strong\n\n      var maskedSrc = src;\n      var match;\n      var keepPrevChar, prevChar; // Mask out reflinks\n\n      if (this.tokens.links) {\n        var links = Object.keys(this.tokens.links);\n\n        if (links.length > 0) {\n          while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n            if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n              maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString$1('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n            }\n          }\n        }\n      } // Mask out other blocks\n\n\n      while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n        maskedSrc = maskedSrc.slice(0, match.index) + '[' + repeatString$1('a', match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n      }\n\n      while (src) {\n        if (!keepPrevChar) {\n          prevChar = '';\n        }\n\n        keepPrevChar = false; // escape\n\n        if (token = this.tokenizer.escape(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // tag\n\n\n        if (token = this.tokenizer.tag(src, inLink, inRawBlock)) {\n          src = src.substring(token.raw.length);\n          inLink = token.inLink;\n          inRawBlock = token.inRawBlock;\n          tokens.push(token);\n          continue;\n        } // link\n\n\n        if (token = this.tokenizer.link(src)) {\n          src = src.substring(token.raw.length);\n\n          if (token.type === 'link') {\n            token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);\n          }\n\n          tokens.push(token);\n          continue;\n        } // reflink, nolink\n\n\n        if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n          src = src.substring(token.raw.length);\n\n          if (token.type === 'link') {\n            token.tokens = this.inlineTokens(token.text, [], true, inRawBlock);\n          }\n\n          tokens.push(token);\n          continue;\n        } // strong\n\n\n        if (token = this.tokenizer.strong(src, maskedSrc, prevChar)) {\n          src = src.substring(token.raw.length);\n          token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);\n          tokens.push(token);\n          continue;\n        } // em\n\n\n        if (token = this.tokenizer.em(src, maskedSrc, prevChar)) {\n          src = src.substring(token.raw.length);\n          token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);\n          tokens.push(token);\n          continue;\n        } // code\n\n\n        if (token = this.tokenizer.codespan(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // br\n\n\n        if (token = this.tokenizer.br(src)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // del (gfm)\n\n\n        if (token = this.tokenizer.del(src)) {\n          src = src.substring(token.raw.length);\n          token.tokens = this.inlineTokens(token.text, [], inLink, inRawBlock);\n          tokens.push(token);\n          continue;\n        } // autolink\n\n\n        if (token = this.tokenizer.autolink(src, mangle)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // url (gfm)\n\n\n        if (!inLink && (token = this.tokenizer.url(src, mangle))) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          continue;\n        } // text\n\n\n        if (token = this.tokenizer.inlineText(src, inRawBlock, smartypants)) {\n          src = src.substring(token.raw.length);\n          prevChar = token.raw.slice(-1);\n          keepPrevChar = true;\n          tokens.push(token);\n          continue;\n        }\n\n        if (src) {\n          var errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n\n          if (this.options.silent) {\n            console.error(errMsg);\n            break;\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n\n      return tokens;\n    };\n\n    _createClass(Lexer, null, [{\n      key: \"rules\",\n      get: function get() {\n        return {\n          block: block$1,\n          inline: inline$1\n        };\n      }\n    }]);\n\n    return Lexer;\n  }();\n\n  var defaults$3 = defaults.defaults;\n  var cleanUrl$1 = helpers.cleanUrl,\n      escape$1 = helpers.escape;\n  /**\n   * Renderer\n   */\n\n  var Renderer_1 = /*#__PURE__*/function () {\n    function Renderer(options) {\n      this.options = options || defaults$3;\n    }\n\n    var _proto = Renderer.prototype;\n\n    _proto.code = function code(_code, infostring, escaped) {\n      var lang = (infostring || '').match(/\\S*/)[0];\n\n      if (this.options.highlight) {\n        var out = this.options.highlight(_code, lang);\n\n        if (out != null && out !== _code) {\n          escaped = true;\n          _code = out;\n        }\n      }\n\n      _code = _code.replace(/\\n$/, '') + '\\n';\n\n      if (!lang) {\n        return '<pre><code>' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\\n';\n      }\n\n      return '<pre><code class=\"' + this.options.langPrefix + escape$1(lang, true) + '\">' + (escaped ? _code : escape$1(_code, true)) + '</code></pre>\\n';\n    };\n\n    _proto.blockquote = function blockquote(quote) {\n      return '<blockquote>\\n' + quote + '</blockquote>\\n';\n    };\n\n    _proto.html = function html(_html) {\n      return _html;\n    };\n\n    _proto.heading = function heading(text, level, raw, slugger) {\n      if (this.options.headerIds) {\n        return '<h' + level + ' id=\"' + this.options.headerPrefix + slugger.slug(raw) + '\">' + text + '</h' + level + '>\\n';\n      } // ignore IDs\n\n\n      return '<h' + level + '>' + text + '</h' + level + '>\\n';\n    };\n\n    _proto.hr = function hr() {\n      return this.options.xhtml ? '<hr/>\\n' : '<hr>\\n';\n    };\n\n    _proto.list = function list(body, ordered, start) {\n      var type = ordered ? 'ol' : 'ul',\n          startatt = ordered && start !== 1 ? ' start=\"' + start + '\"' : '';\n      return '<' + type + startatt + '>\\n' + body + '</' + type + '>\\n';\n    };\n\n    _proto.listitem = function listitem(text) {\n      return '<li>' + text + '</li>\\n';\n    };\n\n    _proto.checkbox = function checkbox(checked) {\n      return '<input ' + (checked ? 'checked=\"\" ' : '') + 'disabled=\"\" type=\"checkbox\"' + (this.options.xhtml ? ' /' : '') + '> ';\n    };\n\n    _proto.paragraph = function paragraph(text) {\n      return '<p>' + text + '</p>\\n';\n    };\n\n    _proto.table = function table(header, body) {\n      if (body) body = '<tbody>' + body + '</tbody>';\n      return '<table>\\n' + '<thead>\\n' + header + '</thead>\\n' + body + '</table>\\n';\n    };\n\n    _proto.tablerow = function tablerow(content) {\n      return '<tr>\\n' + content + '</tr>\\n';\n    };\n\n    _proto.tablecell = function tablecell(content, flags) {\n      var type = flags.header ? 'th' : 'td';\n      var tag = flags.align ? '<' + type + ' align=\"' + flags.align + '\">' : '<' + type + '>';\n      return tag + content + '</' + type + '>\\n';\n    } // span level renderer\n    ;\n\n    _proto.strong = function strong(text) {\n      return '<strong>' + text + '</strong>';\n    };\n\n    _proto.em = function em(text) {\n      return '<em>' + text + '</em>';\n    };\n\n    _proto.codespan = function codespan(text) {\n      return '<code>' + text + '</code>';\n    };\n\n    _proto.br = function br() {\n      return this.options.xhtml ? '<br/>' : '<br>';\n    };\n\n    _proto.del = function del(text) {\n      return '<del>' + text + '</del>';\n    };\n\n    _proto.link = function link(href, title, text) {\n      href = cleanUrl$1(this.options.sanitize, this.options.baseUrl, href);\n\n      if (href === null) {\n        return text;\n      }\n\n      var out = '<a href=\"' + escape$1(href) + '\"';\n\n      if (title) {\n        out += ' title=\"' + title + '\"';\n      }\n\n      out += '>' + text + '</a>';\n      return out;\n    };\n\n    _proto.image = function image(href, title, text) {\n      href = cleanUrl$1(this.options.sanitize, this.options.baseUrl, href);\n\n      if (href === null) {\n        return text;\n      }\n\n      var out = '<img src=\"' + href + '\" alt=\"' + text + '\"';\n\n      if (title) {\n        out += ' title=\"' + title + '\"';\n      }\n\n      out += this.options.xhtml ? '/>' : '>';\n      return out;\n    };\n\n    _proto.text = function text(_text) {\n      return _text;\n    };\n\n    return Renderer;\n  }();\n\n  /**\n   * TextRenderer\n   * returns only the textual part of the token\n   */\n  var TextRenderer_1 = /*#__PURE__*/function () {\n    function TextRenderer() {}\n\n    var _proto = TextRenderer.prototype;\n\n    // no need for block level renderers\n    _proto.strong = function strong(text) {\n      return text;\n    };\n\n    _proto.em = function em(text) {\n      return text;\n    };\n\n    _proto.codespan = function codespan(text) {\n      return text;\n    };\n\n    _proto.del = function del(text) {\n      return text;\n    };\n\n    _proto.html = function html(text) {\n      return text;\n    };\n\n    _proto.text = function text(_text) {\n      return _text;\n    };\n\n    _proto.link = function link(href, title, text) {\n      return '' + text;\n    };\n\n    _proto.image = function image(href, title, text) {\n      return '' + text;\n    };\n\n    _proto.br = function br() {\n      return '';\n    };\n\n    return TextRenderer;\n  }();\n\n  /**\n   * Slugger generates header id\n   */\n  var Slugger_1 = /*#__PURE__*/function () {\n    function Slugger() {\n      this.seen = {};\n    }\n\n    var _proto = Slugger.prototype;\n\n    _proto.serialize = function serialize(value) {\n      return value.toLowerCase().trim() // remove html tags\n      .replace(/<[!\\/a-z].*?>/ig, '') // remove unwanted chars\n      .replace(/[\\u2000-\\u206F\\u2E00-\\u2E7F\\\\'!\"#$%&()*+,./:;<=>?@[\\]^`{|}~]/g, '').replace(/\\s/g, '-');\n    }\n    /**\n     * Finds the next safe (unique) slug to use\n     */\n    ;\n\n    _proto.getNextSafeSlug = function getNextSafeSlug(originalSlug, isDryRun) {\n      var slug = originalSlug;\n      var occurenceAccumulator = 0;\n\n      if (this.seen.hasOwnProperty(slug)) {\n        occurenceAccumulator = this.seen[originalSlug];\n\n        do {\n          occurenceAccumulator++;\n          slug = originalSlug + '-' + occurenceAccumulator;\n        } while (this.seen.hasOwnProperty(slug));\n      }\n\n      if (!isDryRun) {\n        this.seen[originalSlug] = occurenceAccumulator;\n        this.seen[slug] = 0;\n      }\n\n      return slug;\n    }\n    /**\n     * Convert string to unique id\n     * @param {object} options\n     * @param {boolean} options.dryrun Generates the next unique slug without updating the internal accumulator.\n     */\n    ;\n\n    _proto.slug = function slug(value, options) {\n      if (options === void 0) {\n        options = {};\n      }\n\n      var slug = this.serialize(value);\n      return this.getNextSafeSlug(slug, options.dryrun);\n    };\n\n    return Slugger;\n  }();\n\n  var defaults$4 = defaults.defaults;\n  var unescape$1 = helpers.unescape;\n  /**\n   * Parsing & Compiling\n   */\n\n  var Parser_1 = /*#__PURE__*/function () {\n    function Parser(options) {\n      this.options = options || defaults$4;\n      this.options.renderer = this.options.renderer || new Renderer_1();\n      this.renderer = this.options.renderer;\n      this.renderer.options = this.options;\n      this.textRenderer = new TextRenderer_1();\n      this.slugger = new Slugger_1();\n    }\n    /**\n     * Static Parse Method\n     */\n\n\n    Parser.parse = function parse(tokens, options) {\n      var parser = new Parser(options);\n      return parser.parse(tokens);\n    }\n    /**\n     * Static Parse Inline Method\n     */\n    ;\n\n    Parser.parseInline = function parseInline(tokens, options) {\n      var parser = new Parser(options);\n      return parser.parseInline(tokens);\n    }\n    /**\n     * Parse Loop\n     */\n    ;\n\n    var _proto = Parser.prototype;\n\n    _proto.parse = function parse(tokens, top) {\n      if (top === void 0) {\n        top = true;\n      }\n\n      var out = '',\n          i,\n          j,\n          k,\n          l2,\n          l3,\n          row,\n          cell,\n          header,\n          body,\n          token,\n          ordered,\n          start,\n          loose,\n          itemBody,\n          item,\n          checked,\n          task,\n          checkbox;\n      var l = tokens.length;\n\n      for (i = 0; i < l; i++) {\n        token = tokens[i];\n\n        switch (token.type) {\n          case 'space':\n            {\n              continue;\n            }\n\n          case 'hr':\n            {\n              out += this.renderer.hr();\n              continue;\n            }\n\n          case 'heading':\n            {\n              out += this.renderer.heading(this.parseInline(token.tokens), token.depth, unescape$1(this.parseInline(token.tokens, this.textRenderer)), this.slugger);\n              continue;\n            }\n\n          case 'code':\n            {\n              out += this.renderer.code(token.text, token.lang, token.escaped);\n              continue;\n            }\n\n          case 'table':\n            {\n              header = ''; // header\n\n              cell = '';\n              l2 = token.header.length;\n\n              for (j = 0; j < l2; j++) {\n                cell += this.renderer.tablecell(this.parseInline(token.tokens.header[j]), {\n                  header: true,\n                  align: token.align[j]\n                });\n              }\n\n              header += this.renderer.tablerow(cell);\n              body = '';\n              l2 = token.cells.length;\n\n              for (j = 0; j < l2; j++) {\n                row = token.tokens.cells[j];\n                cell = '';\n                l3 = row.length;\n\n                for (k = 0; k < l3; k++) {\n                  cell += this.renderer.tablecell(this.parseInline(row[k]), {\n                    header: false,\n                    align: token.align[k]\n                  });\n                }\n\n                body += this.renderer.tablerow(cell);\n              }\n\n              out += this.renderer.table(header, body);\n              continue;\n            }\n\n          case 'blockquote':\n            {\n              body = this.parse(token.tokens);\n              out += this.renderer.blockquote(body);\n              continue;\n            }\n\n          case 'list':\n            {\n              ordered = token.ordered;\n              start = token.start;\n              loose = token.loose;\n              l2 = token.items.length;\n              body = '';\n\n              for (j = 0; j < l2; j++) {\n                item = token.items[j];\n                checked = item.checked;\n                task = item.task;\n                itemBody = '';\n\n                if (item.task) {\n                  checkbox = this.renderer.checkbox(checked);\n\n                  if (loose) {\n                    if (item.tokens.length > 0 && item.tokens[0].type === 'text') {\n                      item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n\n                      if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n                        item.tokens[0].tokens[0].text = checkbox + ' ' + item.tokens[0].tokens[0].text;\n                      }\n                    } else {\n                      item.tokens.unshift({\n                        type: 'text',\n                        text: checkbox\n                      });\n                    }\n                  } else {\n                    itemBody += checkbox;\n                  }\n                }\n\n                itemBody += this.parse(item.tokens, loose);\n                body += this.renderer.listitem(itemBody, task, checked);\n              }\n\n              out += this.renderer.list(body, ordered, start);\n              continue;\n            }\n\n          case 'html':\n            {\n              // TODO parse inline content if parameter markdown=1\n              out += this.renderer.html(token.text);\n              continue;\n            }\n\n          case 'paragraph':\n            {\n              out += this.renderer.paragraph(this.parseInline(token.tokens));\n              continue;\n            }\n\n          case 'text':\n            {\n              body = token.tokens ? this.parseInline(token.tokens) : token.text;\n\n              while (i + 1 < l && tokens[i + 1].type === 'text') {\n                token = tokens[++i];\n                body += '\\n' + (token.tokens ? this.parseInline(token.tokens) : token.text);\n              }\n\n              out += top ? this.renderer.paragraph(body) : body;\n              continue;\n            }\n\n          default:\n            {\n              var errMsg = 'Token with \"' + token.type + '\" type was not found.';\n\n              if (this.options.silent) {\n                console.error(errMsg);\n                return;\n              } else {\n                throw new Error(errMsg);\n              }\n            }\n        }\n      }\n\n      return out;\n    }\n    /**\n     * Parse Inline Tokens\n     */\n    ;\n\n    _proto.parseInline = function parseInline(tokens, renderer) {\n      renderer = renderer || this.renderer;\n      var out = '',\n          i,\n          token;\n      var l = tokens.length;\n\n      for (i = 0; i < l; i++) {\n        token = tokens[i];\n\n        switch (token.type) {\n          case 'escape':\n            {\n              out += renderer.text(token.text);\n              break;\n            }\n\n          case 'html':\n            {\n              out += renderer.html(token.text);\n              break;\n            }\n\n          case 'link':\n            {\n              out += renderer.link(token.href, token.title, this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'image':\n            {\n              out += renderer.image(token.href, token.title, token.text);\n              break;\n            }\n\n          case 'strong':\n            {\n              out += renderer.strong(this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'em':\n            {\n              out += renderer.em(this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'codespan':\n            {\n              out += renderer.codespan(token.text);\n              break;\n            }\n\n          case 'br':\n            {\n              out += renderer.br();\n              break;\n            }\n\n          case 'del':\n            {\n              out += renderer.del(this.parseInline(token.tokens, renderer));\n              break;\n            }\n\n          case 'text':\n            {\n              out += renderer.text(token.text);\n              break;\n            }\n\n          default:\n            {\n              var errMsg = 'Token with \"' + token.type + '\" type was not found.';\n\n              if (this.options.silent) {\n                console.error(errMsg);\n                return;\n              } else {\n                throw new Error(errMsg);\n              }\n            }\n        }\n      }\n\n      return out;\n    };\n\n    return Parser;\n  }();\n\n  var merge$2 = helpers.merge,\n      checkSanitizeDeprecation$1 = helpers.checkSanitizeDeprecation,\n      escape$2 = helpers.escape;\n  var getDefaults = defaults.getDefaults,\n      changeDefaults = defaults.changeDefaults,\n      defaults$5 = defaults.defaults;\n  /**\n   * Marked\n   */\n\n  function marked(src, opt, callback) {\n    // throw error in case of non string input\n    if (typeof src === 'undefined' || src === null) {\n      throw new Error('marked(): input parameter is undefined or null');\n    }\n\n    if (typeof src !== 'string') {\n      throw new Error('marked(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');\n    }\n\n    if (typeof opt === 'function') {\n      callback = opt;\n      opt = null;\n    }\n\n    opt = merge$2({}, marked.defaults, opt || {});\n    checkSanitizeDeprecation$1(opt);\n\n    if (callback) {\n      var highlight = opt.highlight;\n      var tokens;\n\n      try {\n        tokens = Lexer_1.lex(src, opt);\n      } catch (e) {\n        return callback(e);\n      }\n\n      var done = function done(err) {\n        var out;\n\n        if (!err) {\n          try {\n            out = Parser_1.parse(tokens, opt);\n          } catch (e) {\n            err = e;\n          }\n        }\n\n        opt.highlight = highlight;\n        return err ? callback(err) : callback(null, out);\n      };\n\n      if (!highlight || highlight.length < 3) {\n        return done();\n      }\n\n      delete opt.highlight;\n      if (!tokens.length) return done();\n      var pending = 0;\n      marked.walkTokens(tokens, function (token) {\n        if (token.type === 'code') {\n          pending++;\n          setTimeout(function () {\n            highlight(token.text, token.lang, function (err, code) {\n              if (err) {\n                return done(err);\n              }\n\n              if (code != null && code !== token.text) {\n                token.text = code;\n                token.escaped = true;\n              }\n\n              pending--;\n\n              if (pending === 0) {\n                done();\n              }\n            });\n          }, 0);\n        }\n      });\n\n      if (pending === 0) {\n        done();\n      }\n\n      return;\n    }\n\n    try {\n      var _tokens = Lexer_1.lex(src, opt);\n\n      if (opt.walkTokens) {\n        marked.walkTokens(_tokens, opt.walkTokens);\n      }\n\n      return Parser_1.parse(_tokens, opt);\n    } catch (e) {\n      e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n      if (opt.silent) {\n        return '<p>An error occurred:</p><pre>' + escape$2(e.message + '', true) + '</pre>';\n      }\n\n      throw e;\n    }\n  }\n  /**\n   * Options\n   */\n\n\n  marked.options = marked.setOptions = function (opt) {\n    merge$2(marked.defaults, opt);\n    changeDefaults(marked.defaults);\n    return marked;\n  };\n\n  marked.getDefaults = getDefaults;\n  marked.defaults = defaults$5;\n  /**\n   * Use Extension\n   */\n\n  marked.use = function (extension) {\n    var opts = merge$2({}, extension);\n\n    if (extension.renderer) {\n      (function () {\n        var renderer = marked.defaults.renderer || new Renderer_1();\n\n        var _loop = function _loop(prop) {\n          var prevRenderer = renderer[prop];\n\n          renderer[prop] = function () {\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n\n            var ret = extension.renderer[prop].apply(renderer, args);\n\n            if (ret === false) {\n              ret = prevRenderer.apply(renderer, args);\n            }\n\n            return ret;\n          };\n        };\n\n        for (var prop in extension.renderer) {\n          _loop(prop);\n        }\n\n        opts.renderer = renderer;\n      })();\n    }\n\n    if (extension.tokenizer) {\n      (function () {\n        var tokenizer = marked.defaults.tokenizer || new Tokenizer_1();\n\n        var _loop2 = function _loop2(prop) {\n          var prevTokenizer = tokenizer[prop];\n\n          tokenizer[prop] = function () {\n            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n              args[_key2] = arguments[_key2];\n            }\n\n            var ret = extension.tokenizer[prop].apply(tokenizer, args);\n\n            if (ret === false) {\n              ret = prevTokenizer.apply(tokenizer, args);\n            }\n\n            return ret;\n          };\n        };\n\n        for (var prop in extension.tokenizer) {\n          _loop2(prop);\n        }\n\n        opts.tokenizer = tokenizer;\n      })();\n    }\n\n    if (extension.walkTokens) {\n      var walkTokens = marked.defaults.walkTokens;\n\n      opts.walkTokens = function (token) {\n        extension.walkTokens(token);\n\n        if (walkTokens) {\n          walkTokens(token);\n        }\n      };\n    }\n\n    marked.setOptions(opts);\n  };\n  /**\n   * Run callback for every token\n   */\n\n\n  marked.walkTokens = function (tokens, callback) {\n    for (var _iterator = _createForOfIteratorHelperLoose(tokens), _step; !(_step = _iterator()).done;) {\n      var token = _step.value;\n      callback(token);\n\n      switch (token.type) {\n        case 'table':\n          {\n            for (var _iterator2 = _createForOfIteratorHelperLoose(token.tokens.header), _step2; !(_step2 = _iterator2()).done;) {\n              var cell = _step2.value;\n              marked.walkTokens(cell, callback);\n            }\n\n            for (var _iterator3 = _createForOfIteratorHelperLoose(token.tokens.cells), _step3; !(_step3 = _iterator3()).done;) {\n              var row = _step3.value;\n\n              for (var _iterator4 = _createForOfIteratorHelperLoose(row), _step4; !(_step4 = _iterator4()).done;) {\n                var _cell = _step4.value;\n                marked.walkTokens(_cell, callback);\n              }\n            }\n\n            break;\n          }\n\n        case 'list':\n          {\n            marked.walkTokens(token.items, callback);\n            break;\n          }\n\n        default:\n          {\n            if (token.tokens) {\n              marked.walkTokens(token.tokens, callback);\n            }\n          }\n      }\n    }\n  };\n  /**\n   * Parse Inline\n   */\n\n\n  marked.parseInline = function (src, opt) {\n    // throw error in case of non string input\n    if (typeof src === 'undefined' || src === null) {\n      throw new Error('marked.parseInline(): input parameter is undefined or null');\n    }\n\n    if (typeof src !== 'string') {\n      throw new Error('marked.parseInline(): input parameter is of type ' + Object.prototype.toString.call(src) + ', string expected');\n    }\n\n    opt = merge$2({}, marked.defaults, opt || {});\n    checkSanitizeDeprecation$1(opt);\n\n    try {\n      var tokens = Lexer_1.lexInline(src, opt);\n\n      if (opt.walkTokens) {\n        marked.walkTokens(tokens, opt.walkTokens);\n      }\n\n      return Parser_1.parseInline(tokens, opt);\n    } catch (e) {\n      e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n      if (opt.silent) {\n        return '<p>An error occurred:</p><pre>' + escape$2(e.message + '', true) + '</pre>';\n      }\n\n      throw e;\n    }\n  };\n  /**\n   * Expose\n   */\n\n\n  marked.Parser = Parser_1;\n  marked.parser = Parser_1.parse;\n  marked.Renderer = Renderer_1;\n  marked.TextRenderer = TextRenderer_1;\n  marked.Lexer = Lexer_1;\n  marked.lexer = Lexer_1.lex;\n  marked.Tokenizer = Tokenizer_1;\n  marked.Slugger = Slugger_1;\n  marked.parse = marked;\n  var marked_1 = marked;\n\n  return marked_1;\n\n})));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWFya2VkL2xpYi9tYXJrZWQuanM/MGU1NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSxLQUE0RDtBQUM5RCxFQUFFLFNBQ3FHO0FBQ3ZHLENBQUMscUJBQXFCOztBQUV0QjtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMENBQTBDLFNBQVM7O0FBRW5EO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLGdEQUFnRDtBQUNoRDtBQUNBLGVBQWU7QUFDZixjQUFjO0FBQ2QsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLHNCQUFzQjtBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxrQkFBa0I7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7OztBQUdMLG9CQUFvQjs7QUFFcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLE9BQU87QUFDakI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLElBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLE9BQU87QUFDOUI7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7OztBQUdBO0FBQ0EsMERBQTBEO0FBQzFEOztBQUVBO0FBQ0E7QUFDQSx3RUFBd0UsZ0JBQWdCLGlDQUFpQyxJQUFJO0FBQzdILFdBQVc7QUFDWDtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVzs7O0FBR1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBOztBQUVBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOzs7QUFHWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FB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QUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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Q0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQSx3RUFBd0UsNkJBQTZCO0FBQ3JHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLCtCQUErQjtBQUM5SDtBQUNBO0FBQ0E7O0FBRUEsOEZBQThGLCtCQUErQjtBQUM3SDs7QUFFQSxpRkFBaUYsK0JBQStCO0FBQ2hIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9tYXJrZWQvbGliL21hcmtlZC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogbWFya2VkIC0gYSBtYXJrZG93biBwYXJzZXJcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDIxLCBDaHJpc3RvcGhlciBKZWZmcmV5LiAoTUlUIExpY2Vuc2VkKVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZFxuICovXG5cbi8qKlxuICogRE8gTk9UIEVESVQgVEhJUyBGSUxFXG4gKiBUaGUgY29kZSBpbiB0aGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gZmlsZXMgaW4gLi9zcmMvXG4gKi9cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IGdsb2JhbCB8fCBzZWxmLCBnbG9iYWwubWFya2VkID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgICBpZiAoIW8pIHJldHVybjtcbiAgICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICAgIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICAgIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG5cbiAgICByZXR1cm4gYXJyMjtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UobywgYWxsb3dBcnJheUxpa2UpIHtcbiAgICB2YXIgaXQ7XG5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoaXQpIG8gPSBpdDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IG9baSsrXVxuICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgICB9XG5cbiAgICBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgIHJldHVybiBpdC5uZXh0LmJpbmQoaXQpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4pIHtcbiAgICB2YXIgbW9kdWxlID0geyBleHBvcnRzOiB7fSB9O1xuICBcdHJldHVybiBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG4gIH1cblxuICB2YXIgZGVmYXVsdHMgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG4gICAgZnVuY3Rpb24gZ2V0RGVmYXVsdHMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBiYXNlVXJsOiBudWxsLFxuICAgICAgICBicmVha3M6IGZhbHNlLFxuICAgICAgICBnZm06IHRydWUsXG4gICAgICAgIGhlYWRlcklkczogdHJ1ZSxcbiAgICAgICAgaGVhZGVyUHJlZml4OiAnJyxcbiAgICAgICAgaGlnaGxpZ2h0OiBudWxsLFxuICAgICAgICBsYW5nUHJlZml4OiAnbGFuZ3VhZ2UtJyxcbiAgICAgICAgbWFuZ2xlOiB0cnVlLFxuICAgICAgICBwZWRhbnRpYzogZmFsc2UsXG4gICAgICAgIHJlbmRlcmVyOiBudWxsLFxuICAgICAgICBzYW5pdGl6ZTogZmFsc2UsXG4gICAgICAgIHNhbml0aXplcjogbnVsbCxcbiAgICAgICAgc2lsZW50OiBmYWxzZSxcbiAgICAgICAgc21hcnRMaXN0czogZmFsc2UsXG4gICAgICAgIHNtYXJ0eXBhbnRzOiBmYWxzZSxcbiAgICAgICAgdG9rZW5pemVyOiBudWxsLFxuICAgICAgICB3YWxrVG9rZW5zOiBudWxsLFxuICAgICAgICB4aHRtbDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hhbmdlRGVmYXVsdHMobmV3RGVmYXVsdHMpIHtcbiAgICAgIG1vZHVsZS5leHBvcnRzLmRlZmF1bHRzID0gbmV3RGVmYXVsdHM7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgICBkZWZhdWx0czogZ2V0RGVmYXVsdHMoKSxcbiAgICAgIGdldERlZmF1bHRzOiBnZXREZWZhdWx0cyxcbiAgICAgIGNoYW5nZURlZmF1bHRzOiBjaGFuZ2VEZWZhdWx0c1xuICAgIH07XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBIZWxwZXJzXG4gICAqL1xuICB2YXIgZXNjYXBlVGVzdCA9IC9bJjw+XCInXS87XG4gIHZhciBlc2NhcGVSZXBsYWNlID0gL1smPD5cIiddL2c7XG4gIHZhciBlc2NhcGVUZXN0Tm9FbmNvZGUgPSAvWzw+XCInXXwmKD8hIz9cXHcrOykvO1xuICB2YXIgZXNjYXBlUmVwbGFjZU5vRW5jb2RlID0gL1s8PlwiJ118Jig/ISM/XFx3KzspL2c7XG4gIHZhciBlc2NhcGVSZXBsYWNlbWVudHMgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiMzOTsnXG4gIH07XG5cbiAgdmFyIGdldEVzY2FwZVJlcGxhY2VtZW50ID0gZnVuY3Rpb24gZ2V0RXNjYXBlUmVwbGFjZW1lbnQoY2gpIHtcbiAgICByZXR1cm4gZXNjYXBlUmVwbGFjZW1lbnRzW2NoXTtcbiAgfTtcblxuICBmdW5jdGlvbiBlc2NhcGUoaHRtbCwgZW5jb2RlKSB7XG4gICAgaWYgKGVuY29kZSkge1xuICAgICAgaWYgKGVzY2FwZVRlc3QudGVzdChodG1sKSkge1xuICAgICAgICByZXR1cm4gaHRtbC5yZXBsYWNlKGVzY2FwZVJlcGxhY2UsIGdldEVzY2FwZVJlcGxhY2VtZW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGVzY2FwZVRlc3ROb0VuY29kZS50ZXN0KGh0bWwpKSB7XG4gICAgICAgIHJldHVybiBodG1sLnJlcGxhY2UoZXNjYXBlUmVwbGFjZU5vRW5jb2RlLCBnZXRFc2NhcGVSZXBsYWNlbWVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGh0bWw7XG4gIH1cblxuICB2YXIgdW5lc2NhcGVUZXN0ID0gLyYoIyg/OlxcZCspfCg/OiN4WzAtOUEtRmEtZl0rKXwoPzpcXHcrKSk7Py9pZztcblxuICBmdW5jdGlvbiB1bmVzY2FwZShodG1sKSB7XG4gICAgLy8gZXhwbGljaXRseSBtYXRjaCBkZWNpbWFsLCBoZXgsIGFuZCBuYW1lZCBIVE1MIGVudGl0aWVzXG4gICAgcmV0dXJuIGh0bWwucmVwbGFjZSh1bmVzY2FwZVRlc3QsIGZ1bmN0aW9uIChfLCBuKSB7XG4gICAgICBuID0gbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKG4gPT09ICdjb2xvbicpIHJldHVybiAnOic7XG5cbiAgICAgIGlmIChuLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgIHJldHVybiBuLmNoYXJBdCgxKSA9PT0gJ3gnID8gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChuLnN1YnN0cmluZygyKSwgMTYpKSA6IFN0cmluZy5mcm9tQ2hhckNvZGUoK24uc3Vic3RyaW5nKDEpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcnO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGNhcmV0ID0gLyhefFteXFxbXSlcXF4vZztcblxuICBmdW5jdGlvbiBlZGl0KHJlZ2V4LCBvcHQpIHtcbiAgICByZWdleCA9IHJlZ2V4LnNvdXJjZSB8fCByZWdleDtcbiAgICBvcHQgPSBvcHQgfHwgJyc7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIHJlcGxhY2U6IGZ1bmN0aW9uIHJlcGxhY2UobmFtZSwgdmFsKSB7XG4gICAgICAgIHZhbCA9IHZhbC5zb3VyY2UgfHwgdmFsO1xuICAgICAgICB2YWwgPSB2YWwucmVwbGFjZShjYXJldCwgJyQxJyk7XG4gICAgICAgIHJlZ2V4ID0gcmVnZXgucmVwbGFjZShuYW1lLCB2YWwpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgfSxcbiAgICAgIGdldFJlZ2V4OiBmdW5jdGlvbiBnZXRSZWdleCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAocmVnZXgsIG9wdCk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIG5vbldvcmRBbmRDb2xvblRlc3QgPSAvW15cXHc6XS9nO1xuICB2YXIgb3JpZ2luSW5kZXBlbmRlbnRVcmwgPSAvXiR8XlthLXpdW2EtejAtOSsuLV0qOnxeWz8jXS9pO1xuXG4gIGZ1bmN0aW9uIGNsZWFuVXJsKHNhbml0aXplLCBiYXNlLCBocmVmKSB7XG4gICAgaWYgKHNhbml0aXplKSB7XG4gICAgICB2YXIgcHJvdDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcHJvdCA9IGRlY29kZVVSSUNvbXBvbmVudCh1bmVzY2FwZShocmVmKSkucmVwbGFjZShub25Xb3JkQW5kQ29sb25UZXN0LCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm90LmluZGV4T2YoJ2phdmFzY3JpcHQ6JykgPT09IDAgfHwgcHJvdC5pbmRleE9mKCd2YnNjcmlwdDonKSA9PT0gMCB8fCBwcm90LmluZGV4T2YoJ2RhdGE6JykgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgJiYgIW9yaWdpbkluZGVwZW5kZW50VXJsLnRlc3QoaHJlZikpIHtcbiAgICAgIGhyZWYgPSByZXNvbHZlVXJsKGJhc2UsIGhyZWYpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBocmVmID0gZW5jb2RlVVJJKGhyZWYpLnJlcGxhY2UoLyUyNS9nLCAnJScpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBocmVmO1xuICB9XG5cbiAgdmFyIGJhc2VVcmxzID0ge307XG4gIHZhciBqdXN0RG9tYWluID0gL15bXjpdKzpcXC8qW14vXSokLztcbiAgdmFyIHByb3RvY29sID0gL14oW146XSs6KVtcXHNcXFNdKiQvO1xuICB2YXIgZG9tYWluID0gL14oW146XSs6XFwvKlteL10qKVtcXHNcXFNdKiQvO1xuXG4gIGZ1bmN0aW9uIHJlc29sdmVVcmwoYmFzZSwgaHJlZikge1xuICAgIGlmICghYmFzZVVybHNbJyAnICsgYmFzZV0pIHtcbiAgICAgIC8vIHdlIGNhbiBpZ25vcmUgZXZlcnl0aGluZyBpbiBiYXNlIGFmdGVyIHRoZSBsYXN0IHNsYXNoIG9mIGl0cyBwYXRoIGNvbXBvbmVudCxcbiAgICAgIC8vIGJ1dCB3ZSBtaWdodCBuZWVkIHRvIGFkZCBfdGhhdF9cbiAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tM1xuICAgICAgaWYgKGp1c3REb21haW4udGVzdChiYXNlKSkge1xuICAgICAgICBiYXNlVXJsc1snICcgKyBiYXNlXSA9IGJhc2UgKyAnLyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiYXNlVXJsc1snICcgKyBiYXNlXSA9IHJ0cmltKGJhc2UsICcvJywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYmFzZSA9IGJhc2VVcmxzWycgJyArIGJhc2VdO1xuICAgIHZhciByZWxhdGl2ZUJhc2UgPSBiYXNlLmluZGV4T2YoJzonKSA9PT0gLTE7XG5cbiAgICBpZiAoaHJlZi5zdWJzdHJpbmcoMCwgMikgPT09ICcvLycpIHtcbiAgICAgIGlmIChyZWxhdGl2ZUJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGhyZWY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiYXNlLnJlcGxhY2UocHJvdG9jb2wsICckMScpICsgaHJlZjtcbiAgICB9IGVsc2UgaWYgKGhyZWYuY2hhckF0KDApID09PSAnLycpIHtcbiAgICAgIGlmIChyZWxhdGl2ZUJhc2UpIHtcbiAgICAgICAgcmV0dXJuIGhyZWY7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiYXNlLnJlcGxhY2UoZG9tYWluLCAnJDEnKSArIGhyZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBiYXNlICsgaHJlZjtcbiAgICB9XG4gIH1cblxuICB2YXIgbm9vcFRlc3QgPSB7XG4gICAgZXhlYzogZnVuY3Rpb24gbm9vcFRlc3QoKSB7fVxuICB9O1xuXG4gIGZ1bmN0aW9uIG1lcmdlKG9iaikge1xuICAgIHZhciBpID0gMSxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBrZXk7XG5cbiAgICBmb3IgKDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdGFyZ2V0ID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0YXJnZXQsIGtleSkpIHtcbiAgICAgICAgICBvYmpba2V5XSA9IHRhcmdldFtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNwbGl0Q2VsbHModGFibGVSb3csIGNvdW50KSB7XG4gICAgLy8gZW5zdXJlIHRoYXQgZXZlcnkgY2VsbC1kZWxpbWl0aW5nIHBpcGUgaGFzIGEgc3BhY2VcbiAgICAvLyBiZWZvcmUgaXQgdG8gZGlzdGluZ3Vpc2ggaXQgZnJvbSBhbiBlc2NhcGVkIHBpcGVcbiAgICB2YXIgcm93ID0gdGFibGVSb3cucmVwbGFjZSgvXFx8L2csIGZ1bmN0aW9uIChtYXRjaCwgb2Zmc2V0LCBzdHIpIHtcbiAgICAgIHZhciBlc2NhcGVkID0gZmFsc2UsXG4gICAgICAgICAgY3VyciA9IG9mZnNldDtcblxuICAgICAgd2hpbGUgKC0tY3VyciA+PSAwICYmIHN0cltjdXJyXSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIGVzY2FwZWQgPSAhZXNjYXBlZDtcbiAgICAgIH1cblxuICAgICAgaWYgKGVzY2FwZWQpIHtcbiAgICAgICAgLy8gb2RkIG51bWJlciBvZiBzbGFzaGVzIG1lYW5zIHwgaXMgZXNjYXBlZFxuICAgICAgICAvLyBzbyB3ZSBsZWF2ZSBpdCBhbG9uZVxuICAgICAgICByZXR1cm4gJ3wnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYWRkIHNwYWNlIGJlZm9yZSB1bmVzY2FwZWQgfFxuICAgICAgICByZXR1cm4gJyB8JztcbiAgICAgIH1cbiAgICB9KSxcbiAgICAgICAgY2VsbHMgPSByb3cuc3BsaXQoLyBcXHwvKTtcbiAgICB2YXIgaSA9IDA7XG5cbiAgICBpZiAoY2VsbHMubGVuZ3RoID4gY291bnQpIHtcbiAgICAgIGNlbGxzLnNwbGljZShjb3VudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChjZWxscy5sZW5ndGggPCBjb3VudCkge1xuICAgICAgICBjZWxscy5wdXNoKCcnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKDsgaSA8IGNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBsZWFkaW5nIG9yIHRyYWlsaW5nIHdoaXRlc3BhY2UgaXMgaWdub3JlZCBwZXIgdGhlIGdmbSBzcGVjXG4gICAgICBjZWxsc1tpXSA9IGNlbGxzW2ldLnRyaW0oKS5yZXBsYWNlKC9cXFxcXFx8L2csICd8Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNlbGxzO1xuICB9IC8vIFJlbW92ZSB0cmFpbGluZyAnYydzLiBFcXVpdmFsZW50IHRvIHN0ci5yZXBsYWNlKC9jKiQvLCAnJykuXG4gIC8vIC9jKiQvIGlzIHZ1bG5lcmFibGUgdG8gUkVET1MuXG4gIC8vIGludmVydDogUmVtb3ZlIHN1ZmZpeCBvZiBub24tYyBjaGFycyBpbnN0ZWFkLiBEZWZhdWx0IGZhbHNleS5cblxuXG4gIGZ1bmN0aW9uIHJ0cmltKHN0ciwgYywgaW52ZXJ0KSB7XG4gICAgdmFyIGwgPSBzdHIubGVuZ3RoO1xuXG4gICAgaWYgKGwgPT09IDApIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9IC8vIExlbmd0aCBvZiBzdWZmaXggbWF0Y2hpbmcgdGhlIGludmVydCBjb25kaXRpb24uXG5cblxuICAgIHZhciBzdWZmTGVuID0gMDsgLy8gU3RlcCBsZWZ0IHVudGlsIHdlIGZhaWwgdG8gbWF0Y2ggdGhlIGludmVydCBjb25kaXRpb24uXG5cbiAgICB3aGlsZSAoc3VmZkxlbiA8IGwpIHtcbiAgICAgIHZhciBjdXJyQ2hhciA9IHN0ci5jaGFyQXQobCAtIHN1ZmZMZW4gLSAxKTtcblxuICAgICAgaWYgKGN1cnJDaGFyID09PSBjICYmICFpbnZlcnQpIHtcbiAgICAgICAgc3VmZkxlbisrO1xuICAgICAgfSBlbHNlIGlmIChjdXJyQ2hhciAhPT0gYyAmJiBpbnZlcnQpIHtcbiAgICAgICAgc3VmZkxlbisrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0ci5zdWJzdHIoMCwgbCAtIHN1ZmZMZW4pO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZENsb3NpbmdCcmFja2V0KHN0ciwgYikge1xuICAgIGlmIChzdHIuaW5kZXhPZihiWzFdKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICB2YXIgbCA9IHN0ci5sZW5ndGg7XG4gICAgdmFyIGxldmVsID0gMCxcbiAgICAgICAgaSA9IDA7XG5cbiAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHN0cltpXSA9PT0gJ1xcXFwnKSB7XG4gICAgICAgIGkrKztcbiAgICAgIH0gZWxzZSBpZiAoc3RyW2ldID09PSBiWzBdKSB7XG4gICAgICAgIGxldmVsKys7XG4gICAgICB9IGVsc2UgaWYgKHN0cltpXSA9PT0gYlsxXSkge1xuICAgICAgICBsZXZlbC0tO1xuXG4gICAgICAgIGlmIChsZXZlbCA8IDApIHtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrU2FuaXRpemVEZXByZWNhdGlvbihvcHQpIHtcbiAgICBpZiAob3B0ICYmIG9wdC5zYW5pdGl6ZSAmJiAhb3B0LnNpbGVudCkge1xuICAgICAgY29uc29sZS53YXJuKCdtYXJrZWQoKTogc2FuaXRpemUgYW5kIHNhbml0aXplciBwYXJhbWV0ZXJzIGFyZSBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMC43LjAsIHNob3VsZCBub3QgYmUgdXNlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUuIFJlYWQgbW9yZSBoZXJlOiBodHRwczovL21hcmtlZC5qcy5vcmcvIy9VU0lOR19BRFZBTkNFRC5tZCNvcHRpb25zJyk7XG4gICAgfVxuICB9IC8vIGNvcGllZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81NDUwMTEzLzgwNjc3N1xuXG5cbiAgZnVuY3Rpb24gcmVwZWF0U3RyaW5nKHBhdHRlcm4sIGNvdW50KSB7XG4gICAgaWYgKGNvdW50IDwgMSkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIHZhciByZXN1bHQgPSAnJztcblxuICAgIHdoaWxlIChjb3VudCA+IDEpIHtcbiAgICAgIGlmIChjb3VudCAmIDEpIHtcbiAgICAgICAgcmVzdWx0ICs9IHBhdHRlcm47XG4gICAgICB9XG5cbiAgICAgIGNvdW50ID4+PSAxO1xuICAgICAgcGF0dGVybiArPSBwYXR0ZXJuO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQgKyBwYXR0ZXJuO1xuICB9XG5cbiAgdmFyIGhlbHBlcnMgPSB7XG4gICAgZXNjYXBlOiBlc2NhcGUsXG4gICAgdW5lc2NhcGU6IHVuZXNjYXBlLFxuICAgIGVkaXQ6IGVkaXQsXG4gICAgY2xlYW5Vcmw6IGNsZWFuVXJsLFxuICAgIHJlc29sdmVVcmw6IHJlc29sdmVVcmwsXG4gICAgbm9vcFRlc3Q6IG5vb3BUZXN0LFxuICAgIG1lcmdlOiBtZXJnZSxcbiAgICBzcGxpdENlbGxzOiBzcGxpdENlbGxzLFxuICAgIHJ0cmltOiBydHJpbSxcbiAgICBmaW5kQ2xvc2luZ0JyYWNrZXQ6IGZpbmRDbG9zaW5nQnJhY2tldCxcbiAgICBjaGVja1Nhbml0aXplRGVwcmVjYXRpb246IGNoZWNrU2FuaXRpemVEZXByZWNhdGlvbixcbiAgICByZXBlYXRTdHJpbmc6IHJlcGVhdFN0cmluZ1xuICB9O1xuXG4gIHZhciBkZWZhdWx0cyQxID0gZGVmYXVsdHMuZGVmYXVsdHM7XG4gIHZhciBydHJpbSQxID0gaGVscGVycy5ydHJpbSxcbiAgICAgIHNwbGl0Q2VsbHMkMSA9IGhlbHBlcnMuc3BsaXRDZWxscyxcbiAgICAgIF9lc2NhcGUgPSBoZWxwZXJzLmVzY2FwZSxcbiAgICAgIGZpbmRDbG9zaW5nQnJhY2tldCQxID0gaGVscGVycy5maW5kQ2xvc2luZ0JyYWNrZXQ7XG5cbiAgZnVuY3Rpb24gb3V0cHV0TGluayhjYXAsIGxpbmssIHJhdykge1xuICAgIHZhciBocmVmID0gbGluay5ocmVmO1xuICAgIHZhciB0aXRsZSA9IGxpbmsudGl0bGUgPyBfZXNjYXBlKGxpbmsudGl0bGUpIDogbnVsbDtcbiAgICB2YXIgdGV4dCA9IGNhcFsxXS5yZXBsYWNlKC9cXFxcKFtcXFtcXF1dKS9nLCAnJDEnKTtcblxuICAgIGlmIChjYXBbMF0uY2hhckF0KDApICE9PSAnIScpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdsaW5rJyxcbiAgICAgICAgcmF3OiByYXcsXG4gICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgdGV4dDogdGV4dFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ2ltYWdlJyxcbiAgICAgICAgcmF3OiByYXcsXG4gICAgICAgIGhyZWY6IGhyZWYsXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcbiAgICAgICAgdGV4dDogX2VzY2FwZSh0ZXh0KVxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbmRlbnRDb2RlQ29tcGVuc2F0aW9uKHJhdywgdGV4dCkge1xuICAgIHZhciBtYXRjaEluZGVudFRvQ29kZSA9IHJhdy5tYXRjaCgvXihcXHMrKSg/OmBgYCkvKTtcblxuICAgIGlmIChtYXRjaEluZGVudFRvQ29kZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuXG4gICAgdmFyIGluZGVudFRvQ29kZSA9IG1hdGNoSW5kZW50VG9Db2RlWzFdO1xuICAgIHJldHVybiB0ZXh0LnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciBtYXRjaEluZGVudEluTm9kZSA9IG5vZGUubWF0Y2goL15cXHMrLyk7XG5cbiAgICAgIGlmIChtYXRjaEluZGVudEluTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGVudEluTm9kZSA9IG1hdGNoSW5kZW50SW5Ob2RlWzBdO1xuXG4gICAgICBpZiAoaW5kZW50SW5Ob2RlLmxlbmd0aCA+PSBpbmRlbnRUb0NvZGUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBub2RlLnNsaWNlKGluZGVudFRvQ29kZS5sZW5ndGgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9KS5qb2luKCdcXG4nKTtcbiAgfVxuICAvKipcbiAgICogVG9rZW5pemVyXG4gICAqL1xuXG5cbiAgdmFyIFRva2VuaXplcl8xID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUb2tlbml6ZXIob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQxO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBUb2tlbml6ZXIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLnNwYWNlID0gZnVuY3Rpb24gc3BhY2Uoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5uZXdsaW5lLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICBpZiAoY2FwWzBdLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ3NwYWNlJyxcbiAgICAgICAgICAgIHJhdzogY2FwWzBdXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmF3OiAnXFxuJ1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uY29kZSA9IGZ1bmN0aW9uIGNvZGUoc3JjLCB0b2tlbnMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmNvZGUuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdOyAvLyBBbiBpbmRlbnRlZCBjb2RlIGJsb2NrIGNhbm5vdCBpbnRlcnJ1cHQgYSBwYXJhZ3JhcGguXG5cbiAgICAgICAgaWYgKGxhc3RUb2tlbiAmJiBsYXN0VG9rZW4udHlwZSA9PT0gJ3BhcmFncmFwaCcpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgICB0ZXh0OiBjYXBbMF0udHJpbVJpZ2h0KClcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHQgPSBjYXBbMF0ucmVwbGFjZSgvXiB7MSw0fS9nbSwgJycpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdjb2RlJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICBjb2RlQmxvY2tTdHlsZTogJ2luZGVudGVkJyxcbiAgICAgICAgICB0ZXh0OiAhdGhpcy5vcHRpb25zLnBlZGFudGljID8gcnRyaW0kMSh0ZXh0LCAnXFxuJykgOiB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5mZW5jZXMgPSBmdW5jdGlvbiBmZW5jZXMoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5mZW5jZXMuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciByYXcgPSBjYXBbMF07XG4gICAgICAgIHZhciB0ZXh0ID0gaW5kZW50Q29kZUNvbXBlbnNhdGlvbihyYXcsIGNhcFszXSB8fCAnJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2NvZGUnLFxuICAgICAgICAgIHJhdzogcmF3LFxuICAgICAgICAgIGxhbmc6IGNhcFsyXSA/IGNhcFsyXS50cmltKCkgOiBjYXBbMl0sXG4gICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uaGVhZGluZyA9IGZ1bmN0aW9uIGhlYWRpbmcoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5oZWFkaW5nLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgdGV4dCA9IGNhcFsyXS50cmltKCk7IC8vIHJlbW92ZSB0cmFpbGluZyAjc1xuXG4gICAgICAgIGlmICgvIyQvLnRlc3QodGV4dCkpIHtcbiAgICAgICAgICB2YXIgdHJpbW1lZCA9IHJ0cmltJDEodGV4dCwgJyMnKTtcblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAgIHRleHQgPSB0cmltbWVkLnRyaW0oKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0cmltbWVkIHx8IC8gJC8udGVzdCh0cmltbWVkKSkge1xuICAgICAgICAgICAgLy8gQ29tbW9uTWFyayByZXF1aXJlcyBzcGFjZSBiZWZvcmUgdHJhaWxpbmcgI3NcbiAgICAgICAgICAgIHRleHQgPSB0cmltbWVkLnRyaW0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICBkZXB0aDogY2FwWzFdLmxlbmd0aCxcbiAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5ucHRhYmxlID0gZnVuY3Rpb24gbnB0YWJsZShzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLm5wdGFibGUuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciBpdGVtID0ge1xuICAgICAgICAgIHR5cGU6ICd0YWJsZScsXG4gICAgICAgICAgaGVhZGVyOiBzcGxpdENlbGxzJDEoY2FwWzFdLnJlcGxhY2UoL14gKnwgKlxcfCAqJC9nLCAnJykpLFxuICAgICAgICAgIGFsaWduOiBjYXBbMl0ucmVwbGFjZSgvXiAqfFxcfCAqJC9nLCAnJykuc3BsaXQoLyAqXFx8ICovKSxcbiAgICAgICAgICBjZWxsczogY2FwWzNdID8gY2FwWzNdLnJlcGxhY2UoL1xcbiQvLCAnJykuc3BsaXQoJ1xcbicpIDogW10sXG4gICAgICAgICAgcmF3OiBjYXBbMF1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoaXRlbS5oZWFkZXIubGVuZ3RoID09PSBpdGVtLmFsaWduLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBsID0gaXRlbS5hbGlnbi5sZW5ndGg7XG4gICAgICAgICAgdmFyIGk7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoL14gKi0rOiAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ3JpZ2h0JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL14gKjotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdjZW50ZXInO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgvXiAqOi0rICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnbGVmdCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsID0gaXRlbS5jZWxscy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpdGVtLmNlbGxzW2ldID0gc3BsaXRDZWxscyQxKGl0ZW0uY2VsbHNbaV0sIGl0ZW0uaGVhZGVyLmxlbmd0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmhyID0gZnVuY3Rpb24gaHIoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5oci5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnaHInLFxuICAgICAgICAgIHJhdzogY2FwWzBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5ibG9ja3F1b3RlID0gZnVuY3Rpb24gYmxvY2txdW90ZShzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmJsb2NrcXVvdGUuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gY2FwWzBdLnJlcGxhY2UoL14gKj4gPy9nbSwgJycpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdibG9ja3F1b3RlJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5saXN0ID0gZnVuY3Rpb24gbGlzdChzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmxpc3QuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciByYXcgPSBjYXBbMF07XG4gICAgICAgIHZhciBidWxsID0gY2FwWzJdO1xuICAgICAgICB2YXIgaXNvcmRlcmVkID0gYnVsbC5sZW5ndGggPiAxO1xuICAgICAgICB2YXIgbGlzdCA9IHtcbiAgICAgICAgICB0eXBlOiAnbGlzdCcsXG4gICAgICAgICAgcmF3OiByYXcsXG4gICAgICAgICAgb3JkZXJlZDogaXNvcmRlcmVkLFxuICAgICAgICAgIHN0YXJ0OiBpc29yZGVyZWQgPyArYnVsbC5zbGljZSgwLCAtMSkgOiAnJyxcbiAgICAgICAgICBsb29zZTogZmFsc2UsXG4gICAgICAgICAgaXRlbXM6IFtdXG4gICAgICAgIH07IC8vIEdldCBlYWNoIHRvcC1sZXZlbCBpdGVtLlxuXG4gICAgICAgIHZhciBpdGVtTWF0Y2ggPSBjYXBbMF0ubWF0Y2godGhpcy5ydWxlcy5ibG9jay5pdGVtKTtcbiAgICAgICAgdmFyIG5leHQgPSBmYWxzZSxcbiAgICAgICAgICAgIGl0ZW0sXG4gICAgICAgICAgICBzcGFjZSxcbiAgICAgICAgICAgIGJjdXJyLFxuICAgICAgICAgICAgYm5leHQsXG4gICAgICAgICAgICBhZGRCYWNrLFxuICAgICAgICAgICAgbG9vc2UsXG4gICAgICAgICAgICBpc3Rhc2ssXG4gICAgICAgICAgICBpc2NoZWNrZWQ7XG4gICAgICAgIHZhciBsID0gaXRlbU1hdGNoLmxlbmd0aDtcbiAgICAgICAgYmN1cnIgPSB0aGlzLnJ1bGVzLmJsb2NrLmxpc3RJdGVtU3RhcnQuZXhlYyhpdGVtTWF0Y2hbMF0pO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaXRlbSA9IGl0ZW1NYXRjaFtpXTtcbiAgICAgICAgICByYXcgPSBpdGVtOyAvLyBEZXRlcm1pbmUgd2hldGhlciB0aGUgbmV4dCBsaXN0IGl0ZW0gYmVsb25ncyBoZXJlLlxuICAgICAgICAgIC8vIEJhY2twZWRhbCBpZiBpdCBkb2VzIG5vdCBiZWxvbmcgaW4gdGhpcyBsaXN0LlxuXG4gICAgICAgICAgaWYgKGkgIT09IGwgLSAxKSB7XG4gICAgICAgICAgICBibmV4dCA9IHRoaXMucnVsZXMuYmxvY2subGlzdEl0ZW1TdGFydC5leGVjKGl0ZW1NYXRjaFtpICsgMV0pO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5wZWRhbnRpYyA/IGJuZXh0WzFdLmxlbmd0aCA+IGJjdXJyWzBdLmxlbmd0aCB8fCBibmV4dFsxXS5sZW5ndGggPiAzIDogYm5leHRbMV0ubGVuZ3RoID4gYmN1cnJbMV0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIC8vIG5lc3RlZCBsaXN0XG4gICAgICAgICAgICAgIGl0ZW1NYXRjaC5zcGxpY2UoaSwgMiwgaXRlbU1hdGNoW2ldICsgJ1xcbicgKyBpdGVtTWF0Y2hbaSArIDFdKTtcbiAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICBsLS07XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCAvLyBkaWZmZXJlbnQgYnVsbGV0IHN0eWxlXG4gICAgICAgICAgICAgICF0aGlzLm9wdGlvbnMucGVkYW50aWMgfHwgdGhpcy5vcHRpb25zLnNtYXJ0TGlzdHMgPyBibmV4dFsyXVtibmV4dFsyXS5sZW5ndGggLSAxXSAhPT0gYnVsbFtidWxsLmxlbmd0aCAtIDFdIDogaXNvcmRlcmVkID09PSAoYm5leHRbMl0ubGVuZ3RoID09PSAxKSkge1xuICAgICAgICAgICAgICAgIGFkZEJhY2sgPSBpdGVtTWF0Y2guc2xpY2UoaSArIDEpLmpvaW4oJ1xcbicpO1xuICAgICAgICAgICAgICAgIGxpc3QucmF3ID0gbGlzdC5yYXcuc3Vic3RyaW5nKDAsIGxpc3QucmF3Lmxlbmd0aCAtIGFkZEJhY2subGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpID0gbCAtIDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYmN1cnIgPSBibmV4dDtcbiAgICAgICAgICB9IC8vIFJlbW92ZSB0aGUgbGlzdCBpdGVtJ3MgYnVsbGV0XG4gICAgICAgICAgLy8gc28gaXQgaXMgc2VlbiBhcyB0aGUgbmV4dCB0b2tlbi5cblxuXG4gICAgICAgICAgc3BhY2UgPSBpdGVtLmxlbmd0aDtcbiAgICAgICAgICBpdGVtID0gaXRlbS5yZXBsYWNlKC9eICooWyorLV18XFxkK1suKV0pID8vLCAnJyk7IC8vIE91dGRlbnQgd2hhdGV2ZXIgdGhlXG4gICAgICAgICAgLy8gbGlzdCBpdGVtIGNvbnRhaW5zLiBIYWNreS5cblxuICAgICAgICAgIGlmICh+aXRlbS5pbmRleE9mKCdcXG4gJykpIHtcbiAgICAgICAgICAgIHNwYWNlIC09IGl0ZW0ubGVuZ3RoO1xuICAgICAgICAgICAgaXRlbSA9ICF0aGlzLm9wdGlvbnMucGVkYW50aWMgPyBpdGVtLnJlcGxhY2UobmV3IFJlZ0V4cCgnXiB7MSwnICsgc3BhY2UgKyAnfScsICdnbScpLCAnJykgOiBpdGVtLnJlcGxhY2UoL14gezEsNH0vZ20sICcnKTtcbiAgICAgICAgICB9IC8vIERldGVybWluZSB3aGV0aGVyIGl0ZW0gaXMgbG9vc2Ugb3Igbm90LlxuICAgICAgICAgIC8vIFVzZTogLyhefFxcbikoPyEgKVteXFxuXStcXG5cXG4oPyFcXHMqJCkvXG4gICAgICAgICAgLy8gZm9yIGRpc2NvdW50IGJlaGF2aW9yLlxuXG5cbiAgICAgICAgICBsb29zZSA9IG5leHQgfHwgL1xcblxcbig/IVxccyokKS8udGVzdChpdGVtKTtcblxuICAgICAgICAgIGlmIChpICE9PSBsIC0gMSkge1xuICAgICAgICAgICAgbmV4dCA9IGl0ZW0uY2hhckF0KGl0ZW0ubGVuZ3RoIC0gMSkgPT09ICdcXG4nO1xuICAgICAgICAgICAgaWYgKCFsb29zZSkgbG9vc2UgPSBuZXh0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsb29zZSkge1xuICAgICAgICAgICAgbGlzdC5sb29zZSA9IHRydWU7XG4gICAgICAgICAgfSAvLyBDaGVjayBmb3IgdGFzayBsaXN0IGl0ZW1zXG5cblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgICAgICAgICBpc3Rhc2sgPSAvXlxcW1sgeFhdXFxdIC8udGVzdChpdGVtKTtcbiAgICAgICAgICAgIGlzY2hlY2tlZCA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgICAgaWYgKGlzdGFzaykge1xuICAgICAgICAgICAgICBpc2NoZWNrZWQgPSBpdGVtWzFdICE9PSAnICc7XG4gICAgICAgICAgICAgIGl0ZW0gPSBpdGVtLnJlcGxhY2UoL15cXFtbIHhYXVxcXSArLywgJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3QuaXRlbXMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnbGlzdF9pdGVtJyxcbiAgICAgICAgICAgIHJhdzogcmF3LFxuICAgICAgICAgICAgdGFzazogaXN0YXNrLFxuICAgICAgICAgICAgY2hlY2tlZDogaXNjaGVja2VkLFxuICAgICAgICAgICAgbG9vc2U6IGxvb3NlLFxuICAgICAgICAgICAgdGV4dDogaXRlbVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5odG1sID0gZnVuY3Rpb24gaHRtbChzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmh0bWwuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogdGhpcy5vcHRpb25zLnNhbml0aXplID8gJ3BhcmFncmFwaCcgOiAnaHRtbCcsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgcHJlOiAhdGhpcy5vcHRpb25zLnNhbml0aXplciAmJiAoY2FwWzFdID09PSAncHJlJyB8fCBjYXBbMV0gPT09ICdzY3JpcHQnIHx8IGNhcFsxXSA9PT0gJ3N0eWxlJyksXG4gICAgICAgICAgdGV4dDogdGhpcy5vcHRpb25zLnNhbml0aXplID8gdGhpcy5vcHRpb25zLnNhbml0aXplciA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIoY2FwWzBdKSA6IF9lc2NhcGUoY2FwWzBdKSA6IGNhcFswXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uZGVmID0gZnVuY3Rpb24gZGVmKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuYmxvY2suZGVmLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICBpZiAoY2FwWzNdKSBjYXBbM10gPSBjYXBbM10uc3Vic3RyaW5nKDEsIGNhcFszXS5sZW5ndGggLSAxKTtcbiAgICAgICAgdmFyIHRhZyA9IGNhcFsxXS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xccysvZywgJyAnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0YWc6IHRhZyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICBocmVmOiBjYXBbMl0sXG4gICAgICAgICAgdGl0bGU6IGNhcFszXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8udGFibGUgPSBmdW5jdGlvbiB0YWJsZShzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLnRhYmxlLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgaXRlbSA9IHtcbiAgICAgICAgICB0eXBlOiAndGFibGUnLFxuICAgICAgICAgIGhlYWRlcjogc3BsaXRDZWxscyQxKGNhcFsxXS5yZXBsYWNlKC9eICp8ICpcXHwgKiQvZywgJycpKSxcbiAgICAgICAgICBhbGlnbjogY2FwWzJdLnJlcGxhY2UoL14gKnxcXHwgKiQvZywgJycpLnNwbGl0KC8gKlxcfCAqLyksXG4gICAgICAgICAgY2VsbHM6IGNhcFszXSA/IGNhcFszXS5yZXBsYWNlKC9cXG4kLywgJycpLnNwbGl0KCdcXG4nKSA6IFtdXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGl0ZW0uaGVhZGVyLmxlbmd0aCA9PT0gaXRlbS5hbGlnbi5sZW5ndGgpIHtcbiAgICAgICAgICBpdGVtLnJhdyA9IGNhcFswXTtcbiAgICAgICAgICB2YXIgbCA9IGl0ZW0uYWxpZ24ubGVuZ3RoO1xuICAgICAgICAgIHZhciBpO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKC9eICotKzogKiQvLnRlc3QoaXRlbS5hbGlnbltpXSkpIHtcbiAgICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9ICdyaWdodCc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKC9eICo6LSs6ICokLy50ZXN0KGl0ZW0uYWxpZ25baV0pKSB7XG4gICAgICAgICAgICAgIGl0ZW0uYWxpZ25baV0gPSAnY2VudGVyJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoL14gKjotKyAqJC8udGVzdChpdGVtLmFsaWduW2ldKSkge1xuICAgICAgICAgICAgICBpdGVtLmFsaWduW2ldID0gJ2xlZnQnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXRlbS5hbGlnbltpXSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbCA9IGl0ZW0uY2VsbHMubGVuZ3RoO1xuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaXRlbS5jZWxsc1tpXSA9IHNwbGl0Q2VsbHMkMShpdGVtLmNlbGxzW2ldLnJlcGxhY2UoL14gKlxcfCAqfCAqXFx8ICokL2csICcnKSwgaXRlbS5oZWFkZXIubGVuZ3RoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8ubGhlYWRpbmcgPSBmdW5jdGlvbiBsaGVhZGluZyhzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLmxoZWFkaW5nLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICdoZWFkaW5nJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICBkZXB0aDogY2FwWzJdLmNoYXJBdCgwKSA9PT0gJz0nID8gMSA6IDIsXG4gICAgICAgICAgdGV4dDogY2FwWzFdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5wYXJhZ3JhcGggPSBmdW5jdGlvbiBwYXJhZ3JhcGgoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5ibG9jay5wYXJhZ3JhcGguZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ3BhcmFncmFwaCcsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogY2FwWzFdLmNoYXJBdChjYXBbMV0ubGVuZ3RoIC0gMSkgPT09ICdcXG4nID8gY2FwWzFdLnNsaWNlKDAsIC0xKSA6IGNhcFsxXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8udGV4dCA9IGZ1bmN0aW9uIHRleHQoc3JjLCB0b2tlbnMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmJsb2NrLnRleHQuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciBsYXN0VG9rZW4gPSB0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGlmIChsYXN0VG9rZW4gJiYgbGFzdFRva2VuLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICAgIHRleHQ6IGNhcFswXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICB0ZXh0OiBjYXBbMF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmVzY2FwZSA9IGZ1bmN0aW9uIGVzY2FwZShzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5lc2NhcGUuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2VzY2FwZScsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogX2VzY2FwZShjYXBbMV0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by50YWcgPSBmdW5jdGlvbiB0YWcoc3JjLCBpbkxpbmssIGluUmF3QmxvY2spIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS50YWcuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIGlmICghaW5MaW5rICYmIC9ePGEgL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgaW5MaW5rID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChpbkxpbmsgJiYgL148XFwvYT4vaS50ZXN0KGNhcFswXSkpIHtcbiAgICAgICAgICBpbkxpbmsgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaW5SYXdCbG9jayAmJiAvXjwocHJlfGNvZGV8a2JkfHNjcmlwdCkoXFxzfD4pL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgaW5SYXdCbG9jayA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5SYXdCbG9jayAmJiAvXjxcXC8ocHJlfGNvZGV8a2JkfHNjcmlwdCkoXFxzfD4pL2kudGVzdChjYXBbMF0pKSB7XG4gICAgICAgICAgaW5SYXdCbG9jayA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiB0aGlzLm9wdGlvbnMuc2FuaXRpemUgPyAndGV4dCcgOiAnaHRtbCcsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgaW5MaW5rOiBpbkxpbmssXG4gICAgICAgICAgaW5SYXdCbG9jazogaW5SYXdCbG9jayxcbiAgICAgICAgICB0ZXh0OiB0aGlzLm9wdGlvbnMuc2FuaXRpemUgPyB0aGlzLm9wdGlvbnMuc2FuaXRpemVyID8gdGhpcy5vcHRpb25zLnNhbml0aXplcihjYXBbMF0pIDogX2VzY2FwZShjYXBbMF0pIDogY2FwWzBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5saW5rID0gZnVuY3Rpb24gbGluayhzcmMpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5saW5rLmV4ZWMoc3JjKTtcblxuICAgICAgaWYgKGNhcCkge1xuICAgICAgICB2YXIgdHJpbW1lZFVybCA9IGNhcFsyXS50cmltKCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucGVkYW50aWMgJiYgL148Ly50ZXN0KHRyaW1tZWRVcmwpKSB7XG4gICAgICAgICAgLy8gY29tbW9ubWFyayByZXF1aXJlcyBtYXRjaGluZyBhbmdsZSBicmFja2V0c1xuICAgICAgICAgIGlmICghLz4kLy50ZXN0KHRyaW1tZWRVcmwpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSAvLyBlbmRpbmcgYW5nbGUgYnJhY2tldCBjYW5ub3QgYmUgZXNjYXBlZFxuXG5cbiAgICAgICAgICB2YXIgcnRyaW1TbGFzaCA9IHJ0cmltJDEodHJpbW1lZFVybC5zbGljZSgwLCAtMSksICdcXFxcJyk7XG5cbiAgICAgICAgICBpZiAoKHRyaW1tZWRVcmwubGVuZ3RoIC0gcnRyaW1TbGFzaC5sZW5ndGgpICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmaW5kIGNsb3NpbmcgcGFyZW50aGVzaXNcbiAgICAgICAgICB2YXIgbGFzdFBhcmVuSW5kZXggPSBmaW5kQ2xvc2luZ0JyYWNrZXQkMShjYXBbMl0sICcoKScpO1xuXG4gICAgICAgICAgaWYgKGxhc3RQYXJlbkluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGNhcFswXS5pbmRleE9mKCchJykgPT09IDAgPyA1IDogNDtcbiAgICAgICAgICAgIHZhciBsaW5rTGVuID0gc3RhcnQgKyBjYXBbMV0ubGVuZ3RoICsgbGFzdFBhcmVuSW5kZXg7XG4gICAgICAgICAgICBjYXBbMl0gPSBjYXBbMl0uc3Vic3RyaW5nKDAsIGxhc3RQYXJlbkluZGV4KTtcbiAgICAgICAgICAgIGNhcFswXSA9IGNhcFswXS5zdWJzdHJpbmcoMCwgbGlua0xlbikudHJpbSgpO1xuICAgICAgICAgICAgY2FwWzNdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhyZWYgPSBjYXBbMl07XG4gICAgICAgIHZhciB0aXRsZSA9ICcnO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucGVkYW50aWMpIHtcbiAgICAgICAgICAvLyBzcGxpdCBwZWRhbnRpYyBocmVmIGFuZCB0aXRsZVxuICAgICAgICAgIHZhciBsaW5rID0gL14oW14nXCJdKlteXFxzXSlcXHMrKFsnXCJdKSguKilcXDIvLmV4ZWMoaHJlZik7XG5cbiAgICAgICAgICBpZiAobGluaykge1xuICAgICAgICAgICAgaHJlZiA9IGxpbmtbMV07XG4gICAgICAgICAgICB0aXRsZSA9IGxpbmtbM107XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpdGxlID0gY2FwWzNdID8gY2FwWzNdLnNsaWNlKDEsIC0xKSA6ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaHJlZiA9IGhyZWYudHJpbSgpO1xuXG4gICAgICAgIGlmICgvXjwvLnRlc3QoaHJlZikpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljICYmICEvPiQvLnRlc3QodHJpbW1lZFVybCkpIHtcbiAgICAgICAgICAgIC8vIHBlZGFudGljIGFsbG93cyBzdGFydGluZyBhbmdsZSBicmFja2V0IHdpdGhvdXQgZW5kaW5nIGFuZ2xlIGJyYWNrZXRcbiAgICAgICAgICAgIGhyZWYgPSBocmVmLnNsaWNlKDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBocmVmID0gaHJlZi5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG91dHB1dExpbmsoY2FwLCB7XG4gICAgICAgICAgaHJlZjogaHJlZiA/IGhyZWYucmVwbGFjZSh0aGlzLnJ1bGVzLmlubGluZS5fZXNjYXBlcywgJyQxJykgOiBocmVmLFxuICAgICAgICAgIHRpdGxlOiB0aXRsZSA/IHRpdGxlLnJlcGxhY2UodGhpcy5ydWxlcy5pbmxpbmUuX2VzY2FwZXMsICckMScpIDogdGl0bGVcbiAgICAgICAgfSwgY2FwWzBdKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLnJlZmxpbmsgPSBmdW5jdGlvbiByZWZsaW5rKHNyYywgbGlua3MpIHtcbiAgICAgIHZhciBjYXA7XG5cbiAgICAgIGlmICgoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUucmVmbGluay5leGVjKHNyYykpIHx8IChjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5ub2xpbmsuZXhlYyhzcmMpKSkge1xuICAgICAgICB2YXIgbGluayA9IChjYXBbMl0gfHwgY2FwWzFdKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgICAgIGxpbmsgPSBsaW5rc1tsaW5rLnRvTG93ZXJDYXNlKCldO1xuXG4gICAgICAgIGlmICghbGluayB8fCAhbGluay5ocmVmKSB7XG4gICAgICAgICAgdmFyIHRleHQgPSBjYXBbMF0uY2hhckF0KDApO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICByYXc6IHRleHQsXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvdXRwdXRMaW5rKGNhcCwgbGluaywgY2FwWzBdKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLnN0cm9uZyA9IGZ1bmN0aW9uIHN0cm9uZyhzcmMsIG1hc2tlZFNyYywgcHJldkNoYXIpIHtcbiAgICAgIGlmIChwcmV2Q2hhciA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHByZXZDaGFyID0gJyc7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXRjaCA9IHRoaXMucnVsZXMuaW5saW5lLnN0cm9uZy5zdGFydC5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChtYXRjaCAmJiAoIW1hdGNoWzFdIHx8IG1hdGNoWzFdICYmIChwcmV2Q2hhciA9PT0gJycgfHwgdGhpcy5ydWxlcy5pbmxpbmUucHVuY3R1YXRpb24uZXhlYyhwcmV2Q2hhcikpKSkge1xuICAgICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoLTEgKiBzcmMubGVuZ3RoKTtcbiAgICAgICAgdmFyIGVuZFJlZyA9IG1hdGNoWzBdID09PSAnKionID8gdGhpcy5ydWxlcy5pbmxpbmUuc3Ryb25nLmVuZEFzdCA6IHRoaXMucnVsZXMuaW5saW5lLnN0cm9uZy5lbmRVbmQ7XG4gICAgICAgIGVuZFJlZy5sYXN0SW5kZXggPSAwO1xuICAgICAgICB2YXIgY2FwO1xuXG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSBlbmRSZWcuZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuc3Ryb25nLm1pZGRsZS5leGVjKG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCArIDMpKTtcblxuICAgICAgICAgIGlmIChjYXApIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdzdHJvbmcnLFxuICAgICAgICAgICAgICByYXc6IHNyYy5zbGljZSgwLCBjYXBbMF0ubGVuZ3RoKSxcbiAgICAgICAgICAgICAgdGV4dDogc3JjLnNsaWNlKDIsIGNhcFswXS5sZW5ndGggLSAyKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmVtID0gZnVuY3Rpb24gZW0oc3JjLCBtYXNrZWRTcmMsIHByZXZDaGFyKSB7XG4gICAgICBpZiAocHJldkNoYXIgPT09IHZvaWQgMCkge1xuICAgICAgICBwcmV2Q2hhciA9ICcnO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF0Y2ggPSB0aGlzLnJ1bGVzLmlubGluZS5lbS5zdGFydC5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChtYXRjaCAmJiAoIW1hdGNoWzFdIHx8IG1hdGNoWzFdICYmIChwcmV2Q2hhciA9PT0gJycgfHwgdGhpcy5ydWxlcy5pbmxpbmUucHVuY3R1YXRpb24uZXhlYyhwcmV2Q2hhcikpKSkge1xuICAgICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoLTEgKiBzcmMubGVuZ3RoKTtcbiAgICAgICAgdmFyIGVuZFJlZyA9IG1hdGNoWzBdID09PSAnKicgPyB0aGlzLnJ1bGVzLmlubGluZS5lbS5lbmRBc3QgOiB0aGlzLnJ1bGVzLmlubGluZS5lbS5lbmRVbmQ7XG4gICAgICAgIGVuZFJlZy5sYXN0SW5kZXggPSAwO1xuICAgICAgICB2YXIgY2FwO1xuXG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSBlbmRSZWcuZXhlYyhtYXNrZWRTcmMpKSAhPSBudWxsKSB7XG4gICAgICAgICAgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuZW0ubWlkZGxlLmV4ZWMobWFza2VkU3JjLnNsaWNlKDAsIG1hdGNoLmluZGV4ICsgMikpO1xuXG4gICAgICAgICAgaWYgKGNhcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogJ2VtJyxcbiAgICAgICAgICAgICAgcmF3OiBzcmMuc2xpY2UoMCwgY2FwWzBdLmxlbmd0aCksXG4gICAgICAgICAgICAgIHRleHQ6IHNyYy5zbGljZSgxLCBjYXBbMF0ubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5jb2Rlc3BhbiA9IGZ1bmN0aW9uIGNvZGVzcGFuKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmNvZGUuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gY2FwWzJdLnJlcGxhY2UoL1xcbi9nLCAnICcpO1xuICAgICAgICB2YXIgaGFzTm9uU3BhY2VDaGFycyA9IC9bXiBdLy50ZXN0KHRleHQpO1xuICAgICAgICB2YXIgaGFzU3BhY2VDaGFyc09uQm90aEVuZHMgPSAvXiAvLnRlc3QodGV4dCkgJiYgLyAkLy50ZXN0KHRleHQpO1xuXG4gICAgICAgIGlmIChoYXNOb25TcGFjZUNoYXJzICYmIGhhc1NwYWNlQ2hhcnNPbkJvdGhFbmRzKSB7XG4gICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDEsIHRleHQubGVuZ3RoIC0gMSk7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0ID0gX2VzY2FwZSh0ZXh0LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnY29kZXNwYW4nLFxuICAgICAgICAgIHJhdzogY2FwWzBdLFxuICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmJyID0gZnVuY3Rpb24gYnIoc3JjKSB7XG4gICAgICB2YXIgY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUuYnIuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogJ2JyJyxcbiAgICAgICAgICByYXc6IGNhcFswXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uZGVsID0gZnVuY3Rpb24gZGVsKHNyYykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLmRlbC5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnZGVsJyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICB0ZXh0OiBjYXBbMl1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLmF1dG9saW5rID0gZnVuY3Rpb24gYXV0b2xpbmsoc3JjLCBtYW5nbGUpIHtcbiAgICAgIHZhciBjYXAgPSB0aGlzLnJ1bGVzLmlubGluZS5hdXRvbGluay5leGVjKHNyYyk7XG5cbiAgICAgIGlmIChjYXApIHtcbiAgICAgICAgdmFyIHRleHQsIGhyZWY7XG5cbiAgICAgICAgaWYgKGNhcFsyXSA9PT0gJ0AnKSB7XG4gICAgICAgICAgdGV4dCA9IF9lc2NhcGUodGhpcy5vcHRpb25zLm1hbmdsZSA/IG1hbmdsZShjYXBbMV0pIDogY2FwWzFdKTtcbiAgICAgICAgICBocmVmID0gJ21haWx0bzonICsgdGV4dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0ID0gX2VzY2FwZShjYXBbMV0pO1xuICAgICAgICAgIGhyZWYgPSB0ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgIHRva2VuczogW3tcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8udXJsID0gZnVuY3Rpb24gdXJsKHNyYywgbWFuZ2xlKSB7XG4gICAgICB2YXIgY2FwO1xuXG4gICAgICBpZiAoY2FwID0gdGhpcy5ydWxlcy5pbmxpbmUudXJsLmV4ZWMoc3JjKSkge1xuICAgICAgICB2YXIgdGV4dCwgaHJlZjtcblxuICAgICAgICBpZiAoY2FwWzJdID09PSAnQCcpIHtcbiAgICAgICAgICB0ZXh0ID0gX2VzY2FwZSh0aGlzLm9wdGlvbnMubWFuZ2xlID8gbWFuZ2xlKGNhcFswXSkgOiBjYXBbMF0pO1xuICAgICAgICAgIGhyZWYgPSAnbWFpbHRvOicgKyB0ZXh0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGRvIGV4dGVuZGVkIGF1dG9saW5rIHBhdGggdmFsaWRhdGlvblxuICAgICAgICAgIHZhciBwcmV2Q2FwWmVybztcblxuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIHByZXZDYXBaZXJvID0gY2FwWzBdO1xuICAgICAgICAgICAgY2FwWzBdID0gdGhpcy5ydWxlcy5pbmxpbmUuX2JhY2twZWRhbC5leGVjKGNhcFswXSlbMF07XG4gICAgICAgICAgfSB3aGlsZSAocHJldkNhcFplcm8gIT09IGNhcFswXSk7XG5cbiAgICAgICAgICB0ZXh0ID0gX2VzY2FwZShjYXBbMF0pO1xuXG4gICAgICAgICAgaWYgKGNhcFsxXSA9PT0gJ3d3dy4nKSB7XG4gICAgICAgICAgICBocmVmID0gJ2h0dHA6Ly8nICsgdGV4dDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaHJlZiA9IHRleHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0eXBlOiAnbGluaycsXG4gICAgICAgICAgcmF3OiBjYXBbMF0sXG4gICAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgICBocmVmOiBocmVmLFxuICAgICAgICAgIHRva2VuczogW3tcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIHJhdzogdGV4dCxcbiAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICB9XVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uaW5saW5lVGV4dCA9IGZ1bmN0aW9uIGlubGluZVRleHQoc3JjLCBpblJhd0Jsb2NrLCBzbWFydHlwYW50cykge1xuICAgICAgdmFyIGNhcCA9IHRoaXMucnVsZXMuaW5saW5lLnRleHQuZXhlYyhzcmMpO1xuXG4gICAgICBpZiAoY2FwKSB7XG4gICAgICAgIHZhciB0ZXh0O1xuXG4gICAgICAgIGlmIChpblJhd0Jsb2NrKSB7XG4gICAgICAgICAgdGV4dCA9IHRoaXMub3B0aW9ucy5zYW5pdGl6ZSA/IHRoaXMub3B0aW9ucy5zYW5pdGl6ZXIgPyB0aGlzLm9wdGlvbnMuc2FuaXRpemVyKGNhcFswXSkgOiBfZXNjYXBlKGNhcFswXSkgOiBjYXBbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dCA9IF9lc2NhcGUodGhpcy5vcHRpb25zLnNtYXJ0eXBhbnRzID8gc21hcnR5cGFudHMoY2FwWzBdKSA6IGNhcFswXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICByYXc6IGNhcFswXSxcbiAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBUb2tlbml6ZXI7XG4gIH0oKTtcblxuICB2YXIgbm9vcFRlc3QkMSA9IGhlbHBlcnMubm9vcFRlc3QsXG4gICAgICBlZGl0JDEgPSBoZWxwZXJzLmVkaXQsXG4gICAgICBtZXJnZSQxID0gaGVscGVycy5tZXJnZTtcbiAgLyoqXG4gICAqIEJsb2NrLUxldmVsIEdyYW1tYXJcbiAgICovXG5cbiAgdmFyIGJsb2NrID0ge1xuICAgIG5ld2xpbmU6IC9eKD86ICooPzpcXG58JCkpKy8sXG4gICAgY29kZTogL14oIHs0fVteXFxuXSsoPzpcXG4oPzogKig/OlxcbnwkKSkqKT8pKy8sXG4gICAgZmVuY2VzOiAvXiB7MCwzfShgezMsfSg/PVteYFxcbl0qXFxuKXx+ezMsfSkoW15cXG5dKilcXG4oPzp8KFtcXHNcXFNdKj8pXFxuKSg/OiB7MCwzfVxcMVt+YF0qICooPzpcXG4rfCQpfCQpLyxcbiAgICBocjogL14gezAsM30oKD86LSAqKXszLH18KD86XyAqKXszLH18KD86XFwqICopezMsfSkoPzpcXG4rfCQpLyxcbiAgICBoZWFkaW5nOiAvXiB7MCwzfSgjezEsNn0pKD89XFxzfCQpKC4qKSg/Olxcbit8JCkvLFxuICAgIGJsb2NrcXVvdGU6IC9eKCB7MCwzfT4gPyhwYXJhZ3JhcGh8W15cXG5dKikoPzpcXG58JCkpKy8sXG4gICAgbGlzdDogL14oIHswLDN9KShidWxsKSBbXFxzXFxTXSs/KD86aHJ8ZGVmfFxcbnsyLH0oPyEgKSg/ISB7MCwzfWJ1bGwgKVxcbip8XFxzKiQpLyxcbiAgICBodG1sOiAnXiB7MCwzfSg/OicgLy8gb3B0aW9uYWwgaW5kZW50YXRpb25cbiAgICArICc8KHNjcmlwdHxwcmV8c3R5bGUpW1xcXFxzPl1bXFxcXHNcXFxcU10qPyg/OjwvXFxcXDE+W15cXFxcbl0qXFxcXG4rfCQpJyAvLyAoMSlcbiAgICArICd8Y29tbWVudFteXFxcXG5dKihcXFxcbit8JCknIC8vICgyKVxuICAgICsgJ3w8XFxcXD9bXFxcXHNcXFxcU10qPyg/OlxcXFw/PlxcXFxuKnwkKScgLy8gKDMpXG4gICAgKyAnfDwhW0EtWl1bXFxcXHNcXFxcU10qPyg/Oj5cXFxcbip8JCknIC8vICg0KVxuICAgICsgJ3w8IVxcXFxbQ0RBVEFcXFxcW1tcXFxcc1xcXFxTXSo/KD86XFxcXF1cXFxcXT5cXFxcbip8JCknIC8vICg1KVxuICAgICsgJ3w8Lz8odGFnKSg/OiArfFxcXFxufC8/PilbXFxcXHNcXFxcU10qPyg/OlxcXFxuezIsfXwkKScgLy8gKDYpXG4gICAgKyAnfDwoPyFzY3JpcHR8cHJlfHN0eWxlKShbYS16XVtcXFxcdy1dKikoPzphdHRyaWJ1dGUpKj8gKi8/Pig/PVsgXFxcXHRdKig/OlxcXFxufCQpKVtcXFxcc1xcXFxTXSo/KD86XFxcXG57Mix9fCQpJyAvLyAoNykgb3BlbiB0YWdcbiAgICArICd8PC8oPyFzY3JpcHR8cHJlfHN0eWxlKVthLXpdW1xcXFx3LV0qXFxcXHMqPig/PVsgXFxcXHRdKig/OlxcXFxufCQpKVtcXFxcc1xcXFxTXSo/KD86XFxcXG57Mix9fCQpJyAvLyAoNykgY2xvc2luZyB0YWdcbiAgICArICcpJyxcbiAgICBkZWY6IC9eIHswLDN9XFxbKGxhYmVsKVxcXTogKlxcbj8gKjw/KFteXFxzPl0rKT4/KD86KD86ICtcXG4/ICp8ICpcXG4gKikodGl0bGUpKT8gKig/Olxcbit8JCkvLFxuICAgIG5wdGFibGU6IG5vb3BUZXN0JDEsXG4gICAgdGFibGU6IG5vb3BUZXN0JDEsXG4gICAgbGhlYWRpbmc6IC9eKFteXFxuXSspXFxuIHswLDN9KD0rfC0rKSAqKD86XFxuK3wkKS8sXG4gICAgLy8gcmVnZXggdGVtcGxhdGUsIHBsYWNlaG9sZGVycyB3aWxsIGJlIHJlcGxhY2VkIGFjY29yZGluZyB0byBkaWZmZXJlbnQgcGFyYWdyYXBoXG4gICAgLy8gaW50ZXJydXB0aW9uIHJ1bGVzIG9mIGNvbW1vbm1hcmsgYW5kIHRoZSBvcmlnaW5hbCBtYXJrZG93biBzcGVjOlxuICAgIF9wYXJhZ3JhcGg6IC9eKFteXFxuXSsoPzpcXG4oPyFocnxoZWFkaW5nfGxoZWFkaW5nfGJsb2NrcXVvdGV8ZmVuY2VzfGxpc3R8aHRtbHwgK1xcbilbXlxcbl0rKSopLyxcbiAgICB0ZXh0OiAvXlteXFxuXSsvXG4gIH07XG4gIGJsb2NrLl9sYWJlbCA9IC8oPyFcXHMqXFxdKSg/OlxcXFxbXFxbXFxdXXxbXlxcW1xcXV0pKy87XG4gIGJsb2NrLl90aXRsZSA9IC8oPzpcIig/OlxcXFxcIj98W15cIlxcXFxdKSpcInwnW14nXFxuXSooPzpcXG5bXidcXG5dKykqXFxuPyd8XFwoW14oKV0qXFwpKS87XG4gIGJsb2NrLmRlZiA9IGVkaXQkMShibG9jay5kZWYpLnJlcGxhY2UoJ2xhYmVsJywgYmxvY2suX2xhYmVsKS5yZXBsYWNlKCd0aXRsZScsIGJsb2NrLl90aXRsZSkuZ2V0UmVnZXgoKTtcbiAgYmxvY2suYnVsbGV0ID0gLyg/OlsqKy1dfFxcZHsxLDl9Wy4pXSkvO1xuICBibG9jay5pdGVtID0gL14oICopKGJ1bGwpID9bXlxcbl0qKD86XFxuKD8hICpidWxsID8pW15cXG5dKikqLztcbiAgYmxvY2suaXRlbSA9IGVkaXQkMShibG9jay5pdGVtLCAnZ20nKS5yZXBsYWNlKC9idWxsL2csIGJsb2NrLmJ1bGxldCkuZ2V0UmVnZXgoKTtcbiAgYmxvY2subGlzdEl0ZW1TdGFydCA9IGVkaXQkMSgvXiggKikoYnVsbCkvKS5yZXBsYWNlKCdidWxsJywgYmxvY2suYnVsbGV0KS5nZXRSZWdleCgpO1xuICBibG9jay5saXN0ID0gZWRpdCQxKGJsb2NrLmxpc3QpLnJlcGxhY2UoL2J1bGwvZywgYmxvY2suYnVsbGV0KS5yZXBsYWNlKCdocicsICdcXFxcbisoPz1cXFxcMT8oPzooPzotICopezMsfXwoPzpfICopezMsfXwoPzpcXFxcKiAqKXszLH0pKD86XFxcXG4rfCQpKScpLnJlcGxhY2UoJ2RlZicsICdcXFxcbisoPz0nICsgYmxvY2suZGVmLnNvdXJjZSArICcpJykuZ2V0UmVnZXgoKTtcbiAgYmxvY2suX3RhZyA9ICdhZGRyZXNzfGFydGljbGV8YXNpZGV8YmFzZXxiYXNlZm9udHxibG9ja3F1b3RlfGJvZHl8Y2FwdGlvbicgKyAnfGNlbnRlcnxjb2x8Y29sZ3JvdXB8ZGR8ZGV0YWlsc3xkaWFsb2d8ZGlyfGRpdnxkbHxkdHxmaWVsZHNldHxmaWdjYXB0aW9uJyArICd8ZmlndXJlfGZvb3Rlcnxmb3JtfGZyYW1lfGZyYW1lc2V0fGhbMS02XXxoZWFkfGhlYWRlcnxocnxodG1sfGlmcmFtZScgKyAnfGxlZ2VuZHxsaXxsaW5rfG1haW58bWVudXxtZW51aXRlbXxtZXRhfG5hdnxub2ZyYW1lc3xvbHxvcHRncm91cHxvcHRpb24nICsgJ3xwfHBhcmFtfHNlY3Rpb258c291cmNlfHN1bW1hcnl8dGFibGV8dGJvZHl8dGR8dGZvb3R8dGh8dGhlYWR8dGl0bGV8dHInICsgJ3x0cmFja3x1bCc7XG4gIGJsb2NrLl9jb21tZW50ID0gLzwhLS0oPyEtPz4pW1xcc1xcU10qPyg/Oi0tPnwkKS87XG4gIGJsb2NrLmh0bWwgPSBlZGl0JDEoYmxvY2suaHRtbCwgJ2knKS5yZXBsYWNlKCdjb21tZW50JywgYmxvY2suX2NvbW1lbnQpLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpLnJlcGxhY2UoJ2F0dHJpYnV0ZScsIC8gK1thLXpBLVo6X11bXFx3LjotXSooPzogKj0gKlwiW15cIlxcbl0qXCJ8ICo9IConW14nXFxuXSonfCAqPSAqW15cXHNcIic9PD5gXSspPy8pLmdldFJlZ2V4KCk7XG4gIGJsb2NrLnBhcmFncmFwaCA9IGVkaXQkMShibG9jay5fcGFyYWdyYXBoKS5yZXBsYWNlKCdocicsIGJsb2NrLmhyKS5yZXBsYWNlKCdoZWFkaW5nJywgJyB7MCwzfSN7MSw2fSAnKS5yZXBsYWNlKCd8bGhlYWRpbmcnLCAnJykgLy8gc2V0ZXggaGVhZGluZ3MgZG9uJ3QgaW50ZXJydXB0IGNvbW1vbm1hcmsgcGFyYWdyYXBoc1xuICAucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JykucmVwbGFjZSgnZmVuY2VzJywgJyB7MCwzfSg/OmB7Myx9KD89W15gXFxcXG5dKlxcXFxuKXx+ezMsfSlbXlxcXFxuXSpcXFxcbicpLnJlcGxhY2UoJ2xpc3QnLCAnIHswLDN9KD86WyorLV18MVsuKV0pICcpIC8vIG9ubHkgbGlzdHMgc3RhcnRpbmcgZnJvbSAxIGNhbiBpbnRlcnJ1cHRcbiAgLnJlcGxhY2UoJ2h0bWwnLCAnPC8/KD86dGFnKSg/OiArfFxcXFxufC8/Pil8PCg/OnNjcmlwdHxwcmV8c3R5bGV8IS0tKScpLnJlcGxhY2UoJ3RhZycsIGJsb2NrLl90YWcpIC8vIHBhcnMgY2FuIGJlIGludGVycnVwdGVkIGJ5IHR5cGUgKDYpIGh0bWwgYmxvY2tzXG4gIC5nZXRSZWdleCgpO1xuICBibG9jay5ibG9ja3F1b3RlID0gZWRpdCQxKGJsb2NrLmJsb2NrcXVvdGUpLnJlcGxhY2UoJ3BhcmFncmFwaCcsIGJsb2NrLnBhcmFncmFwaCkuZ2V0UmVnZXgoKTtcbiAgLyoqXG4gICAqIE5vcm1hbCBCbG9jayBHcmFtbWFyXG4gICAqL1xuXG4gIGJsb2NrLm5vcm1hbCA9IG1lcmdlJDEoe30sIGJsb2NrKTtcbiAgLyoqXG4gICAqIEdGTSBCbG9jayBHcmFtbWFyXG4gICAqL1xuXG4gIGJsb2NrLmdmbSA9IG1lcmdlJDEoe30sIGJsb2NrLm5vcm1hbCwge1xuICAgIG5wdGFibGU6ICdeICooW158XFxcXG4gXS4qXFxcXHwuKilcXFxcbicgLy8gSGVhZGVyXG4gICAgKyAnIHswLDN9KFstOl0rICpcXFxcfFstfCA6XSopJyAvLyBBbGlnblxuICAgICsgJyg/OlxcXFxuKCg/Oig/IVxcXFxufGhyfGhlYWRpbmd8YmxvY2txdW90ZXxjb2RlfGZlbmNlc3xsaXN0fGh0bWwpLiooPzpcXFxcbnwkKSkqKVxcXFxuKnwkKScsXG4gICAgLy8gQ2VsbHNcbiAgICB0YWJsZTogJ14gKlxcXFx8KC4rKVxcXFxuJyAvLyBIZWFkZXJcbiAgICArICcgezAsM31cXFxcfD8oICpbLTpdK1stfCA6XSopJyAvLyBBbGlnblxuICAgICsgJyg/OlxcXFxuICooKD86KD8hXFxcXG58aHJ8aGVhZGluZ3xibG9ja3F1b3RlfGNvZGV8ZmVuY2VzfGxpc3R8aHRtbCkuKig/OlxcXFxufCQpKSopXFxcXG4qfCQpJyAvLyBDZWxsc1xuXG4gIH0pO1xuICBibG9jay5nZm0ubnB0YWJsZSA9IGVkaXQkMShibG9jay5nZm0ubnB0YWJsZSkucmVwbGFjZSgnaHInLCBibG9jay5ocikucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0gJykucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JykucmVwbGFjZSgnY29kZScsICcgezR9W15cXFxcbl0nKS5yZXBsYWNlKCdmZW5jZXMnLCAnIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuJykucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuICAucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXwhLS0pJykucmVwbGFjZSgndGFnJywgYmxvY2suX3RhZykgLy8gdGFibGVzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAuZ2V0UmVnZXgoKTtcbiAgYmxvY2suZ2ZtLnRhYmxlID0gZWRpdCQxKGJsb2NrLmdmbS50YWJsZSkucmVwbGFjZSgnaHInLCBibG9jay5ocikucmVwbGFjZSgnaGVhZGluZycsICcgezAsM30jezEsNn0gJykucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JykucmVwbGFjZSgnY29kZScsICcgezR9W15cXFxcbl0nKS5yZXBsYWNlKCdmZW5jZXMnLCAnIHswLDN9KD86YHszLH0oPz1bXmBcXFxcbl0qXFxcXG4pfH57Myx9KVteXFxcXG5dKlxcXFxuJykucmVwbGFjZSgnbGlzdCcsICcgezAsM30oPzpbKistXXwxWy4pXSkgJykgLy8gb25seSBsaXN0cyBzdGFydGluZyBmcm9tIDEgY2FuIGludGVycnVwdFxuICAucmVwbGFjZSgnaHRtbCcsICc8Lz8oPzp0YWcpKD86ICt8XFxcXG58Lz8+KXw8KD86c2NyaXB0fHByZXxzdHlsZXwhLS0pJykucmVwbGFjZSgndGFnJywgYmxvY2suX3RhZykgLy8gdGFibGVzIGNhbiBiZSBpbnRlcnJ1cHRlZCBieSB0eXBlICg2KSBodG1sIGJsb2Nrc1xuICAuZ2V0UmVnZXgoKTtcbiAgLyoqXG4gICAqIFBlZGFudGljIGdyYW1tYXIgKG9yaWdpbmFsIEpvaG4gR3J1YmVyJ3MgbG9vc2UgbWFya2Rvd24gc3BlY2lmaWNhdGlvbilcbiAgICovXG5cbiAgYmxvY2sucGVkYW50aWMgPSBtZXJnZSQxKHt9LCBibG9jay5ub3JtYWwsIHtcbiAgICBodG1sOiBlZGl0JDEoJ14gKig/OmNvbW1lbnQgKig/OlxcXFxufFxcXFxzKiQpJyArICd8PCh0YWcpW1xcXFxzXFxcXFNdKz88L1xcXFwxPiAqKD86XFxcXG57Mix9fFxcXFxzKiQpJyAvLyBjbG9zZWQgdGFnXG4gICAgKyAnfDx0YWcoPzpcIlteXCJdKlwifFxcJ1teXFwnXSpcXCd8XFxcXHNbXlxcJ1wiLz5cXFxcc10qKSo/Lz8+ICooPzpcXFxcbnsyLH18XFxcXHMqJCkpJykucmVwbGFjZSgnY29tbWVudCcsIGJsb2NrLl9jb21tZW50KS5yZXBsYWNlKC90YWcvZywgJyg/ISg/OicgKyAnYXxlbXxzdHJvbmd8c21hbGx8c3xjaXRlfHF8ZGZufGFiYnJ8ZGF0YXx0aW1lfGNvZGV8dmFyfHNhbXB8a2JkfHN1YicgKyAnfHN1cHxpfGJ8dXxtYXJrfHJ1Ynl8cnR8cnB8YmRpfGJkb3xzcGFufGJyfHdicnxpbnN8ZGVsfGltZyknICsgJ1xcXFxiKVxcXFx3Kyg/ITp8W15cXFxcd1xcXFxzQF0qQClcXFxcYicpLmdldFJlZ2V4KCksXG4gICAgZGVmOiAvXiAqXFxbKFteXFxdXSspXFxdOiAqPD8oW15cXHM+XSspPj8oPzogKyhbXCIoXVteXFxuXStbXCIpXSkpPyAqKD86XFxuK3wkKS8sXG4gICAgaGVhZGluZzogL14oI3sxLDZ9KSguKikoPzpcXG4rfCQpLyxcbiAgICBmZW5jZXM6IG5vb3BUZXN0JDEsXG4gICAgLy8gZmVuY2VzIG5vdCBzdXBwb3J0ZWRcbiAgICBwYXJhZ3JhcGg6IGVkaXQkMShibG9jay5ub3JtYWwuX3BhcmFncmFwaCkucmVwbGFjZSgnaHInLCBibG9jay5ocikucmVwbGFjZSgnaGVhZGluZycsICcgKiN7MSw2fSAqW15cXG5dJykucmVwbGFjZSgnbGhlYWRpbmcnLCBibG9jay5saGVhZGluZykucmVwbGFjZSgnYmxvY2txdW90ZScsICcgezAsM30+JykucmVwbGFjZSgnfGZlbmNlcycsICcnKS5yZXBsYWNlKCd8bGlzdCcsICcnKS5yZXBsYWNlKCd8aHRtbCcsICcnKS5nZXRSZWdleCgpXG4gIH0pO1xuICAvKipcbiAgICogSW5saW5lLUxldmVsIEdyYW1tYXJcbiAgICovXG5cbiAgdmFyIGlubGluZSA9IHtcbiAgICBlc2NhcGU6IC9eXFxcXChbIVwiIyQlJicoKSorLFxcLS4vOjs8PT4/QFxcW1xcXVxcXFxeX2B7fH1+XSkvLFxuICAgIGF1dG9saW5rOiAvXjwoc2NoZW1lOlteXFxzXFx4MDAtXFx4MWY8Pl0qfGVtYWlsKT4vLFxuICAgIHVybDogbm9vcFRlc3QkMSxcbiAgICB0YWc6ICdeY29tbWVudCcgKyAnfF48L1thLXpBLVpdW1xcXFx3Oi1dKlxcXFxzKj4nIC8vIHNlbGYtY2xvc2luZyB0YWdcbiAgICArICd8XjxbYS16QS1aXVtcXFxcdy1dKig/OmF0dHJpYnV0ZSkqP1xcXFxzKi8/PicgLy8gb3BlbiB0YWdcbiAgICArICd8XjxcXFxcP1tcXFxcc1xcXFxTXSo/XFxcXD8+JyAvLyBwcm9jZXNzaW5nIGluc3RydWN0aW9uLCBlLmcuIDw/cGhwID8+XG4gICAgKyAnfF48IVthLXpBLVpdK1xcXFxzW1xcXFxzXFxcXFNdKj8+JyAvLyBkZWNsYXJhdGlvbiwgZS5nLiA8IURPQ1RZUEUgaHRtbD5cbiAgICArICd8XjwhXFxcXFtDREFUQVxcXFxbW1xcXFxzXFxcXFNdKj9cXFxcXVxcXFxdPicsXG4gICAgLy8gQ0RBVEEgc2VjdGlvblxuICAgIGxpbms6IC9eIT9cXFsobGFiZWwpXFxdXFwoXFxzKihocmVmKSg/OlxccysodGl0bGUpKT9cXHMqXFwpLyxcbiAgICByZWZsaW5rOiAvXiE/XFxbKGxhYmVsKVxcXVxcWyg/IVxccypcXF0pKCg/OlxcXFxbXFxbXFxdXT98W15cXFtcXF1cXFxcXSkrKVxcXS8sXG4gICAgbm9saW5rOiAvXiE/XFxbKD8hXFxzKlxcXSkoKD86XFxbW15cXFtcXF1dKlxcXXxcXFxcW1xcW1xcXV18W15cXFtcXF1dKSopXFxdKD86XFxbXFxdKT8vLFxuICAgIHJlZmxpbmtTZWFyY2g6ICdyZWZsaW5rfG5vbGluayg/IVxcXFwoKScsXG4gICAgc3Ryb25nOiB7XG4gICAgICBzdGFydDogL14oPzooXFwqXFwqKD89WypwdW5jdHVhdGlvbl0pKXxcXCpcXCopKD8hW1xcc10pfF9fLyxcbiAgICAgIC8vICgxKSByZXR1cm5zIGlmIHN0YXJ0cyB3LyBwdW5jdHVhdGlvblxuICAgICAgbWlkZGxlOiAvXlxcKlxcKig/Oig/Oig/IW92ZXJsYXBTa2lwKSg/OlteKl18XFxcXFxcKil8b3ZlcmxhcFNraXApfFxcKig/Oig/IW92ZXJsYXBTa2lwKSg/OlteKl18XFxcXFxcKil8b3ZlcmxhcFNraXApKj9cXCopKz9cXCpcXCokfF5fXyg/IVtcXHNdKSgoPzooPzooPyFvdmVybGFwU2tpcCkoPzpbXl9dfFxcXFxfKXxvdmVybGFwU2tpcCl8Xyg/Oig/IW92ZXJsYXBTa2lwKSg/OlteX118XFxcXF8pfG92ZXJsYXBTa2lwKSo/XykrPylfXyQvLFxuICAgICAgZW5kQXN0OiAvW15wdW5jdHVhdGlvblxcc11cXCpcXCooPyFcXCopfFtwdW5jdHVhdGlvbl1cXCpcXCooPyFcXCopKD86KD89W3B1bmN0dWF0aW9uX1xcc118JCkpLyxcbiAgICAgIC8vIGxhc3QgY2hhciBjYW4ndCBiZSBwdW5jdCwgb3IgZmluYWwgKiBtdXN0IGFsc28gYmUgZm9sbG93ZWQgYnkgcHVuY3QgKG9yIGVuZGxpbmUpXG4gICAgICBlbmRVbmQ6IC9bXlxcc11fXyg/IV8pKD86KD89W3B1bmN0dWF0aW9uKlxcc10pfCQpLyAvLyBsYXN0IGNoYXIgY2FuJ3QgYmUgYSBzcGFjZSwgYW5kIGZpbmFsIF8gbXVzdCBwcmVjZWVkIHB1bmN0IG9yIFxccyAob3IgZW5kbGluZSlcblxuICAgIH0sXG4gICAgZW06IHtcbiAgICAgIHN0YXJ0OiAvXig/OihcXCooPz1bcHVuY3R1YXRpb25dKSl8XFwqKSg/IVsqXFxzXSl8Xy8sXG4gICAgICAvLyAoMSkgcmV0dXJucyBpZiBzdGFydHMgdy8gcHVuY3R1YXRpb25cbiAgICAgIG1pZGRsZTogL15cXCooPzooPzooPyFvdmVybGFwU2tpcCkoPzpbXipdfFxcXFxcXCopfG92ZXJsYXBTa2lwKXxcXCooPzooPyFvdmVybGFwU2tpcCkoPzpbXipdfFxcXFxcXCopfG92ZXJsYXBTa2lwKSo/XFwqKSs/XFwqJHxeXyg/IVtfXFxzXSkoPzooPzooPyFvdmVybGFwU2tpcCkoPzpbXl9dfFxcXFxfKXxvdmVybGFwU2tpcCl8Xyg/Oig/IW92ZXJsYXBTa2lwKSg/OlteX118XFxcXF8pfG92ZXJsYXBTa2lwKSo/XykrP18kLyxcbiAgICAgIGVuZEFzdDogL1tecHVuY3R1YXRpb25cXHNdXFwqKD8hXFwqKXxbcHVuY3R1YXRpb25dXFwqKD8hXFwqKSg/Oig/PVtwdW5jdHVhdGlvbl9cXHNdfCQpKS8sXG4gICAgICAvLyBsYXN0IGNoYXIgY2FuJ3QgYmUgcHVuY3QsIG9yIGZpbmFsICogbXVzdCBhbHNvIGJlIGZvbGxvd2VkIGJ5IHB1bmN0IChvciBlbmRsaW5lKVxuICAgICAgZW5kVW5kOiAvW15cXHNdXyg/IV8pKD86KD89W3B1bmN0dWF0aW9uKlxcc10pfCQpLyAvLyBsYXN0IGNoYXIgY2FuJ3QgYmUgYSBzcGFjZSwgYW5kIGZpbmFsIF8gbXVzdCBwcmVjZWVkIHB1bmN0IG9yIFxccyAob3IgZW5kbGluZSlcblxuICAgIH0sXG4gICAgY29kZTogL14oYCspKFteYF18W15gXVtcXHNcXFNdKj9bXmBdKVxcMSg/IWApLyxcbiAgICBicjogL14oIHsyLH18XFxcXClcXG4oPyFcXHMqJCkvLFxuICAgIGRlbDogbm9vcFRlc3QkMSxcbiAgICB0ZXh0OiAvXihgK3xbXmBdKSg/Oig/PSB7Mix9XFxuKXxbXFxzXFxTXSo/KD86KD89W1xcXFw8IVxcW2AqXXxcXGJffCQpfFteIF0oPz0gezIsfVxcbikpKS8sXG4gICAgcHVuY3R1YXRpb246IC9eKFtcXHMqcHVuY3R1YXRpb25dKS9cbiAgfTsgLy8gbGlzdCBvZiBwdW5jdHVhdGlvbiBtYXJrcyBmcm9tIGNvbW1vbiBtYXJrIHNwZWNcbiAgLy8gd2l0aG91dCAqIGFuZCBfIHRvIHdvcmthcm91bmQgY2FzZXMgd2l0aCBkb3VibGUgZW1waGFzaXNcblxuICBpbmxpbmUuX3B1bmN0dWF0aW9uID0gJyFcIiMkJSZcXCcoKStcXFxcLS4sLzo7PD0+P0BcXFxcW1xcXFxdYF57fH1+JztcbiAgaW5saW5lLnB1bmN0dWF0aW9uID0gZWRpdCQxKGlubGluZS5wdW5jdHVhdGlvbikucmVwbGFjZSgvcHVuY3R1YXRpb24vZywgaW5saW5lLl9wdW5jdHVhdGlvbikuZ2V0UmVnZXgoKTsgLy8gc2VxdWVuY2VzIGVtIHNob3VsZCBza2lwIG92ZXIgW3RpdGxlXShsaW5rKSwgYGNvZGVgLCA8aHRtbD5cblxuICBpbmxpbmUuX2Jsb2NrU2tpcCA9ICdcXFxcW1teXFxcXF1dKj9cXFxcXVxcXFwoW15cXFxcKV0qP1xcXFwpfGBbXmBdKj9gfDxbXj5dKj8+JztcbiAgaW5saW5lLl9vdmVybGFwU2tpcCA9ICdfX1teX10qP19ffFxcXFwqXFxcXCpcXFxcW15cXFxcKlxcXFxdKj9cXFxcKlxcXFwqJztcbiAgaW5saW5lLl9jb21tZW50ID0gZWRpdCQxKGJsb2NrLl9jb21tZW50KS5yZXBsYWNlKCcoPzotLT58JCknLCAnLS0+JykuZ2V0UmVnZXgoKTtcbiAgaW5saW5lLmVtLnN0YXJ0ID0gZWRpdCQxKGlubGluZS5lbS5zdGFydCkucmVwbGFjZSgvcHVuY3R1YXRpb24vZywgaW5saW5lLl9wdW5jdHVhdGlvbikuZ2V0UmVnZXgoKTtcbiAgaW5saW5lLmVtLm1pZGRsZSA9IGVkaXQkMShpbmxpbmUuZW0ubWlkZGxlKS5yZXBsYWNlKC9wdW5jdHVhdGlvbi9nLCBpbmxpbmUuX3B1bmN0dWF0aW9uKS5yZXBsYWNlKC9vdmVybGFwU2tpcC9nLCBpbmxpbmUuX292ZXJsYXBTa2lwKS5nZXRSZWdleCgpO1xuICBpbmxpbmUuZW0uZW5kQXN0ID0gZWRpdCQxKGlubGluZS5lbS5lbmRBc3QsICdnJykucmVwbGFjZSgvcHVuY3R1YXRpb24vZywgaW5saW5lLl9wdW5jdHVhdGlvbikuZ2V0UmVnZXgoKTtcbiAgaW5saW5lLmVtLmVuZFVuZCA9IGVkaXQkMShpbmxpbmUuZW0uZW5kVW5kLCAnZycpLnJlcGxhY2UoL3B1bmN0dWF0aW9uL2csIGlubGluZS5fcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG4gIGlubGluZS5zdHJvbmcuc3RhcnQgPSBlZGl0JDEoaW5saW5lLnN0cm9uZy5zdGFydCkucmVwbGFjZSgvcHVuY3R1YXRpb24vZywgaW5saW5lLl9wdW5jdHVhdGlvbikuZ2V0UmVnZXgoKTtcbiAgaW5saW5lLnN0cm9uZy5taWRkbGUgPSBlZGl0JDEoaW5saW5lLnN0cm9uZy5taWRkbGUpLnJlcGxhY2UoL3B1bmN0dWF0aW9uL2csIGlubGluZS5fcHVuY3R1YXRpb24pLnJlcGxhY2UoL292ZXJsYXBTa2lwL2csIGlubGluZS5fb3ZlcmxhcFNraXApLmdldFJlZ2V4KCk7XG4gIGlubGluZS5zdHJvbmcuZW5kQXN0ID0gZWRpdCQxKGlubGluZS5zdHJvbmcuZW5kQXN0LCAnZycpLnJlcGxhY2UoL3B1bmN0dWF0aW9uL2csIGlubGluZS5fcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG4gIGlubGluZS5zdHJvbmcuZW5kVW5kID0gZWRpdCQxKGlubGluZS5zdHJvbmcuZW5kVW5kLCAnZycpLnJlcGxhY2UoL3B1bmN0dWF0aW9uL2csIGlubGluZS5fcHVuY3R1YXRpb24pLmdldFJlZ2V4KCk7XG4gIGlubGluZS5ibG9ja1NraXAgPSBlZGl0JDEoaW5saW5lLl9ibG9ja1NraXAsICdnJykuZ2V0UmVnZXgoKTtcbiAgaW5saW5lLm92ZXJsYXBTa2lwID0gZWRpdCQxKGlubGluZS5fb3ZlcmxhcFNraXAsICdnJykuZ2V0UmVnZXgoKTtcbiAgaW5saW5lLl9lc2NhcGVzID0gL1xcXFwoWyFcIiMkJSYnKCkqKyxcXC0uLzo7PD0+P0BcXFtcXF1cXFxcXl9ge3x9fl0pL2c7XG4gIGlubGluZS5fc2NoZW1lID0gL1thLXpBLVpdW2EtekEtWjAtOSsuLV17MSwzMX0vO1xuICBpbmxpbmUuX2VtYWlsID0gL1thLXpBLVowLTkuISMkJSYnKisvPT9eX2B7fH1+LV0rKEApW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSsoPyFbLV9dKS87XG4gIGlubGluZS5hdXRvbGluayA9IGVkaXQkMShpbmxpbmUuYXV0b2xpbmspLnJlcGxhY2UoJ3NjaGVtZScsIGlubGluZS5fc2NoZW1lKS5yZXBsYWNlKCdlbWFpbCcsIGlubGluZS5fZW1haWwpLmdldFJlZ2V4KCk7XG4gIGlubGluZS5fYXR0cmlidXRlID0gL1xccytbYS16QS1aOl9dW1xcdy46LV0qKD86XFxzKj1cXHMqXCJbXlwiXSpcInxcXHMqPVxccyonW14nXSonfFxccyo9XFxzKlteXFxzXCInPTw+YF0rKT8vO1xuICBpbmxpbmUudGFnID0gZWRpdCQxKGlubGluZS50YWcpLnJlcGxhY2UoJ2NvbW1lbnQnLCBpbmxpbmUuX2NvbW1lbnQpLnJlcGxhY2UoJ2F0dHJpYnV0ZScsIGlubGluZS5fYXR0cmlidXRlKS5nZXRSZWdleCgpO1xuICBpbmxpbmUuX2xhYmVsID0gLyg/OlxcWyg/OlxcXFwufFteXFxbXFxdXFxcXF0pKlxcXXxcXFxcLnxgW15gXSpgfFteXFxbXFxdXFxcXGBdKSo/LztcbiAgaW5saW5lLl9ocmVmID0gLzwoPzpcXFxcLnxbXlxcbjw+XFxcXF0pKz58W15cXHNcXHgwMC1cXHgxZl0qLztcbiAgaW5saW5lLl90aXRsZSA9IC9cIig/OlxcXFxcIj98W15cIlxcXFxdKSpcInwnKD86XFxcXCc/fFteJ1xcXFxdKSonfFxcKCg/OlxcXFxcXCk/fFteKVxcXFxdKSpcXCkvO1xuICBpbmxpbmUubGluayA9IGVkaXQkMShpbmxpbmUubGluaykucmVwbGFjZSgnbGFiZWwnLCBpbmxpbmUuX2xhYmVsKS5yZXBsYWNlKCdocmVmJywgaW5saW5lLl9ocmVmKS5yZXBsYWNlKCd0aXRsZScsIGlubGluZS5fdGl0bGUpLmdldFJlZ2V4KCk7XG4gIGlubGluZS5yZWZsaW5rID0gZWRpdCQxKGlubGluZS5yZWZsaW5rKS5yZXBsYWNlKCdsYWJlbCcsIGlubGluZS5fbGFiZWwpLmdldFJlZ2V4KCk7XG4gIGlubGluZS5yZWZsaW5rU2VhcmNoID0gZWRpdCQxKGlubGluZS5yZWZsaW5rU2VhcmNoLCAnZycpLnJlcGxhY2UoJ3JlZmxpbmsnLCBpbmxpbmUucmVmbGluaykucmVwbGFjZSgnbm9saW5rJywgaW5saW5lLm5vbGluaykuZ2V0UmVnZXgoKTtcbiAgLyoqXG4gICAqIE5vcm1hbCBJbmxpbmUgR3JhbW1hclxuICAgKi9cblxuICBpbmxpbmUubm9ybWFsID0gbWVyZ2UkMSh7fSwgaW5saW5lKTtcbiAgLyoqXG4gICAqIFBlZGFudGljIElubGluZSBHcmFtbWFyXG4gICAqL1xuXG4gIGlubGluZS5wZWRhbnRpYyA9IG1lcmdlJDEoe30sIGlubGluZS5ub3JtYWwsIHtcbiAgICBzdHJvbmc6IHtcbiAgICAgIHN0YXJ0OiAvXl9ffFxcKlxcKi8sXG4gICAgICBtaWRkbGU6IC9eX18oPz1cXFMpKFtcXHNcXFNdKj9cXFMpX18oPyFfKXxeXFwqXFwqKD89XFxTKShbXFxzXFxTXSo/XFxTKVxcKlxcKig/IVxcKikvLFxuICAgICAgZW5kQXN0OiAvXFwqXFwqKD8hXFwqKS9nLFxuICAgICAgZW5kVW5kOiAvX18oPyFfKS9nXG4gICAgfSxcbiAgICBlbToge1xuICAgICAgc3RhcnQ6IC9eX3xcXCovLFxuICAgICAgbWlkZGxlOiAvXigpXFwqKD89XFxTKShbXFxzXFxTXSo/XFxTKVxcKig/IVxcKil8Xl8oPz1cXFMpKFtcXHNcXFNdKj9cXFMpXyg/IV8pLyxcbiAgICAgIGVuZEFzdDogL1xcKig/IVxcKikvZyxcbiAgICAgIGVuZFVuZDogL18oPyFfKS9nXG4gICAgfSxcbiAgICBsaW5rOiBlZGl0JDEoL14hP1xcWyhsYWJlbClcXF1cXCgoLio/KVxcKS8pLnJlcGxhY2UoJ2xhYmVsJywgaW5saW5lLl9sYWJlbCkuZ2V0UmVnZXgoKSxcbiAgICByZWZsaW5rOiBlZGl0JDEoL14hP1xcWyhsYWJlbClcXF1cXHMqXFxbKFteXFxdXSopXFxdLykucmVwbGFjZSgnbGFiZWwnLCBpbmxpbmUuX2xhYmVsKS5nZXRSZWdleCgpXG4gIH0pO1xuICAvKipcbiAgICogR0ZNIElubGluZSBHcmFtbWFyXG4gICAqL1xuXG4gIGlubGluZS5nZm0gPSBtZXJnZSQxKHt9LCBpbmxpbmUubm9ybWFsLCB7XG4gICAgZXNjYXBlOiBlZGl0JDEoaW5saW5lLmVzY2FwZSkucmVwbGFjZSgnXSknLCAnfnxdKScpLmdldFJlZ2V4KCksXG4gICAgX2V4dGVuZGVkX2VtYWlsOiAvW0EtWmEtejAtOS5fKy1dKyhAKVthLXpBLVowLTktX10rKD86XFwuW2EtekEtWjAtOS1fXSpbYS16QS1aMC05XSkrKD8hWy1fXSkvLFxuICAgIHVybDogL14oKD86ZnRwfGh0dHBzPyk6XFwvXFwvfHd3d1xcLikoPzpbYS16QS1aMC05XFwtXStcXC4/KStbXlxcczxdKnxeZW1haWwvLFxuICAgIF9iYWNrcGVkYWw6IC8oPzpbXj8hLiw6OypffigpJl0rfFxcKFteKV0qXFwpfCYoPyFbYS16QS1aMC05XSs7JCl8Wz8hLiw6OypffildKyg/ISQpKSsvLFxuICAgIGRlbDogL14ofn4/KSg/PVteXFxzfl0pKFtcXHNcXFNdKj9bXlxcc35dKVxcMSg/PVtefl18JCkvLFxuICAgIHRleHQ6IC9eKFtgfl0rfFteYH5dKSg/Oig/PSB7Mix9XFxuKXxbXFxzXFxTXSo/KD86KD89W1xcXFw8IVxcW2Aqfl18XFxiX3xodHRwcz86XFwvXFwvfGZ0cDpcXC9cXC98d3d3XFwufCQpfFteIF0oPz0gezIsfVxcbil8W15hLXpBLVowLTkuISMkJSYnKitcXC89P19ge1xcfH1+LV0oPz1bYS16QS1aMC05LiEjJCUmJyorXFwvPT9fYHtcXHx9fi1dK0ApKXwoPz1bYS16QS1aMC05LiEjJCUmJyorXFwvPT9fYHtcXHx9fi1dK0ApKS9cbiAgfSk7XG4gIGlubGluZS5nZm0udXJsID0gZWRpdCQxKGlubGluZS5nZm0udXJsLCAnaScpLnJlcGxhY2UoJ2VtYWlsJywgaW5saW5lLmdmbS5fZXh0ZW5kZWRfZW1haWwpLmdldFJlZ2V4KCk7XG4gIC8qKlxuICAgKiBHRk0gKyBMaW5lIEJyZWFrcyBJbmxpbmUgR3JhbW1hclxuICAgKi9cblxuICBpbmxpbmUuYnJlYWtzID0gbWVyZ2UkMSh7fSwgaW5saW5lLmdmbSwge1xuICAgIGJyOiBlZGl0JDEoaW5saW5lLmJyKS5yZXBsYWNlKCd7Mix9JywgJyonKS5nZXRSZWdleCgpLFxuICAgIHRleHQ6IGVkaXQkMShpbmxpbmUuZ2ZtLnRleHQpLnJlcGxhY2UoJ1xcXFxiXycsICdcXFxcYl98IHsyLH1cXFxcbicpLnJlcGxhY2UoL1xcezIsXFx9L2csICcqJykuZ2V0UmVnZXgoKVxuICB9KTtcbiAgdmFyIHJ1bGVzID0ge1xuICAgIGJsb2NrOiBibG9jayxcbiAgICBpbmxpbmU6IGlubGluZVxuICB9O1xuXG4gIHZhciBkZWZhdWx0cyQyID0gZGVmYXVsdHMuZGVmYXVsdHM7XG4gIHZhciBibG9jayQxID0gcnVsZXMuYmxvY2ssXG4gICAgICBpbmxpbmUkMSA9IHJ1bGVzLmlubGluZTtcbiAgdmFyIHJlcGVhdFN0cmluZyQxID0gaGVscGVycy5yZXBlYXRTdHJpbmc7XG4gIC8qKlxuICAgKiBzbWFydHlwYW50cyB0ZXh0IHJlcGxhY2VtZW50XG4gICAqL1xuXG4gIGZ1bmN0aW9uIHNtYXJ0eXBhbnRzKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dCAvLyBlbS1kYXNoZXNcbiAgICAucmVwbGFjZSgvLS0tL2csIFwiXFx1MjAxNFwiKSAvLyBlbi1kYXNoZXNcbiAgICAucmVwbGFjZSgvLS0vZywgXCJcXHUyMDEzXCIpIC8vIG9wZW5pbmcgc2luZ2xlc1xuICAgIC5yZXBsYWNlKC8oXnxbLVxcdTIwMTQvKFxcW3tcIlxcc10pJy9nLCBcIiQxXFx1MjAxOFwiKSAvLyBjbG9zaW5nIHNpbmdsZXMgJiBhcG9zdHJvcGhlc1xuICAgIC5yZXBsYWNlKC8nL2csIFwiXFx1MjAxOVwiKSAvLyBvcGVuaW5nIGRvdWJsZXNcbiAgICAucmVwbGFjZSgvKF58Wy1cXHUyMDE0LyhcXFt7XFx1MjAxOFxcc10pXCIvZywgXCIkMVxcdTIwMUNcIikgLy8gY2xvc2luZyBkb3VibGVzXG4gICAgLnJlcGxhY2UoL1wiL2csIFwiXFx1MjAxRFwiKSAvLyBlbGxpcHNlc1xuICAgIC5yZXBsYWNlKC9cXC57M30vZywgXCJcXHUyMDI2XCIpO1xuICB9XG4gIC8qKlxuICAgKiBtYW5nbGUgZW1haWwgYWRkcmVzc2VzXG4gICAqL1xuXG5cbiAgZnVuY3Rpb24gbWFuZ2xlKHRleHQpIHtcbiAgICB2YXIgb3V0ID0gJycsXG4gICAgICAgIGksXG4gICAgICAgIGNoO1xuICAgIHZhciBsID0gdGV4dC5sZW5ndGg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjaCA9IHRleHQuY2hhckNvZGVBdChpKTtcblxuICAgICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcbiAgICAgICAgY2ggPSAneCcgKyBjaC50b1N0cmluZygxNik7XG4gICAgICB9XG5cbiAgICAgIG91dCArPSAnJiMnICsgY2ggKyAnOyc7XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dDtcbiAgfVxuICAvKipcbiAgICogQmxvY2sgTGV4ZXJcbiAgICovXG5cblxuICB2YXIgTGV4ZXJfMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTGV4ZXIob3B0aW9ucykge1xuICAgICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICAgIHRoaXMudG9rZW5zLmxpbmtzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwgZGVmYXVsdHMkMjtcbiAgICAgIHRoaXMub3B0aW9ucy50b2tlbml6ZXIgPSB0aGlzLm9wdGlvbnMudG9rZW5pemVyIHx8IG5ldyBUb2tlbml6ZXJfMSgpO1xuICAgICAgdGhpcy50b2tlbml6ZXIgPSB0aGlzLm9wdGlvbnMudG9rZW5pemVyO1xuICAgICAgdGhpcy50b2tlbml6ZXIub3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIHZhciBydWxlcyA9IHtcbiAgICAgICAgYmxvY2s6IGJsb2NrJDEubm9ybWFsLFxuICAgICAgICBpbmxpbmU6IGlubGluZSQxLm5vcm1hbFxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wZWRhbnRpYykge1xuICAgICAgICBydWxlcy5ibG9jayA9IGJsb2NrJDEucGVkYW50aWM7XG4gICAgICAgIHJ1bGVzLmlubGluZSA9IGlubGluZSQxLnBlZGFudGljO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZ2ZtKSB7XG4gICAgICAgIHJ1bGVzLmJsb2NrID0gYmxvY2skMS5nZm07XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5icmVha3MpIHtcbiAgICAgICAgICBydWxlcy5pbmxpbmUgPSBpbmxpbmUkMS5icmVha3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcnVsZXMuaW5saW5lID0gaW5saW5lJDEuZ2ZtO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMudG9rZW5pemVyLnJ1bGVzID0gcnVsZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4cG9zZSBSdWxlc1xuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgTGV4IE1ldGhvZFxuICAgICAqL1xuICAgIExleGVyLmxleCA9IGZ1bmN0aW9uIGxleChzcmMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBsZXhlciA9IG5ldyBMZXhlcihvcHRpb25zKTtcbiAgICAgIHJldHVybiBsZXhlci5sZXgoc3JjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIExleCBJbmxpbmUgTWV0aG9kXG4gICAgICovXG4gICAgO1xuXG4gICAgTGV4ZXIubGV4SW5saW5lID0gZnVuY3Rpb24gbGV4SW5saW5lKHNyYywgb3B0aW9ucykge1xuICAgICAgdmFyIGxleGVyID0gbmV3IExleGVyKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIGxleGVyLmlubGluZVRva2VucyhzcmMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVwcm9jZXNzaW5nXG4gICAgICovXG4gICAgO1xuXG4gICAgdmFyIF9wcm90byA9IExleGVyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5sZXggPSBmdW5jdGlvbiBsZXgoc3JjKSB7XG4gICAgICBzcmMgPSBzcmMucmVwbGFjZSgvXFxyXFxufFxcci9nLCAnXFxuJykucmVwbGFjZSgvXFx0L2csICcgICAgJyk7XG4gICAgICB0aGlzLmJsb2NrVG9rZW5zKHNyYywgdGhpcy50b2tlbnMsIHRydWUpO1xuICAgICAgdGhpcy5pbmxpbmUodGhpcy50b2tlbnMpO1xuICAgICAgcmV0dXJuIHRoaXMudG9rZW5zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZXhpbmdcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8uYmxvY2tUb2tlbnMgPSBmdW5jdGlvbiBibG9ja1Rva2VucyhzcmMsIHRva2VucywgdG9wKSB7XG4gICAgICBpZiAodG9rZW5zID09PSB2b2lkIDApIHtcbiAgICAgICAgdG9rZW5zID0gW107XG4gICAgICB9XG5cbiAgICAgIGlmICh0b3AgPT09IHZvaWQgMCkge1xuICAgICAgICB0b3AgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnBlZGFudGljKSB7XG4gICAgICAgIHNyYyA9IHNyYy5yZXBsYWNlKC9eICskL2dtLCAnJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b2tlbiwgaSwgbCwgbGFzdFRva2VuO1xuXG4gICAgICB3aGlsZSAoc3JjKSB7XG4gICAgICAgIC8vIG5ld2xpbmVcbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuc3BhY2Uoc3JjKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG5cbiAgICAgICAgICBpZiAodG9rZW4udHlwZSkge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGNvZGVcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmNvZGUoc3JjLCB0b2tlbnMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcblxuICAgICAgICAgIGlmICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBsYXN0VG9rZW4ucmF3ICs9ICdcXG4nICsgdG9rZW4ucmF3O1xuICAgICAgICAgICAgbGFzdFRva2VuLnRleHQgKz0gJ1xcbicgKyB0b2tlbi50ZXh0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGZlbmNlc1xuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZmVuY2VzKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBoZWFkaW5nXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5oZWFkaW5nKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyB0YWJsZSBubyBsZWFkaW5nIHBpcGUgKGdmbSlcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLm5wdGFibGUoc3JjKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGhyXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5ocihzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gYmxvY2txdW90ZVxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuYmxvY2txdW90ZShzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbi50b2tlbnMgPSB0aGlzLmJsb2NrVG9rZW5zKHRva2VuLnRleHQsIFtdLCB0b3ApO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBsaXN0XG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5saXN0KHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIGwgPSB0b2tlbi5pdGVtcy5sZW5ndGg7XG5cbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB0b2tlbi5pdGVtc1tpXS50b2tlbnMgPSB0aGlzLmJsb2NrVG9rZW5zKHRva2VuLml0ZW1zW2ldLnRleHQsIFtdLCBmYWxzZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGh0bWxcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmh0bWwoc3JjKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGRlZlxuXG5cbiAgICAgICAgaWYgKHRvcCAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci5kZWYoc3JjKSkpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuXG4gICAgICAgICAgaWYgKCF0aGlzLnRva2Vucy5saW5rc1t0b2tlbi50YWddKSB7XG4gICAgICAgICAgICB0aGlzLnRva2Vucy5saW5rc1t0b2tlbi50YWddID0ge1xuICAgICAgICAgICAgICBocmVmOiB0b2tlbi5ocmVmLFxuICAgICAgICAgICAgICB0aXRsZTogdG9rZW4udGl0bGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gdGFibGUgKGdmbSlcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLnRhYmxlKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBsaGVhZGluZ1xuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIubGhlYWRpbmcoc3JjKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIHRvcC1sZXZlbCBwYXJhZ3JhcGhcblxuXG4gICAgICAgIGlmICh0b3AgJiYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIucGFyYWdyYXBoKHNyYykpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gdGV4dFxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIudGV4dChzcmMsIHRva2VucykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuXG4gICAgICAgICAgaWYgKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdFRva2VuID0gdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGxhc3RUb2tlbi5yYXcgKz0gJ1xcbicgKyB0b2tlbi5yYXc7XG4gICAgICAgICAgICBsYXN0VG9rZW4udGV4dCArPSAnXFxuJyArIHRva2VuLnRleHQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgdmFyIGVyck1zZyA9ICdJbmZpbml0ZSBsb29wIG9uIGJ5dGU6ICcgKyBzcmMuY2hhckNvZGVBdCgwKTtcblxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyck1zZyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVyck1zZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfTtcblxuICAgIF9wcm90by5pbmxpbmUgPSBmdW5jdGlvbiBpbmxpbmUodG9rZW5zKSB7XG4gICAgICB2YXIgaSwgaiwgaywgbDIsIHJvdywgdG9rZW47XG4gICAgICB2YXIgbCA9IHRva2Vucy5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgY2FzZSAncGFyYWdyYXBoJzpcbiAgICAgICAgICBjYXNlICd0ZXh0JzpcbiAgICAgICAgICBjYXNlICdoZWFkaW5nJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdG9rZW4udG9rZW5zID0gW107XG4gICAgICAgICAgICAgIHRoaXMuaW5saW5lVG9rZW5zKHRva2VuLnRleHQsIHRva2VuLnRva2Vucyk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0b2tlbi50b2tlbnMgPSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyOiBbXSxcbiAgICAgICAgICAgICAgICBjZWxsczogW11cbiAgICAgICAgICAgICAgfTsgLy8gaGVhZGVyXG5cbiAgICAgICAgICAgICAgbDIgPSB0b2tlbi5oZWFkZXIubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4udG9rZW5zLmhlYWRlcltqXSA9IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lVG9rZW5zKHRva2VuLmhlYWRlcltqXSwgdG9rZW4udG9rZW5zLmhlYWRlcltqXSk7XG4gICAgICAgICAgICAgIH0gLy8gY2VsbHNcblxuXG4gICAgICAgICAgICAgIGwyID0gdG9rZW4uY2VsbHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgcm93ID0gdG9rZW4uY2VsbHNbal07XG4gICAgICAgICAgICAgICAgdG9rZW4udG9rZW5zLmNlbGxzW2pdID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgcm93Lmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgICB0b2tlbi50b2tlbnMuY2VsbHNbal1ba10gPSBbXTtcbiAgICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lVG9rZW5zKHJvd1trXSwgdG9rZW4udG9rZW5zLmNlbGxzW2pdW2tdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aGlzLmlubGluZSh0b2tlbi50b2tlbnMpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBsMiA9IHRva2VuLml0ZW1zLmxlbmd0aDtcblxuICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbDI7IGorKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lKHRva2VuLml0ZW1zW2pdLnRva2Vucyk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZXhpbmcvQ29tcGlsaW5nXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmlubGluZVRva2VucyA9IGZ1bmN0aW9uIGlubGluZVRva2VucyhzcmMsIHRva2VucywgaW5MaW5rLCBpblJhd0Jsb2NrKSB7XG4gICAgICBpZiAodG9rZW5zID09PSB2b2lkIDApIHtcbiAgICAgICAgdG9rZW5zID0gW107XG4gICAgICB9XG5cbiAgICAgIGlmIChpbkxpbmsgPT09IHZvaWQgMCkge1xuICAgICAgICBpbkxpbmsgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluUmF3QmxvY2sgPT09IHZvaWQgMCkge1xuICAgICAgICBpblJhd0Jsb2NrID0gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b2tlbjsgLy8gU3RyaW5nIHdpdGggbGlua3MgbWFza2VkIHRvIGF2b2lkIGludGVyZmVyZW5jZSB3aXRoIGVtIGFuZCBzdHJvbmdcblxuICAgICAgdmFyIG1hc2tlZFNyYyA9IHNyYztcbiAgICAgIHZhciBtYXRjaDtcbiAgICAgIHZhciBrZWVwUHJldkNoYXIsIHByZXZDaGFyOyAvLyBNYXNrIG91dCByZWZsaW5rc1xuXG4gICAgICBpZiAodGhpcy50b2tlbnMubGlua3MpIHtcbiAgICAgICAgdmFyIGxpbmtzID0gT2JqZWN0LmtleXModGhpcy50b2tlbnMubGlua3MpO1xuXG4gICAgICAgIGlmIChsaW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgd2hpbGUgKChtYXRjaCA9IHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5yZWZsaW5rU2VhcmNoLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGxpbmtzLmluY2x1ZGVzKG1hdGNoWzBdLnNsaWNlKG1hdGNoWzBdLmxhc3RJbmRleE9mKCdbJykgKyAxLCAtMSkpKSB7XG4gICAgICAgICAgICAgIG1hc2tlZFNyYyA9IG1hc2tlZFNyYy5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAnWycgKyByZXBlYXRTdHJpbmckMSgnYScsIG1hdGNoWzBdLmxlbmd0aCAtIDIpICsgJ10nICsgbWFza2VkU3JjLnNsaWNlKHRoaXMudG9rZW5pemVyLnJ1bGVzLmlubGluZS5yZWZsaW5rU2VhcmNoLmxhc3RJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vIE1hc2sgb3V0IG90aGVyIGJsb2Nrc1xuXG5cbiAgICAgIHdoaWxlICgobWF0Y2ggPSB0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYmxvY2tTa2lwLmV4ZWMobWFza2VkU3JjKSkgIT0gbnVsbCkge1xuICAgICAgICBtYXNrZWRTcmMgPSBtYXNrZWRTcmMuc2xpY2UoMCwgbWF0Y2guaW5kZXgpICsgJ1snICsgcmVwZWF0U3RyaW5nJDEoJ2EnLCBtYXRjaFswXS5sZW5ndGggLSAyKSArICddJyArIG1hc2tlZFNyYy5zbGljZSh0aGlzLnRva2VuaXplci5ydWxlcy5pbmxpbmUuYmxvY2tTa2lwLmxhc3RJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChzcmMpIHtcbiAgICAgICAgaWYgKCFrZWVwUHJldkNoYXIpIHtcbiAgICAgICAgICBwcmV2Q2hhciA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAga2VlcFByZXZDaGFyID0gZmFsc2U7IC8vIGVzY2FwZVxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmVzY2FwZShzcmMpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gdGFnXG5cblxuICAgICAgICBpZiAodG9rZW4gPSB0aGlzLnRva2VuaXplci50YWcoc3JjLCBpbkxpbmssIGluUmF3QmxvY2spKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICBpbkxpbmsgPSB0b2tlbi5pbkxpbms7XG4gICAgICAgICAgaW5SYXdCbG9jayA9IHRva2VuLmluUmF3QmxvY2s7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGxpbmtcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmxpbmsoc3JjKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG5cbiAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2xpbmsnKSB7XG4gICAgICAgICAgICB0b2tlbi50b2tlbnMgPSB0aGlzLmlubGluZVRva2Vucyh0b2tlbi50ZXh0LCBbXSwgdHJ1ZSwgaW5SYXdCbG9jayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIHJlZmxpbmssIG5vbGlua1xuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIucmVmbGluayhzcmMsIHRoaXMudG9rZW5zLmxpbmtzKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG5cbiAgICAgICAgICBpZiAodG9rZW4udHlwZSA9PT0gJ2xpbmsnKSB7XG4gICAgICAgICAgICB0b2tlbi50b2tlbnMgPSB0aGlzLmlubGluZVRva2Vucyh0b2tlbi50ZXh0LCBbXSwgdHJ1ZSwgaW5SYXdCbG9jayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIHN0cm9uZ1xuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuc3Ryb25nKHNyYywgbWFza2VkU3JjLCBwcmV2Q2hhcikpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2VuLnRva2VucyA9IHRoaXMuaW5saW5lVG9rZW5zKHRva2VuLnRleHQsIFtdLCBpbkxpbmssIGluUmF3QmxvY2spO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBlbVxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZW0oc3JjLCBtYXNrZWRTcmMsIHByZXZDaGFyKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW4udG9rZW5zID0gdGhpcy5pbmxpbmVUb2tlbnModG9rZW4udGV4dCwgW10sIGluTGluaywgaW5SYXdCbG9jayk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGNvZGVcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmNvZGVzcGFuKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBiclxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuYnIoc3JjKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIGRlbCAoZ2ZtKVxuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuZGVsKHNyYykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHRva2VuLnRva2VucyA9IHRoaXMuaW5saW5lVG9rZW5zKHRva2VuLnRleHQsIFtdLCBpbkxpbmssIGluUmF3QmxvY2spO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBhdXRvbGlua1xuXG5cbiAgICAgICAgaWYgKHRva2VuID0gdGhpcy50b2tlbml6ZXIuYXV0b2xpbmsoc3JjLCBtYW5nbGUpKSB7XG4gICAgICAgICAgc3JjID0gc3JjLnN1YnN0cmluZyh0b2tlbi5yYXcubGVuZ3RoKTtcbiAgICAgICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gdXJsIChnZm0pXG5cblxuICAgICAgICBpZiAoIWluTGluayAmJiAodG9rZW4gPSB0aGlzLnRva2VuaXplci51cmwoc3JjLCBtYW5nbGUpKSkge1xuICAgICAgICAgIHNyYyA9IHNyYy5zdWJzdHJpbmcodG9rZW4ucmF3Lmxlbmd0aCk7XG4gICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIHRleHRcblxuXG4gICAgICAgIGlmICh0b2tlbiA9IHRoaXMudG9rZW5pemVyLmlubGluZVRleHQoc3JjLCBpblJhd0Jsb2NrLCBzbWFydHlwYW50cykpIHtcbiAgICAgICAgICBzcmMgPSBzcmMuc3Vic3RyaW5nKHRva2VuLnJhdy5sZW5ndGgpO1xuICAgICAgICAgIHByZXZDaGFyID0gdG9rZW4ucmF3LnNsaWNlKC0xKTtcbiAgICAgICAgICBrZWVwUHJldkNoYXIgPSB0cnVlO1xuICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICB2YXIgZXJyTXNnID0gJ0luZmluaXRlIGxvb3Agb24gYnl0ZTogJyArIHNyYy5jaGFyQ29kZUF0KDApO1xuXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9O1xuXG4gICAgX2NyZWF0ZUNsYXNzKExleGVyLCBudWxsLCBbe1xuICAgICAga2V5OiBcInJ1bGVzXCIsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBibG9jazogYmxvY2skMSxcbiAgICAgICAgICBpbmxpbmU6IGlubGluZSQxXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIExleGVyO1xuICB9KCk7XG5cbiAgdmFyIGRlZmF1bHRzJDMgPSBkZWZhdWx0cy5kZWZhdWx0cztcbiAgdmFyIGNsZWFuVXJsJDEgPSBoZWxwZXJzLmNsZWFuVXJsLFxuICAgICAgZXNjYXBlJDEgPSBoZWxwZXJzLmVzY2FwZTtcbiAgLyoqXG4gICAqIFJlbmRlcmVyXG4gICAqL1xuXG4gIHZhciBSZW5kZXJlcl8xID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZW5kZXJlcihvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IGRlZmF1bHRzJDM7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IFJlbmRlcmVyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5jb2RlID0gZnVuY3Rpb24gY29kZShfY29kZSwgaW5mb3N0cmluZywgZXNjYXBlZCkge1xuICAgICAgdmFyIGxhbmcgPSAoaW5mb3N0cmluZyB8fCAnJykubWF0Y2goL1xcUyovKVswXTtcblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oaWdobGlnaHQpIHtcbiAgICAgICAgdmFyIG91dCA9IHRoaXMub3B0aW9ucy5oaWdobGlnaHQoX2NvZGUsIGxhbmcpO1xuXG4gICAgICAgIGlmIChvdXQgIT0gbnVsbCAmJiBvdXQgIT09IF9jb2RlKSB7XG4gICAgICAgICAgZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgX2NvZGUgPSBvdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgX2NvZGUgPSBfY29kZS5yZXBsYWNlKC9cXG4kLywgJycpICsgJ1xcbic7XG5cbiAgICAgIGlmICghbGFuZykge1xuICAgICAgICByZXR1cm4gJzxwcmU+PGNvZGU+JyArIChlc2NhcGVkID8gX2NvZGUgOiBlc2NhcGUkMShfY29kZSwgdHJ1ZSkpICsgJzwvY29kZT48L3ByZT5cXG4nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJzxwcmU+PGNvZGUgY2xhc3M9XCInICsgdGhpcy5vcHRpb25zLmxhbmdQcmVmaXggKyBlc2NhcGUkMShsYW5nLCB0cnVlKSArICdcIj4nICsgKGVzY2FwZWQgPyBfY29kZSA6IGVzY2FwZSQxKF9jb2RlLCB0cnVlKSkgKyAnPC9jb2RlPjwvcHJlPlxcbic7XG4gICAgfTtcblxuICAgIF9wcm90by5ibG9ja3F1b3RlID0gZnVuY3Rpb24gYmxvY2txdW90ZShxdW90ZSkge1xuICAgICAgcmV0dXJuICc8YmxvY2txdW90ZT5cXG4nICsgcXVvdGUgKyAnPC9ibG9ja3F1b3RlPlxcbic7XG4gICAgfTtcblxuICAgIF9wcm90by5odG1sID0gZnVuY3Rpb24gaHRtbChfaHRtbCkge1xuICAgICAgcmV0dXJuIF9odG1sO1xuICAgIH07XG5cbiAgICBfcHJvdG8uaGVhZGluZyA9IGZ1bmN0aW9uIGhlYWRpbmcodGV4dCwgbGV2ZWwsIHJhdywgc2x1Z2dlcikge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5oZWFkZXJJZHMpIHtcbiAgICAgICAgcmV0dXJuICc8aCcgKyBsZXZlbCArICcgaWQ9XCInICsgdGhpcy5vcHRpb25zLmhlYWRlclByZWZpeCArIHNsdWdnZXIuc2x1ZyhyYXcpICsgJ1wiPicgKyB0ZXh0ICsgJzwvaCcgKyBsZXZlbCArICc+XFxuJztcbiAgICAgIH0gLy8gaWdub3JlIElEc1xuXG5cbiAgICAgIHJldHVybiAnPGgnICsgbGV2ZWwgKyAnPicgKyB0ZXh0ICsgJzwvaCcgKyBsZXZlbCArICc+XFxuJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmhyID0gZnVuY3Rpb24gaHIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnhodG1sID8gJzxoci8+XFxuJyA6ICc8aHI+XFxuJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmxpc3QgPSBmdW5jdGlvbiBsaXN0KGJvZHksIG9yZGVyZWQsIHN0YXJ0KSB7XG4gICAgICB2YXIgdHlwZSA9IG9yZGVyZWQgPyAnb2wnIDogJ3VsJyxcbiAgICAgICAgICBzdGFydGF0dCA9IG9yZGVyZWQgJiYgc3RhcnQgIT09IDEgPyAnIHN0YXJ0PVwiJyArIHN0YXJ0ICsgJ1wiJyA6ICcnO1xuICAgICAgcmV0dXJuICc8JyArIHR5cGUgKyBzdGFydGF0dCArICc+XFxuJyArIGJvZHkgKyAnPC8nICsgdHlwZSArICc+XFxuJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmxpc3RpdGVtID0gZnVuY3Rpb24gbGlzdGl0ZW0odGV4dCkge1xuICAgICAgcmV0dXJuICc8bGk+JyArIHRleHQgKyAnPC9saT5cXG4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8uY2hlY2tib3ggPSBmdW5jdGlvbiBjaGVja2JveChjaGVja2VkKSB7XG4gICAgICByZXR1cm4gJzxpbnB1dCAnICsgKGNoZWNrZWQgPyAnY2hlY2tlZD1cIlwiICcgOiAnJykgKyAnZGlzYWJsZWQ9XCJcIiB0eXBlPVwiY2hlY2tib3hcIicgKyAodGhpcy5vcHRpb25zLnhodG1sID8gJyAvJyA6ICcnKSArICc+ICc7XG4gICAgfTtcblxuICAgIF9wcm90by5wYXJhZ3JhcGggPSBmdW5jdGlvbiBwYXJhZ3JhcGgodGV4dCkge1xuICAgICAgcmV0dXJuICc8cD4nICsgdGV4dCArICc8L3A+XFxuJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLnRhYmxlID0gZnVuY3Rpb24gdGFibGUoaGVhZGVyLCBib2R5KSB7XG4gICAgICBpZiAoYm9keSkgYm9keSA9ICc8dGJvZHk+JyArIGJvZHkgKyAnPC90Ym9keT4nO1xuICAgICAgcmV0dXJuICc8dGFibGU+XFxuJyArICc8dGhlYWQ+XFxuJyArIGhlYWRlciArICc8L3RoZWFkPlxcbicgKyBib2R5ICsgJzwvdGFibGU+XFxuJztcbiAgICB9O1xuXG4gICAgX3Byb3RvLnRhYmxlcm93ID0gZnVuY3Rpb24gdGFibGVyb3coY29udGVudCkge1xuICAgICAgcmV0dXJuICc8dHI+XFxuJyArIGNvbnRlbnQgKyAnPC90cj5cXG4nO1xuICAgIH07XG5cbiAgICBfcHJvdG8udGFibGVjZWxsID0gZnVuY3Rpb24gdGFibGVjZWxsKGNvbnRlbnQsIGZsYWdzKSB7XG4gICAgICB2YXIgdHlwZSA9IGZsYWdzLmhlYWRlciA/ICd0aCcgOiAndGQnO1xuICAgICAgdmFyIHRhZyA9IGZsYWdzLmFsaWduID8gJzwnICsgdHlwZSArICcgYWxpZ249XCInICsgZmxhZ3MuYWxpZ24gKyAnXCI+JyA6ICc8JyArIHR5cGUgKyAnPic7XG4gICAgICByZXR1cm4gdGFnICsgY29udGVudCArICc8LycgKyB0eXBlICsgJz5cXG4nO1xuICAgIH0gLy8gc3BhbiBsZXZlbCByZW5kZXJlclxuICAgIDtcblxuICAgIF9wcm90by5zdHJvbmcgPSBmdW5jdGlvbiBzdHJvbmcodGV4dCkge1xuICAgICAgcmV0dXJuICc8c3Ryb25nPicgKyB0ZXh0ICsgJzwvc3Ryb25nPic7XG4gICAgfTtcblxuICAgIF9wcm90by5lbSA9IGZ1bmN0aW9uIGVtKHRleHQpIHtcbiAgICAgIHJldHVybiAnPGVtPicgKyB0ZXh0ICsgJzwvZW0+JztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmNvZGVzcGFuID0gZnVuY3Rpb24gY29kZXNwYW4odGV4dCkge1xuICAgICAgcmV0dXJuICc8Y29kZT4nICsgdGV4dCArICc8L2NvZGU+JztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmJyID0gZnVuY3Rpb24gYnIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnhodG1sID8gJzxici8+JyA6ICc8YnI+JztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmRlbCA9IGZ1bmN0aW9uIGRlbCh0ZXh0KSB7XG4gICAgICByZXR1cm4gJzxkZWw+JyArIHRleHQgKyAnPC9kZWw+JztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmxpbmsgPSBmdW5jdGlvbiBsaW5rKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gICAgICBocmVmID0gY2xlYW5VcmwkMSh0aGlzLm9wdGlvbnMuc2FuaXRpemUsIHRoaXMub3B0aW9ucy5iYXNlVXJsLCBocmVmKTtcblxuICAgICAgaWYgKGhyZWYgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBvdXQgPSAnPGEgaHJlZj1cIicgKyBlc2NhcGUkMShocmVmKSArICdcIic7XG5cbiAgICAgIGlmICh0aXRsZSkge1xuICAgICAgICBvdXQgKz0gJyB0aXRsZT1cIicgKyB0aXRsZSArICdcIic7XG4gICAgICB9XG5cbiAgICAgIG91dCArPSAnPicgKyB0ZXh0ICsgJzwvYT4nO1xuICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmltYWdlID0gZnVuY3Rpb24gaW1hZ2UoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgIGhyZWYgPSBjbGVhblVybCQxKHRoaXMub3B0aW9ucy5zYW5pdGl6ZSwgdGhpcy5vcHRpb25zLmJhc2VVcmwsIGhyZWYpO1xuXG4gICAgICBpZiAoaHJlZiA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dCA9ICc8aW1nIHNyYz1cIicgKyBocmVmICsgJ1wiIGFsdD1cIicgKyB0ZXh0ICsgJ1wiJztcblxuICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgIG91dCArPSAnIHRpdGxlPVwiJyArIHRpdGxlICsgJ1wiJztcbiAgICAgIH1cblxuICAgICAgb3V0ICs9IHRoaXMub3B0aW9ucy54aHRtbCA/ICcvPicgOiAnPic7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH07XG5cbiAgICBfcHJvdG8udGV4dCA9IGZ1bmN0aW9uIHRleHQoX3RleHQpIHtcbiAgICAgIHJldHVybiBfdGV4dDtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFJlbmRlcmVyO1xuICB9KCk7XG5cbiAgLyoqXG4gICAqIFRleHRSZW5kZXJlclxuICAgKiByZXR1cm5zIG9ubHkgdGhlIHRleHR1YWwgcGFydCBvZiB0aGUgdG9rZW5cbiAgICovXG4gIHZhciBUZXh0UmVuZGVyZXJfMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGV4dFJlbmRlcmVyKCkge31cblxuICAgIHZhciBfcHJvdG8gPSBUZXh0UmVuZGVyZXIucHJvdG90eXBlO1xuXG4gICAgLy8gbm8gbmVlZCBmb3IgYmxvY2sgbGV2ZWwgcmVuZGVyZXJzXG4gICAgX3Byb3RvLnN0cm9uZyA9IGZ1bmN0aW9uIHN0cm9uZyh0ZXh0KSB7XG4gICAgICByZXR1cm4gdGV4dDtcbiAgICB9O1xuXG4gICAgX3Byb3RvLmVtID0gZnVuY3Rpb24gZW0odGV4dCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by5jb2Rlc3BhbiA9IGZ1bmN0aW9uIGNvZGVzcGFuKHRleHQpIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG5cbiAgICBfcHJvdG8uZGVsID0gZnVuY3Rpb24gZGVsKHRleHQpIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH07XG5cbiAgICBfcHJvdG8uaHRtbCA9IGZ1bmN0aW9uIGh0bWwodGV4dCkge1xuICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by50ZXh0ID0gZnVuY3Rpb24gdGV4dChfdGV4dCkge1xuICAgICAgcmV0dXJuIF90ZXh0O1xuICAgIH07XG5cbiAgICBfcHJvdG8ubGluayA9IGZ1bmN0aW9uIGxpbmsoaHJlZiwgdGl0bGUsIHRleHQpIHtcbiAgICAgIHJldHVybiAnJyArIHRleHQ7XG4gICAgfTtcblxuICAgIF9wcm90by5pbWFnZSA9IGZ1bmN0aW9uIGltYWdlKGhyZWYsIHRpdGxlLCB0ZXh0KSB7XG4gICAgICByZXR1cm4gJycgKyB0ZXh0O1xuICAgIH07XG5cbiAgICBfcHJvdG8uYnIgPSBmdW5jdGlvbiBicigpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9O1xuXG4gICAgcmV0dXJuIFRleHRSZW5kZXJlcjtcbiAgfSgpO1xuXG4gIC8qKlxuICAgKiBTbHVnZ2VyIGdlbmVyYXRlcyBoZWFkZXIgaWRcbiAgICovXG4gIHZhciBTbHVnZ2VyXzEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNsdWdnZXIoKSB7XG4gICAgICB0aGlzLnNlZW4gPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvID0gU2x1Z2dlci5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCkgLy8gcmVtb3ZlIGh0bWwgdGFnc1xuICAgICAgLnJlcGxhY2UoLzxbIVxcL2Etel0uKj8+L2lnLCAnJykgLy8gcmVtb3ZlIHVud2FudGVkIGNoYXJzXG4gICAgICAucmVwbGFjZSgvW1xcdTIwMDAtXFx1MjA2RlxcdTJFMDAtXFx1MkU3RlxcXFwnIVwiIyQlJigpKissLi86Ozw9Pj9AW1xcXV5ge3x9fl0vZywgJycpLnJlcGxhY2UoL1xccy9nLCAnLScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGaW5kcyB0aGUgbmV4dCBzYWZlICh1bmlxdWUpIHNsdWcgdG8gdXNlXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLmdldE5leHRTYWZlU2x1ZyA9IGZ1bmN0aW9uIGdldE5leHRTYWZlU2x1ZyhvcmlnaW5hbFNsdWcsIGlzRHJ5UnVuKSB7XG4gICAgICB2YXIgc2x1ZyA9IG9yaWdpbmFsU2x1ZztcbiAgICAgIHZhciBvY2N1cmVuY2VBY2N1bXVsYXRvciA9IDA7XG5cbiAgICAgIGlmICh0aGlzLnNlZW4uaGFzT3duUHJvcGVydHkoc2x1ZykpIHtcbiAgICAgICAgb2NjdXJlbmNlQWNjdW11bGF0b3IgPSB0aGlzLnNlZW5bb3JpZ2luYWxTbHVnXTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgb2NjdXJlbmNlQWNjdW11bGF0b3IrKztcbiAgICAgICAgICBzbHVnID0gb3JpZ2luYWxTbHVnICsgJy0nICsgb2NjdXJlbmNlQWNjdW11bGF0b3I7XG4gICAgICAgIH0gd2hpbGUgKHRoaXMuc2Vlbi5oYXNPd25Qcm9wZXJ0eShzbHVnKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNEcnlSdW4pIHtcbiAgICAgICAgdGhpcy5zZWVuW29yaWdpbmFsU2x1Z10gPSBvY2N1cmVuY2VBY2N1bXVsYXRvcjtcbiAgICAgICAgdGhpcy5zZWVuW3NsdWddID0gMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNsdWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgc3RyaW5nIHRvIHVuaXF1ZSBpZFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLmRyeXJ1biBHZW5lcmF0ZXMgdGhlIG5leHQgdW5pcXVlIHNsdWcgd2l0aG91dCB1cGRhdGluZyB0aGUgaW50ZXJuYWwgYWNjdW11bGF0b3IuXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnNsdWcgPSBmdW5jdGlvbiBzbHVnKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNsdWcgPSB0aGlzLnNlcmlhbGl6ZSh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcy5nZXROZXh0U2FmZVNsdWcoc2x1Zywgb3B0aW9ucy5kcnlydW4pO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2x1Z2dlcjtcbiAgfSgpO1xuXG4gIHZhciBkZWZhdWx0cyQ0ID0gZGVmYXVsdHMuZGVmYXVsdHM7XG4gIHZhciB1bmVzY2FwZSQxID0gaGVscGVycy51bmVzY2FwZTtcbiAgLyoqXG4gICAqIFBhcnNpbmcgJiBDb21waWxpbmdcbiAgICovXG5cbiAgdmFyIFBhcnNlcl8xID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYXJzZXIob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCBkZWZhdWx0cyQ0O1xuICAgICAgdGhpcy5vcHRpb25zLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyIHx8IG5ldyBSZW5kZXJlcl8xKCk7XG4gICAgICB0aGlzLnJlbmRlcmVyID0gdGhpcy5vcHRpb25zLnJlbmRlcmVyO1xuICAgICAgdGhpcy5yZW5kZXJlci5vcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdGhpcy50ZXh0UmVuZGVyZXIgPSBuZXcgVGV4dFJlbmRlcmVyXzEoKTtcbiAgICAgIHRoaXMuc2x1Z2dlciA9IG5ldyBTbHVnZ2VyXzEoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhdGljIFBhcnNlIE1ldGhvZFxuICAgICAqL1xuXG5cbiAgICBQYXJzZXIucGFyc2UgPSBmdW5jdGlvbiBwYXJzZSh0b2tlbnMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBwYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZSh0b2tlbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGF0aWMgUGFyc2UgSW5saW5lIE1ldGhvZFxuICAgICAqL1xuICAgIDtcblxuICAgIFBhcnNlci5wYXJzZUlubGluZSA9IGZ1bmN0aW9uIHBhcnNlSW5saW5lKHRva2Vucywgb3B0aW9ucykge1xuICAgICAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucyk7XG4gICAgICByZXR1cm4gcGFyc2VyLnBhcnNlSW5saW5lKHRva2Vucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIExvb3BcbiAgICAgKi9cbiAgICA7XG5cbiAgICB2YXIgX3Byb3RvID0gUGFyc2VyLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlKHRva2VucywgdG9wKSB7XG4gICAgICBpZiAodG9wID09PSB2b2lkIDApIHtcbiAgICAgICAgdG9wID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG91dCA9ICcnLFxuICAgICAgICAgIGksXG4gICAgICAgICAgaixcbiAgICAgICAgICBrLFxuICAgICAgICAgIGwyLFxuICAgICAgICAgIGwzLFxuICAgICAgICAgIHJvdyxcbiAgICAgICAgICBjZWxsLFxuICAgICAgICAgIGhlYWRlcixcbiAgICAgICAgICBib2R5LFxuICAgICAgICAgIHRva2VuLFxuICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgc3RhcnQsXG4gICAgICAgICAgbG9vc2UsXG4gICAgICAgICAgaXRlbUJvZHksXG4gICAgICAgICAgaXRlbSxcbiAgICAgICAgICBjaGVja2VkLFxuICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgY2hlY2tib3g7XG4gICAgICB2YXIgbCA9IHRva2Vucy5sZW5ndGg7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnc3BhY2UnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2hyJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaHIoKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdoZWFkaW5nJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIuaGVhZGluZyh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucyksIHRva2VuLmRlcHRoLCB1bmVzY2FwZSQxKHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zLCB0aGlzLnRleHRSZW5kZXJlcikpLCB0aGlzLnNsdWdnZXIpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2NvZGUnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5jb2RlKHRva2VuLnRleHQsIHRva2VuLmxhbmcsIHRva2VuLmVzY2FwZWQpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaGVhZGVyID0gJyc7IC8vIGhlYWRlclxuXG4gICAgICAgICAgICAgIGNlbGwgPSAnJztcbiAgICAgICAgICAgICAgbDIgPSB0b2tlbi5oZWFkZXIubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgY2VsbCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlY2VsbCh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2Vucy5oZWFkZXJbal0pLCB7XG4gICAgICAgICAgICAgICAgICBoZWFkZXI6IHRydWUsXG4gICAgICAgICAgICAgICAgICBhbGlnbjogdG9rZW4uYWxpZ25bal1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGhlYWRlciArPSB0aGlzLnJlbmRlcmVyLnRhYmxlcm93KGNlbGwpO1xuICAgICAgICAgICAgICBib2R5ID0gJyc7XG4gICAgICAgICAgICAgIGwyID0gdG9rZW4uY2VsbHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsMjsgaisrKSB7XG4gICAgICAgICAgICAgICAgcm93ID0gdG9rZW4udG9rZW5zLmNlbGxzW2pdO1xuICAgICAgICAgICAgICAgIGNlbGwgPSAnJztcbiAgICAgICAgICAgICAgICBsMyA9IHJvdy5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgbDM7IGsrKykge1xuICAgICAgICAgICAgICAgICAgY2VsbCArPSB0aGlzLnJlbmRlcmVyLnRhYmxlY2VsbCh0aGlzLnBhcnNlSW5saW5lKHJvd1trXSksIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgYWxpZ246IHRva2VuLmFsaWduW2tdXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBib2R5ICs9IHRoaXMucmVuZGVyZXIudGFibGVyb3coY2VsbCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci50YWJsZShoZWFkZXIsIGJvZHkpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2Jsb2NrcXVvdGUnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBib2R5ID0gdGhpcy5wYXJzZSh0b2tlbi50b2tlbnMpO1xuICAgICAgICAgICAgICBvdXQgKz0gdGhpcy5yZW5kZXJlci5ibG9ja3F1b3RlKGJvZHkpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvcmRlcmVkID0gdG9rZW4ub3JkZXJlZDtcbiAgICAgICAgICAgICAgc3RhcnQgPSB0b2tlbi5zdGFydDtcbiAgICAgICAgICAgICAgbG9vc2UgPSB0b2tlbi5sb29zZTtcbiAgICAgICAgICAgICAgbDIgPSB0b2tlbi5pdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICAgIGJvZHkgPSAnJztcblxuICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbDI7IGorKykge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSB0b2tlbi5pdGVtc1tqXTtcbiAgICAgICAgICAgICAgICBjaGVja2VkID0gaXRlbS5jaGVja2VkO1xuICAgICAgICAgICAgICAgIHRhc2sgPSBpdGVtLnRhc2s7XG4gICAgICAgICAgICAgICAgaXRlbUJvZHkgPSAnJztcblxuICAgICAgICAgICAgICAgIGlmIChpdGVtLnRhc2spIHtcbiAgICAgICAgICAgICAgICAgIGNoZWNrYm94ID0gdGhpcy5yZW5kZXJlci5jaGVja2JveChjaGVja2VkKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKGxvb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLnRva2Vucy5sZW5ndGggPiAwICYmIGl0ZW0udG9rZW5zWzBdLnR5cGUgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zWzBdLnRleHQgPSBjaGVja2JveCArICcgJyArIGl0ZW0udG9rZW5zWzBdLnRleHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS50b2tlbnNbMF0udG9rZW5zICYmIGl0ZW0udG9rZW5zWzBdLnRva2Vucy5sZW5ndGggPiAwICYmIGl0ZW0udG9rZW5zWzBdLnRva2Vuc1swXS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udG9rZW5zWzBdLnRva2Vuc1swXS50ZXh0ID0gY2hlY2tib3ggKyAnICcgKyBpdGVtLnRva2Vuc1swXS50b2tlbnNbMF0udGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgaXRlbS50b2tlbnMudW5zaGlmdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjaGVja2JveFxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVtQm9keSArPSBjaGVja2JveDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpdGVtQm9keSArPSB0aGlzLnBhcnNlKGl0ZW0udG9rZW5zLCBsb29zZSk7XG4gICAgICAgICAgICAgICAgYm9keSArPSB0aGlzLnJlbmRlcmVyLmxpc3RpdGVtKGl0ZW1Cb2R5LCB0YXNrLCBjaGVja2VkKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmxpc3QoYm9keSwgb3JkZXJlZCwgc3RhcnQpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyBUT0RPIHBhcnNlIGlubGluZSBjb250ZW50IGlmIHBhcmFtZXRlciBtYXJrZG93bj0xXG4gICAgICAgICAgICAgIG91dCArPSB0aGlzLnJlbmRlcmVyLmh0bWwodG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAncGFyYWdyYXBoJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHRoaXMucmVuZGVyZXIucGFyYWdyYXBoKHRoaXMucGFyc2VJbmxpbmUodG9rZW4udG9rZW5zKSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGJvZHkgPSB0b2tlbi50b2tlbnMgPyB0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucykgOiB0b2tlbi50ZXh0O1xuXG4gICAgICAgICAgICAgIHdoaWxlIChpICsgMSA8IGwgJiYgdG9rZW5zW2kgKyAxXS50eXBlID09PSAndGV4dCcpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1srK2ldO1xuICAgICAgICAgICAgICAgIGJvZHkgKz0gJ1xcbicgKyAodG9rZW4udG9rZW5zID8gdGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMpIDogdG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvdXQgKz0gdG9wID8gdGhpcy5yZW5kZXJlci5wYXJhZ3JhcGgoYm9keSkgOiBib2R5O1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBlcnJNc2cgPSAnVG9rZW4gd2l0aCBcIicgKyB0b2tlbi50eXBlICsgJ1wiIHR5cGUgd2FzIG5vdCBmb3VuZC4nO1xuXG4gICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIElubGluZSBUb2tlbnNcbiAgICAgKi9cbiAgICA7XG5cbiAgICBfcHJvdG8ucGFyc2VJbmxpbmUgPSBmdW5jdGlvbiBwYXJzZUlubGluZSh0b2tlbnMsIHJlbmRlcmVyKSB7XG4gICAgICByZW5kZXJlciA9IHJlbmRlcmVyIHx8IHRoaXMucmVuZGVyZXI7XG4gICAgICB2YXIgb3V0ID0gJycsXG4gICAgICAgICAgaSxcbiAgICAgICAgICB0b2tlbjtcbiAgICAgIHZhciBsID0gdG9rZW5zLmxlbmd0aDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgICBjYXNlICdlc2NhcGUnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvdXQgKz0gcmVuZGVyZXIudGV4dCh0b2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLmh0bWwodG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnbGluayc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5saW5rKHRva2VuLmhyZWYsIHRva2VuLnRpdGxlLCB0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdpbWFnZSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5pbWFnZSh0b2tlbi5ocmVmLCB0b2tlbi50aXRsZSwgdG9rZW4udGV4dCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAnc3Ryb25nJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3V0ICs9IHJlbmRlcmVyLnN0cm9uZyh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdlbSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5lbSh0aGlzLnBhcnNlSW5saW5lKHRva2VuLnRva2VucywgcmVuZGVyZXIpKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdjb2Rlc3Bhbic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5jb2Rlc3Bhbih0b2tlbi50ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdicic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5icigpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2RlbCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci5kZWwodGhpcy5wYXJzZUlubGluZSh0b2tlbi50b2tlbnMsIHJlbmRlcmVyKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG91dCArPSByZW5kZXJlci50ZXh0KHRva2VuLnRleHQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBlcnJNc2cgPSAnVG9rZW4gd2l0aCBcIicgKyB0b2tlbi50eXBlICsgJ1wiIHR5cGUgd2FzIG5vdCBmb3VuZC4nO1xuXG4gICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJNc2cpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcblxuICAgIHJldHVybiBQYXJzZXI7XG4gIH0oKTtcblxuICB2YXIgbWVyZ2UkMiA9IGhlbHBlcnMubWVyZ2UsXG4gICAgICBjaGVja1Nhbml0aXplRGVwcmVjYXRpb24kMSA9IGhlbHBlcnMuY2hlY2tTYW5pdGl6ZURlcHJlY2F0aW9uLFxuICAgICAgZXNjYXBlJDIgPSBoZWxwZXJzLmVzY2FwZTtcbiAgdmFyIGdldERlZmF1bHRzID0gZGVmYXVsdHMuZ2V0RGVmYXVsdHMsXG4gICAgICBjaGFuZ2VEZWZhdWx0cyA9IGRlZmF1bHRzLmNoYW5nZURlZmF1bHRzLFxuICAgICAgZGVmYXVsdHMkNSA9IGRlZmF1bHRzLmRlZmF1bHRzO1xuICAvKipcbiAgICogTWFya2VkXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG1hcmtlZChzcmMsIG9wdCwgY2FsbGJhY2spIHtcbiAgICAvLyB0aHJvdyBlcnJvciBpbiBjYXNlIG9mIG5vbiBzdHJpbmcgaW5wdXRcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3VuZGVmaW5lZCcgfHwgc3JjID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcmtlZCgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkIG9yIG51bGwnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFya2VkKCk6IGlucHV0IHBhcmFtZXRlciBpcyBvZiB0eXBlICcgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3JjKSArICcsIHN0cmluZyBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdDtcbiAgICAgIG9wdCA9IG51bGw7XG4gICAgfVxuXG4gICAgb3B0ID0gbWVyZ2UkMih7fSwgbWFya2VkLmRlZmF1bHRzLCBvcHQgfHwge30pO1xuICAgIGNoZWNrU2FuaXRpemVEZXByZWNhdGlvbiQxKG9wdCk7XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHZhciBoaWdobGlnaHQgPSBvcHQuaGlnaGxpZ2h0O1xuICAgICAgdmFyIHRva2VucztcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdG9rZW5zID0gTGV4ZXJfMS5sZXgoc3JjLCBvcHQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkb25lID0gZnVuY3Rpb24gZG9uZShlcnIpIHtcbiAgICAgICAgdmFyIG91dDtcblxuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvdXQgPSBQYXJzZXJfMS5wYXJzZSh0b2tlbnMsIG9wdCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyID0gZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBvcHQuaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0O1xuICAgICAgICByZXR1cm4gZXJyID8gY2FsbGJhY2soZXJyKSA6IGNhbGxiYWNrKG51bGwsIG91dCk7XG4gICAgICB9O1xuXG4gICAgICBpZiAoIWhpZ2hsaWdodCB8fCBoaWdobGlnaHQubGVuZ3RoIDwgMykge1xuICAgICAgICByZXR1cm4gZG9uZSgpO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgb3B0LmhpZ2hsaWdodDtcbiAgICAgIGlmICghdG9rZW5zLmxlbmd0aCkgcmV0dXJuIGRvbmUoKTtcbiAgICAgIHZhciBwZW5kaW5nID0gMDtcbiAgICAgIG1hcmtlZC53YWxrVG9rZW5zKHRva2VucywgZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIGlmICh0b2tlbi50eXBlID09PSAnY29kZScpIHtcbiAgICAgICAgICBwZW5kaW5nKys7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBoaWdobGlnaHQodG9rZW4udGV4dCwgdG9rZW4ubGFuZywgZnVuY3Rpb24gKGVyciwgY29kZSkge1xuICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbmUoZXJyKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChjb2RlICE9IG51bGwgJiYgY29kZSAhPT0gdG9rZW4udGV4dCkge1xuICAgICAgICAgICAgICAgIHRva2VuLnRleHQgPSBjb2RlO1xuICAgICAgICAgICAgICAgIHRva2VuLmVzY2FwZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcGVuZGluZy0tO1xuXG4gICAgICAgICAgICAgIGlmIChwZW5kaW5nID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChwZW5kaW5nID09PSAwKSB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICB2YXIgX3Rva2VucyA9IExleGVyXzEubGV4KHNyYywgb3B0KTtcblxuICAgICAgaWYgKG9wdC53YWxrVG9rZW5zKSB7XG4gICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKF90b2tlbnMsIG9wdC53YWxrVG9rZW5zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFBhcnNlcl8xLnBhcnNlKF90b2tlbnMsIG9wdCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5tZXNzYWdlICs9ICdcXG5QbGVhc2UgcmVwb3J0IHRoaXMgdG8gaHR0cHM6Ly9naXRodWIuY29tL21hcmtlZGpzL21hcmtlZC4nO1xuXG4gICAgICBpZiAob3B0LnNpbGVudCkge1xuICAgICAgICByZXR1cm4gJzxwPkFuIGVycm9yIG9jY3VycmVkOjwvcD48cHJlPicgKyBlc2NhcGUkMihlLm1lc3NhZ2UgKyAnJywgdHJ1ZSkgKyAnPC9wcmU+JztcbiAgICAgIH1cblxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE9wdGlvbnNcbiAgICovXG5cblxuICBtYXJrZWQub3B0aW9ucyA9IG1hcmtlZC5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdCkge1xuICAgIG1lcmdlJDIobWFya2VkLmRlZmF1bHRzLCBvcHQpO1xuICAgIGNoYW5nZURlZmF1bHRzKG1hcmtlZC5kZWZhdWx0cyk7XG4gICAgcmV0dXJuIG1hcmtlZDtcbiAgfTtcblxuICBtYXJrZWQuZ2V0RGVmYXVsdHMgPSBnZXREZWZhdWx0cztcbiAgbWFya2VkLmRlZmF1bHRzID0gZGVmYXVsdHMkNTtcbiAgLyoqXG4gICAqIFVzZSBFeHRlbnNpb25cbiAgICovXG5cbiAgbWFya2VkLnVzZSA9IGZ1bmN0aW9uIChleHRlbnNpb24pIHtcbiAgICB2YXIgb3B0cyA9IG1lcmdlJDIoe30sIGV4dGVuc2lvbik7XG5cbiAgICBpZiAoZXh0ZW5zaW9uLnJlbmRlcmVyKSB7XG4gICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSBtYXJrZWQuZGVmYXVsdHMucmVuZGVyZXIgfHwgbmV3IFJlbmRlcmVyXzEoKTtcblxuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChwcm9wKSB7XG4gICAgICAgICAgdmFyIHByZXZSZW5kZXJlciA9IHJlbmRlcmVyW3Byb3BdO1xuXG4gICAgICAgICAgcmVuZGVyZXJbcHJvcF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHJldCA9IGV4dGVuc2lvbi5yZW5kZXJlcltwcm9wXS5hcHBseShyZW5kZXJlciwgYXJncyk7XG5cbiAgICAgICAgICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgIHJldCA9IHByZXZSZW5kZXJlci5hcHBseShyZW5kZXJlciwgYXJncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGV4dGVuc2lvbi5yZW5kZXJlcikge1xuICAgICAgICAgIF9sb29wKHByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgb3B0cy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgfSkoKTtcbiAgICB9XG5cbiAgICBpZiAoZXh0ZW5zaW9uLnRva2VuaXplcikge1xuICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHRva2VuaXplciA9IG1hcmtlZC5kZWZhdWx0cy50b2tlbml6ZXIgfHwgbmV3IFRva2VuaXplcl8xKCk7XG5cbiAgICAgICAgdmFyIF9sb29wMiA9IGZ1bmN0aW9uIF9sb29wMihwcm9wKSB7XG4gICAgICAgICAgdmFyIHByZXZUb2tlbml6ZXIgPSB0b2tlbml6ZXJbcHJvcF07XG5cbiAgICAgICAgICB0b2tlbml6ZXJbcHJvcF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmV0ID0gZXh0ZW5zaW9uLnRva2VuaXplcltwcm9wXS5hcHBseSh0b2tlbml6ZXIsIGFyZ3MpO1xuXG4gICAgICAgICAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICByZXQgPSBwcmV2VG9rZW5pemVyLmFwcGx5KHRva2VuaXplciwgYXJncyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgfTtcblxuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGV4dGVuc2lvbi50b2tlbml6ZXIpIHtcbiAgICAgICAgICBfbG9vcDIocHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBvcHRzLnRva2VuaXplciA9IHRva2VuaXplcjtcbiAgICAgIH0pKCk7XG4gICAgfVxuXG4gICAgaWYgKGV4dGVuc2lvbi53YWxrVG9rZW5zKSB7XG4gICAgICB2YXIgd2Fsa1Rva2VucyA9IG1hcmtlZC5kZWZhdWx0cy53YWxrVG9rZW5zO1xuXG4gICAgICBvcHRzLndhbGtUb2tlbnMgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgZXh0ZW5zaW9uLndhbGtUb2tlbnModG9rZW4pO1xuXG4gICAgICAgIGlmICh3YWxrVG9rZW5zKSB7XG4gICAgICAgICAgd2Fsa1Rva2Vucyh0b2tlbik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgbWFya2VkLnNldE9wdGlvbnMob3B0cyk7XG4gIH07XG4gIC8qKlxuICAgKiBSdW4gY2FsbGJhY2sgZm9yIGV2ZXJ5IHRva2VuXG4gICAqL1xuXG5cbiAgbWFya2VkLndhbGtUb2tlbnMgPSBmdW5jdGlvbiAodG9rZW5zLCBjYWxsYmFjaykge1xuICAgIGZvciAodmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyTG9vc2UodG9rZW5zKSwgX3N0ZXA7ICEoX3N0ZXAgPSBfaXRlcmF0b3IoKSkuZG9uZTspIHtcbiAgICAgIHZhciB0b2tlbiA9IF9zdGVwLnZhbHVlO1xuICAgICAgY2FsbGJhY2sodG9rZW4pO1xuXG4gICAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHRva2VuLnRva2Vucy5oZWFkZXIpLCBfc3RlcDI7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgY2VsbCA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICAgICAgbWFya2VkLndhbGtUb2tlbnMoY2VsbCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXJMb29zZSh0b2tlbi50b2tlbnMuY2VsbHMpLCBfc3RlcDM7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMygpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgcm93ID0gX3N0ZXAzLnZhbHVlO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlckxvb3NlKHJvdyksIF9zdGVwNDsgIShfc3RlcDQgPSBfaXRlcmF0b3I0KCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9jZWxsID0gX3N0ZXA0LnZhbHVlO1xuICAgICAgICAgICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKF9jZWxsLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKHRva2VuLml0ZW1zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAodG9rZW4udG9rZW5zKSB7XG4gICAgICAgICAgICAgIG1hcmtlZC53YWxrVG9rZW5zKHRva2VuLnRva2VucywgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8qKlxuICAgKiBQYXJzZSBJbmxpbmVcbiAgICovXG5cblxuICBtYXJrZWQucGFyc2VJbmxpbmUgPSBmdW5jdGlvbiAoc3JjLCBvcHQpIHtcbiAgICAvLyB0aHJvdyBlcnJvciBpbiBjYXNlIG9mIG5vbiBzdHJpbmcgaW5wdXRcbiAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ3VuZGVmaW5lZCcgfHwgc3JjID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcmtlZC5wYXJzZUlubGluZSgpOiBpbnB1dCBwYXJhbWV0ZXIgaXMgdW5kZWZpbmVkIG9yIG51bGwnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbWFya2VkLnBhcnNlSW5saW5lKCk6IGlucHV0IHBhcmFtZXRlciBpcyBvZiB0eXBlICcgKyBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3JjKSArICcsIHN0cmluZyBleHBlY3RlZCcpO1xuICAgIH1cblxuICAgIG9wdCA9IG1lcmdlJDIoe30sIG1hcmtlZC5kZWZhdWx0cywgb3B0IHx8IHt9KTtcbiAgICBjaGVja1Nhbml0aXplRGVwcmVjYXRpb24kMShvcHQpO1xuXG4gICAgdHJ5IHtcbiAgICAgIHZhciB0b2tlbnMgPSBMZXhlcl8xLmxleElubGluZShzcmMsIG9wdCk7XG5cbiAgICAgIGlmIChvcHQud2Fsa1Rva2Vucykge1xuICAgICAgICBtYXJrZWQud2Fsa1Rva2Vucyh0b2tlbnMsIG9wdC53YWxrVG9rZW5zKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFBhcnNlcl8xLnBhcnNlSW5saW5lKHRva2Vucywgb3B0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlLm1lc3NhZ2UgKz0gJ1xcblBsZWFzZSByZXBvcnQgdGhpcyB0byBodHRwczovL2dpdGh1Yi5jb20vbWFya2VkanMvbWFya2VkLic7XG5cbiAgICAgIGlmIChvcHQuc2lsZW50KSB7XG4gICAgICAgIHJldHVybiAnPHA+QW4gZXJyb3Igb2NjdXJyZWQ6PC9wPjxwcmU+JyArIGVzY2FwZSQyKGUubWVzc2FnZSArICcnLCB0cnVlKSArICc8L3ByZT4nO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfTtcbiAgLyoqXG4gICAqIEV4cG9zZVxuICAgKi9cblxuXG4gIG1hcmtlZC5QYXJzZXIgPSBQYXJzZXJfMTtcbiAgbWFya2VkLnBhcnNlciA9IFBhcnNlcl8xLnBhcnNlO1xuICBtYXJrZWQuUmVuZGVyZXIgPSBSZW5kZXJlcl8xO1xuICBtYXJrZWQuVGV4dFJlbmRlcmVyID0gVGV4dFJlbmRlcmVyXzE7XG4gIG1hcmtlZC5MZXhlciA9IExleGVyXzE7XG4gIG1hcmtlZC5sZXhlciA9IExleGVyXzEubGV4O1xuICBtYXJrZWQuVG9rZW5pemVyID0gVG9rZW5pemVyXzE7XG4gIG1hcmtlZC5TbHVnZ2VyID0gU2x1Z2dlcl8xO1xuICBtYXJrZWQucGFyc2UgPSBtYXJrZWQ7XG4gIHZhciBtYXJrZWRfMSA9IG1hcmtlZDtcblxuICByZXR1cm4gbWFya2VkXzE7XG5cbn0pKSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/marked/lib/marked.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3dlYnBhY2svYnVpbGRpbi9nbG9iYWwuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/global.js\n");

/***/ }),

/***/ "./resources/js/set-editor-flashcard-manager.js":
/*!******************************************************!*\
  !*** ./resources/js/set-editor-flashcard-manager.js ***!
  \******************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dompurify */ \"./node_modules/dompurify/dist/purify.js\");\n/* harmony import */ var dompurify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dompurify__WEBPACK_IMPORTED_MODULE_0__);\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n\n\nvar marked = __webpack_require__(/*! marked */ \"./node_modules/marked/lib/marked.js\");\n\nvar markedImages = __webpack_require__(/*! marked-images */ \"./node_modules/marked-images/marked-images.js\");\n\nmarked.use(markedImages()); // This file contains all the JS logic to interact with the set editor for\n// editing the count of flashcards and the positioning of the flashcard editor.\n\nvar easymde_textareas = [];\nvar flashcard_toolbar = [{\n  name: \"bold\",\n  action: EasyMDE.toggleBold,\n  className: \"mdi mdi-18px mdi-format-bold\",\n  title: \"Bold\"\n}, {\n  name: \"italic\",\n  action: EasyMDE.toggleItalic,\n  className: \"mdi mdi-18px mdi-format-italic\",\n  title: \"Italic\"\n}, {\n  name: \"heading-smaller\",\n  action: EasyMDE.toggleHeadingSmaller,\n  className: \"mdi mdi-18px mdi-format-header-decrease\",\n  title: \"Smaller Heading\"\n}, {\n  name: \"heading-bigger\",\n  action: EasyMDE.toggleHeadingBigger,\n  className: \"mdi mdi-18px mdi-format-header-increase\",\n  title: \"Bigger Heading\"\n}, \"|\", {\n  name: \"horizontal-rule\",\n  action: EasyMDE.drawHorizontalRule,\n  className: \"mdi mdi-18px mdi-minus\",\n  title: \"Insert Horizontal Line\"\n}, {\n  name: \"quote\",\n  action: EasyMDE.toggleBlockquote,\n  className: \"mdi mdi-18px mdi-format-quote-open\",\n  title: \"Quote\"\n}, {\n  name: \"unordered-list\",\n  action: EasyMDE.toggleUnorderedList,\n  className: \"mdi mdi-18px mdi-format-list-bulleted\",\n  title: \"Generic List\"\n}, {\n  name: \"ordered-list\",\n  action: EasyMDE.toggleOrderedList,\n  className: \"mdi mdi-18px mdi-format-list-numbered\",\n  title: \"Numbered List\"\n}, {\n  name: \"table\",\n  action: EasyMDE.drawTable,\n  className: \"mdi mdi-18px mdi-table\",\n  title: \"Insert Table\"\n}, \"|\", {\n  name: \"link\",\n  action: EasyMDE.drawLink,\n  className: \"mdi mdi-18px mdi-link\",\n  title: \"Create Link\"\n}, {\n  name: \"image\",\n  action: EasyMDE.drawImage,\n  className: \"mdi mdi-18px mdi-image-area\",\n  title: \"Insert Image\"\n}, {\n  name: \"preview\",\n  action: EasyMDE.togglePreview,\n  noDisable: true,\n  className: \"mdi mdi-18px mdi-eye-outline\",\n  title: \"Toggle Preview\"\n}]; // This function updates the page adding new easyMDE editors when there is a need\n// for one, otherwise it hopefully shouldn't run. There is a list that checks\n// that one is already an easyMDE called easymde_textareas it uses.\n// Essentailly: Adds EasyMDE editors to newly inserted textareas to dom.\n\nfunction flashcard_easyMDE_watch() {\n  var set_editor_parent = document.getElementById(\"set-editors\");\n  var all_textareas = set_editor_parent.getElementsByClassName(\"easy-markdown-editor-needed\");\n\n  var _iterator = _createForOfIteratorHelper(all_textareas),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var textarea = _step.value;\n\n      if (!(easymde_textareas.indexOf(textarea.id) >= 0)) {\n        // If the current textarea is not in the list of easymde_textareas.\n        easymde_textareas.push(textarea.id);\n        new EasyMDE({\n          autofocus: true,\n          autoDownloadFontAwesome: false,\n          toolbar: flashcard_toolbar,\n          element: document.getElementById(textarea.id),\n          previewRender: function previewRender(plainText) {\n            return marked(\"<center>\\n\" + plainText + \"</center>\"); // Returns HTML from a custom parser\n          },\n          renderingConfig: {\n            sanitizerFunction: function sanitizerFunction(renderedHTML) {\n              return dompurify__WEBPACK_IMPORTED_MODULE_0___default.a.sanitize(renderedHTML);\n            }\n          }\n        });\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\nfunction remove_flashcard_by_identifier(identifier) {\n  if (easymde_textareas.length != 2) {\n    if (document.getElementById(\"flashcard-\" + identifier + \"-container\")) {\n      document.getElementById(\"flashcard-\" + identifier + \"-container\").remove();\n      var index = easymde_textareas.indexOf(\"flashcard-\" + identifier + \"-front\");\n\n      if (index !== -1) {\n        easymde_textareas.splice(index, 1);\n      }\n\n      var index = easymde_textareas.indexOf(\"flashcard-\" + identifier + \"-back\");\n\n      if (index !== -1) {\n        easymde_textareas.splice(index, 1);\n      }\n    }\n  } else {\n    $('.toast-body').text(\"\");\n    $('.toast-body').append(\"You cannot remove the only flashcard!\");\n    $('.toast').toast('show');\n  }\n}\n\nfunction add_flashcard_by_identifier(identifier) {\n  if (identifier > 0) {\n    var previous_flashcard = document.getElementById(\"flashcard-\" + identifier + \"-container\");\n    var new_card_id = identifier + 1;\n    var new_dom_code = \"<div class=\\\"flashcard-container\\\" id=\\\"flashcard-\" + new_card_id + \"-container\\\"><hr><h3 class=\\\"flashcard-title-front\\\">Flashcard \" + new_card_id + \" - Front</h3><textarea class=\\\"easy-markdown-editor-needed  flashcard-front\\\" max=\\\"300\\\" id=\\\"flashcard-\" + new_card_id + \"-front\\\" name=\\\"flashcard-\" + new_card_id + \"-front\\\"></textarea><h3 class=\\\"flashcard-title-back\\\">Flashcard \" + new_card_id + \" - Back</h3><textarea class=\\\"easy-markdown-editor-needed  flashcard-back\\\" max=\\\"300\\\" id=\\\"flashcard-\" + new_card_id + \"-back\\\" name=\\\"flashcard-\" + new_card_id + \"-back\\\"></textarea><div class=\\\"d-flex justify-content-center\\\"><button type=\\\"button\\\" class=\\\"btn btn-outline-info btn-sm py-1 flashcard-remove-button\\\" id=\\\"\" + new_card_id + \"\\\">Remove Flashcard \" + new_card_id + \"</button></div></div>\";\n    previous_flashcard.insertAdjacentHTML('afterend', new_dom_code);\n    recently_inserted_remove_button = previous_flashcard.nextSibling.querySelectorAll(\".flashcard-remove-button:last-child\");\n    flashcard_easyMDE_watch();\n    recently_inserted_remove_button[0].addEventListener(\"click\", function (event) {\n      remove_flashcard_by_identifier(this.id);\n      order_watch();\n    });\n    update_flashcard_count();\n  }\n} // This function looks at and corrects any changes to the list of flashcards\n// because the user may wish to delete flashcards at any time, this function\n// updates the list so that there is always a consecutive process when the\n// cards are submitted and updated by the user.\n\n\nfunction order_watch() {\n  var cards = document.getElementsByClassName(\"flashcard-container\");\n  easymde_textareas = [];\n\n  for (var i = 0; i < cards.length; i++) {\n    var current_card_index = i + 1;\n    cards[i].setAttribute(\"id\", \"flashcard-\" + current_card_index + \"-container\");\n    var front_title = $(cards[i]).find(\".flashcard-title-front\")[0];\n    var front_textarea = $(cards[i]).find(\".flashcard-front\")[0];\n    var back_title = $(cards[i]).find(\".flashcard-title-back\")[0];\n    var back_textarea = $(cards[i]).find(\".flashcard-back\")[0];\n    var del_button = $(cards[i]).find(\".flashcard-remove-button\")[0];\n    front_title.innerHTML = \"Flashcard \" + current_card_index + \" - Front\";\n    back_title.innerHTML = \"Flashcard \" + current_card_index + \" - Back\";\n    front_textarea.setAttribute(\"id\", \"flashcard-\" + current_card_index + \"-front\");\n    back_textarea.setAttribute(\"id\", \"flashcard-\" + current_card_index + \"-back\");\n    front_textarea.setAttribute(\"name\", \"flashcard-\" + current_card_index + \"-front\");\n    back_textarea.setAttribute(\"name\", \"flashcard-\" + current_card_index + \"-back\");\n    del_button.setAttribute(\"id\", current_card_index);\n    del_button.innerHTML = \"Remove Flashcard \" + current_card_index; // Update master list of textareas for add and remove functions.\n\n    easymde_textareas.push(\"flashcard-\" + current_card_index + \"-front\");\n    easymde_textareas.push(\"flashcard-\" + current_card_index + \"-back\");\n  } // Update Count\n\n\n  update_flashcard_count();\n}\n\nfunction update_flashcard_count() {\n  var cards = document.getElementsByClassName(\"flashcard-container\");\n  $('.flashcard-count').html(cards.length + \" flashcards in set.\");\n}\n\n$('document').ready(function () {\n  $('.flashcard-remove-button').click(function () {\n    remove_flashcard_by_identifier(this.id);\n    order_watch();\n  });\n  $('#new-flashcard').click(function () {\n    add_flashcard_by_identifier(easymde_textareas.length / 2);\n    flashcard_easyMDE_watch();\n  });\n  $('#save-flashcards').click(function () {\n    document.getElementById('flashcards').submit();\n  }); // Add easyMDE TextAreas to all boxes that need them.\n\n  flashcard_easyMDE_watch(); // Fix any order shenanigans.\n\n  order_watch(); // Set flashcard count to finish.\n\n  update_flashcard_count();\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvc2V0LWVkaXRvci1mbGFzaGNhcmQtbWFuYWdlci5qcz9iMjg2Il0sIm5hbWVzIjpbIm1hcmtlZCIsInJlcXVpcmUiLCJtYXJrZWRJbWFnZXMiLCJ1c2UiLCJlYXN5bWRlX3RleHRhcmVhcyIsImZsYXNoY2FyZF90b29sYmFyIiwibmFtZSIsImFjdGlvbiIsIkVhc3lNREUiLCJ0b2dnbGVCb2xkIiwiY2xhc3NOYW1lIiwidGl0bGUiLCJ0b2dnbGVJdGFsaWMiLCJ0b2dnbGVIZWFkaW5nU21hbGxlciIsInRvZ2dsZUhlYWRpbmdCaWdnZXIiLCJkcmF3SG9yaXpvbnRhbFJ1bGUiLCJ0b2dnbGVCbG9ja3F1b3RlIiwidG9nZ2xlVW5vcmRlcmVkTGlzdCIsInRvZ2dsZU9yZGVyZWRMaXN0IiwiZHJhd1RhYmxlIiwiZHJhd0xpbmsiLCJkcmF3SW1hZ2UiLCJ0b2dnbGVQcmV2aWV3Iiwibm9EaXNhYmxlIiwiZmxhc2hjYXJkX2Vhc3lNREVfd2F0Y2giLCJzZXRfZWRpdG9yX3BhcmVudCIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJhbGxfdGV4dGFyZWFzIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsInRleHRhcmVhIiwiaW5kZXhPZiIsImlkIiwicHVzaCIsImF1dG9mb2N1cyIsImF1dG9Eb3dubG9hZEZvbnRBd2Vzb21lIiwidG9vbGJhciIsImVsZW1lbnQiLCJwcmV2aWV3UmVuZGVyIiwicGxhaW5UZXh0IiwicmVuZGVyaW5nQ29uZmlnIiwic2FuaXRpemVyRnVuY3Rpb24iLCJyZW5kZXJlZEhUTUwiLCJET01QdXJpZnkiLCJzYW5pdGl6ZSIsInJlbW92ZV9mbGFzaGNhcmRfYnlfaWRlbnRpZmllciIsImlkZW50aWZpZXIiLCJsZW5ndGgiLCJyZW1vdmUiLCJpbmRleCIsInNwbGljZSIsIiQiLCJ0ZXh0IiwiYXBwZW5kIiwidG9hc3QiLCJhZGRfZmxhc2hjYXJkX2J5X2lkZW50aWZpZXIiLCJwcmV2aW91c19mbGFzaGNhcmQiLCJuZXdfY2FyZF9pZCIsIm5ld19kb21fY29kZSIsImluc2VydEFkamFjZW50SFRNTCIsInJlY2VudGx5X2luc2VydGVkX3JlbW92ZV9idXR0b24iLCJuZXh0U2libGluZyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJvcmRlcl93YXRjaCIsInVwZGF0ZV9mbGFzaGNhcmRfY291bnQiLCJjYXJkcyIsImkiLCJjdXJyZW50X2NhcmRfaW5kZXgiLCJzZXRBdHRyaWJ1dGUiLCJmcm9udF90aXRsZSIsImZpbmQiLCJmcm9udF90ZXh0YXJlYSIsImJhY2tfdGl0bGUiLCJiYWNrX3RleHRhcmVhIiwiZGVsX2J1dHRvbiIsImlubmVySFRNTCIsImh0bWwiLCJyZWFkeSIsImNsaWNrIiwic3VibWl0Il0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTs7QUFFQSxJQUFJQSxNQUFNLEdBQUdDLG1CQUFPLENBQUMsbURBQUQsQ0FBcEI7O0FBRUEsSUFBSUMsWUFBWSxHQUFHRCxtQkFBTyxDQUFDLG9FQUFELENBQTFCOztBQUVBRCxNQUFNLENBQUNHLEdBQVAsQ0FBV0QsWUFBWSxFQUF2QixFLENBR0E7QUFDQTs7QUFFQSxJQUFJRSxpQkFBaUIsR0FBRyxFQUF4QjtBQUVBLElBQUlDLGlCQUFpQixHQUFHLENBQUM7QUFDakJDLE1BQUksRUFBRSxNQURXO0FBRWpCQyxRQUFNLEVBQUVDLE9BQU8sQ0FBQ0MsVUFGQztBQUdqQkMsV0FBUyxFQUFFLDhCQUhNO0FBSWpCQyxPQUFLLEVBQUU7QUFKVSxDQUFELEVBTXBCO0FBQ0lMLE1BQUksRUFBRSxRQURWO0FBRUlDLFFBQU0sRUFBRUMsT0FBTyxDQUFDSSxZQUZwQjtBQUdJRixXQUFTLEVBQUUsZ0NBSGY7QUFJSUMsT0FBSyxFQUFFO0FBSlgsQ0FOb0IsRUFhcEI7QUFDSUwsTUFBSSxFQUFFLGlCQURWO0FBRUlDLFFBQU0sRUFBRUMsT0FBTyxDQUFDSyxvQkFGcEI7QUFHSUgsV0FBUyxFQUFFLHlDQUhmO0FB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QixLQUF0QixDQUE0QixZQUFXO0FBQ25DdEQsWUFBUSxDQUFDQyxjQUFULENBQXdCLFlBQXhCLEVBQXNDc0QsTUFBdEM7QUFDSCxHQUZELEVBWjJCLENBZ0IzQjs7QUFDQXpELHlCQUF1QixHQWpCSSxDQW1CM0I7O0FBQ0F5QyxhQUFXLEdBcEJnQixDQXNCM0I7O0FBQ0FDLHdCQUFzQjtBQUV6QixDQXpCRCIsImZpbGUiOiIuL3Jlc291cmNlcy9qcy9zZXQtZWRpdG9yLWZsYXNoY2FyZC1tYW5hZ2VyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IERPTVB1cmlmeSBmcm9tICdkb21wdXJpZnknO1xuXG52YXIgbWFya2VkID0gcmVxdWlyZSgnbWFya2VkJyk7XG5cbnZhciBtYXJrZWRJbWFnZXMgPSByZXF1aXJlKCdtYXJrZWQtaW1hZ2VzJyk7XG5cbm1hcmtlZC51c2UobWFya2VkSW1hZ2VzKCkpO1xuXG5cbi8vIFRoaXMgZmlsZSBjb250YWlucyBhbGwgdGhlIEpTIGxvZ2ljIHRvIGludGVyYWN0IHdpdGggdGhlIHNldCBlZGl0b3IgZm9yXG4vLyBlZGl0aW5nIHRoZSBjb3VudCBvZiBmbGFzaGNhcmRzIGFuZCB0aGUgcG9zaXRpb25pbmcgb2YgdGhlIGZsYXNoY2FyZCBlZGl0b3IuXG5cbmxldCBlYXN5bWRlX3RleHRhcmVhcyA9IFtdO1xuXG5sZXQgZmxhc2hjYXJkX3Rvb2xiYXIgPSBbe1xuICAgICAgICBuYW1lOiBcImJvbGRcIixcbiAgICAgICAgYWN0aW9uOiBFYXN5TURFLnRvZ2dsZUJvbGQsXG4gICAgICAgIGNsYXNzTmFtZTogXCJtZGkgbWRpLTE4cHggbWRpLWZvcm1hdC1ib2xkXCIsXG4gICAgICAgIHRpdGxlOiBcIkJvbGRcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogXCJpdGFsaWNcIixcbiAgICAgICAgYWN0aW9uOiBFYXN5TURFLnRvZ2dsZUl0YWxpYyxcbiAgICAgICAgY2xhc3NOYW1lOiBcIm1kaSBtZGktMThweCBtZGktZm9ybWF0LWl0YWxpY1wiLFxuICAgICAgICB0aXRsZTogXCJJdGFsaWNcIixcbiAgICB9LFxuXG4gICAge1xuICAgICAgICBuYW1lOiBcImhlYWRpbmctc21hbGxlclwiLFxuICAgICAgICBhY3Rpb246IEVhc3lNREUudG9nZ2xlSGVhZGluZ1NtYWxsZXIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJtZGkgbWRpLTE4cHggbWRpLWZvcm1hdC1oZWFkZXItZGVjcmVhc2VcIixcbiAgICAgICAgdGl0bGU6IFwiU21hbGxlciBIZWFkaW5nXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwiaGVhZGluZy1iaWdnZXJcIixcbiAgICAgICAgYWN0aW9uOiBFYXN5TURFLnRvZ2dsZUhlYWRpbmdCaWdnZXIsXG4gICAgICAgIGNsYXNzTmFtZTogXCJtZGkgbWRpLTE4cHggbWRpLWZvcm1hdC1oZWFkZXItaW5jcmVhc2VcIixcbiAgICAgICAgdGl0bGU6IFwiQmlnZ2VyIEhlYWRpbmdcIixcbiAgICB9LFxuICAgIFwifFwiLFxuICAgIHtcbiAgICAgICAgbmFtZTogXCJob3Jpem9udGFsLXJ1bGVcIixcbiAgICAgICAgYWN0aW9uOiBFYXN5TURFLmRyYXdIb3Jpem9udGFsUnVsZSxcbiAgICAgICAgY2xhc3NOYW1lOiBcIm1kaSBtZGktMThweCBtZGktbWludXNcIixcbiAgICAgICAgdGl0bGU6IFwiSW5zZXJ0IEhvcml6b250YWwgTGluZVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcInF1b3RlXCIsXG4gICAgICAgIGFjdGlvbjogRWFzeU1ERS50b2dnbGVCbG9ja3F1b3RlLFxuICAgICAgICBjbGFzc05hbWU6IFwibWRpIG1kaS0xOHB4IG1kaS1mb3JtYXQtcXVvdGUtb3BlblwiLFxuICAgICAgICB0aXRsZTogXCJRdW90ZVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcInVub3JkZXJlZC1saXN0XCIsXG4gICAgICAgIGFjdGlvbjogRWFzeU1ERS50b2dnbGVVbm9yZGVyZWRMaXN0LFxuICAgICAgICBjbGFzc05hbWU6IFwibWRpIG1kaS0xOHB4IG1kaS1mb3JtYXQtbGlzdC1idWxsZXRlZFwiLFxuICAgICAgICB0aXRsZTogXCJHZW5lcmljIExpc3RcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogXCJvcmRlcmVkLWxpc3RcIixcbiAgICAgICAgYWN0aW9uOiBFYXN5TURFLnRvZ2dsZU9yZGVyZWRMaXN0LFxuICAgICAgICBjbGFzc05hbWU6IFwibWRpIG1kaS0xOHB4IG1kaS1mb3JtYXQtbGlzdC1udW1iZXJlZFwiLFxuICAgICAgICB0aXRsZTogXCJOdW1iZXJlZCBMaXN0XCIsXG4gICAgfSxcbiAgICB7XG4gICAgICAgIG5hbWU6IFwidGFibGVcIixcbiAgICAgICAgYWN0aW9uOiBFYXN5TURFLmRyYXdUYWJsZSxcbiAgICAgICAgY2xhc3NOYW1lOiBcIm1kaSBtZGktMThweCBtZGktdGFibGVcIixcbiAgICAgICAgdGl0bGU6IFwiSW5zZXJ0IFRhYmxlXCIsXG4gICAgfSxcbiAgICBcInxcIixcbiAgICB7XG4gICAgICAgIG5hbWU6IFwibGlua1wiLFxuICAgICAgICBhY3Rpb246IEVhc3lNREUuZHJhd0xpbmssXG4gICAgICAgIGNsYXNzTmFtZTogXCJtZGkgbWRpLTE4cHggbWRpLWxpbmtcIixcbiAgICAgICAgdGl0bGU6IFwiQ3JlYXRlIExpbmtcIixcbiAgICB9LFxuICAgIHtcbiAgICAgICAgbmFtZTogXCJpbWFnZVwiLFxuICAgICAgICBhY3Rpb246IEVhc3lNREUuZHJhd0ltYWdlLFxuICAgICAgICBjbGFzc05hbWU6IFwibWRpIG1kaS0xOHB4IG1kaS1pbWFnZS1hcmVhXCIsXG4gICAgICAgIHRpdGxlOiBcIkluc2VydCBJbWFnZVwiLFxuICAgIH0sXG4gICAge1xuICAgICAgICBuYW1lOiBcInByZXZpZXdcIixcbiAgICAgICAgYWN0aW9uOiBFYXN5TURFLnRvZ2dsZVByZXZpZXcsXG4gICAgICAgIG5vRGlzYWJsZTogdHJ1ZSxcbiAgICAgICAgY2xhc3NOYW1lOiBcIm1kaSBtZGktMThweCBtZGktZXllLW91dGxpbmVcIixcbiAgICAgICAgdGl0bGU6IFwiVG9nZ2xlIFByZXZpZXdcIixcbiAgICB9LFxuXTtcblxuLy8gVGhpcyBmdW5jdGlvbiB1cGRhdGVzIHRoZSBwYWdlIGFkZGluZyBuZXcgZWFzeU1ERSBlZGl0b3JzIHdoZW4gdGhlcmUgaXMgYSBuZWVkXG4vLyBmb3Igb25lLCBvdGhlcndpc2UgaXQgaG9wZWZ1bGx5IHNob3VsZG4ndCBydW4uIFRoZXJlIGlzIGEgbGlzdCB0aGF0IGNoZWNrc1xuLy8gdGhhdCBvbmUgaXMgYWxyZWFkeSBhbiBlYXN5TURFIGNhbGxlZCBlYXN5bWRlX3RleHRhcmVhcyBpdCB1c2VzLlxuXG4vLyBFc3NlbnRhaWxseTogQWRkcyBFYXN5TURFIGVkaXRvcnMgdG8gbmV3bHkgaW5zZXJ0ZWQgdGV4dGFyZWFzIHRvIGRvbS5cbmZ1bmN0aW9uIGZsYXNoY2FyZF9lYXN5TURFX3dhdGNoKCkge1xuICAgIGxldCBzZXRfZWRpdG9yX3BhcmVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2V0LWVkaXRvcnNcIik7XG4gICAgbGV0IGFsbF90ZXh0YXJlYXMgPSBzZXRfZWRpdG9yX3BhcmVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiZWFzeS1tYXJrZG93bi1lZGl0b3ItbmVlZGVkXCIpO1xuICAgIGZvciAobGV0IHRleHRhcmVhIG9mIGFsbF90ZXh0YXJlYXMpIHtcbiAgICAgICAgaWYgKCEoZWFzeW1kZV90ZXh0YXJlYXMuaW5kZXhPZih0ZXh0YXJlYS5pZCkgPj0gMCkpIHsgLy8gSWYgdGhlIGN1cnJlbnQgdGV4dGFyZWEgaXMgbm90IGluIHRoZSBsaXN0IG9mIGVhc3ltZGVfdGV4dGFyZWFzLlxuICAgICAgICAgICAgZWFzeW1kZV90ZXh0YXJlYXMucHVzaCh0ZXh0YXJlYS5pZCk7XG4gICAgICAgICAgICBuZXcgRWFzeU1ERSh7XG4gICAgICAgICAgICAgICAgYXV0b2ZvY3VzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGF1dG9Eb3dubG9hZEZvbnRBd2Vzb21lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0b29sYmFyOiBmbGFzaGNhcmRfdG9vbGJhcixcbiAgICAgICAgICAgICAgICBlbGVtZW50OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0ZXh0YXJlYS5pZCksXG4gICAgICAgICAgICAgICAgcHJldmlld1JlbmRlcjogZnVuY3Rpb24ocGxhaW5UZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXJrZWQoXCI8Y2VudGVyPlxcblwiICsgcGxhaW5UZXh0ICsgXCI8L2NlbnRlcj5cIik7IC8vIFJldHVybnMgSFRNTCBmcm9tIGEgY3VzdG9tIHBhcnNlclxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVuZGVyaW5nQ29uZmlnOiB7XG4gICAgICAgICAgICAgICAgICAgIHNhbml0aXplckZ1bmN0aW9uOiBmdW5jdGlvbihyZW5kZXJlZEhUTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBET01QdXJpZnkuc2FuaXRpemUocmVuZGVyZWRIVE1MKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuZnVuY3Rpb24gcmVtb3ZlX2ZsYXNoY2FyZF9ieV9pZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgICBpZiAoZWFzeW1kZV90ZXh0YXJlYXMubGVuZ3RoICE9IDIpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZmxhc2hjYXJkLVwiICsgaWRlbnRpZmllciArIFwiLWNvbnRhaW5lclwiKSkge1xuICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmbGFzaGNhcmQtXCIgKyBpZGVudGlmaWVyICsgXCItY29udGFpbmVyXCIpLnJlbW92ZSgpO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gZWFzeW1kZV90ZXh0YXJlYXMuaW5kZXhPZihcImZsYXNoY2FyZC1cIiArIGlkZW50aWZpZXIgKyBcIi1mcm9udFwiKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBlYXN5bWRlX3RleHRhcmVhcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZWFzeW1kZV90ZXh0YXJlYXMuaW5kZXhPZihcImZsYXNoY2FyZC1cIiArIGlkZW50aWZpZXIgKyBcIi1iYWNrXCIpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGVhc3ltZGVfdGV4dGFyZWFzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICAkKCcudG9hc3QtYm9keScpLnRleHQoXCJcIik7XG4gICAgICAgICQoJy50b2FzdC1ib2R5JykuYXBwZW5kKFwiWW91IGNhbm5vdCByZW1vdmUgdGhlIG9ubHkgZmxhc2hjYXJkIVwiKTtcbiAgICAgICAgJCgnLnRvYXN0JykudG9hc3QoJ3Nob3cnKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFkZF9mbGFzaGNhcmRfYnlfaWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gICAgaWYgKGlkZW50aWZpZXIgPiAwKSB7XG4gICAgICAgIGxldCBwcmV2aW91c19mbGFzaGNhcmQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImZsYXNoY2FyZC1cIiArIChpZGVudGlmaWVyKSArIFwiLWNvbnRhaW5lclwiKTtcbiAgICAgICAgbGV0IG5ld19jYXJkX2lkID0gaWRlbnRpZmllciArIDE7XG4gICAgICAgIGxldCBuZXdfZG9tX2NvZGUgPVxuICAgICAgICAgICAgXCI8ZGl2IGNsYXNzPVxcXCJmbGFzaGNhcmQtY29udGFpbmVyXFxcIiBpZD1cXFwiZmxhc2hjYXJkLVwiICsgbmV3X2NhcmRfaWQgKyBcIi1jb250YWluZXJcXFwiPjxocj48aDMgY2xhc3M9XFxcImZsYXNoY2FyZC10aXRsZS1mcm9udFxcXCI+Rmxhc2hjYXJkIFwiICsgbmV3X2NhcmRfaWQgKyBcIiAtIEZyb250PC9oMz48dGV4dGFyZWEgY2xhc3M9XFxcImVhc3ktbWFya2Rvd24tZWRpdG9yLW5lZWRlZCAgZmxhc2hjYXJkLWZyb250XFxcIiBtYXg9XFxcIjMwMFxcXCIgaWQ9XFxcImZsYXNoY2FyZC1cIiArIG5ld19jYXJkX2lkICsgXCItZnJvbnRcXFwiIG5hbWU9XFxcImZsYXNoY2FyZC1cIiArIG5ld19jYXJkX2lkICsgXCItZnJvbnRcXFwiPjwvdGV4dGFyZWE+PGgzIGNsYXNzPVxcXCJmbGFzaGNhcmQtdGl0bGUtYmFja1xcXCI+Rmxhc2hjYXJkIFwiICsgbmV3X2NhcmRfaWQgKyBcIiAtIEJhY2s8L2gzPjx0ZXh0YXJlYSBjbGFzcz1cXFwiZWFzeS1tYXJrZG93bi1lZGl0b3ItbmVlZGVkICBmbGFzaGNhcmQtYmFja1xcXCIgbWF4PVxcXCIzMDBcXFwiIGlkPVxcXCJmbGFzaGNhcmQtXCIgKyBuZXdfY2FyZF9pZCArIFwiLWJhY2tcXFwiIG5hbWU9XFxcImZsYXNoY2FyZC1cIiArIG5ld19jYXJkX2lkICsgXCItYmFja1xcXCI+PC90ZXh0YXJlYT48ZGl2IGNsYXNzPVxcXCJkLWZsZXgganVzdGlmeS1jb250ZW50LWNlbnRlclxcXCI+PGJ1dHRvbiB0eXBlPVxcXCJidXR0b25cXFwiIGNsYXNzPVxcXCJidG4gYnRuLW91dGxpbmUtaW5mbyBidG4tc20gcHktMSBmbGFzaGNhcmQtcmVtb3ZlLWJ1dHRvblxcXCIgaWQ9XFxcIlwiICsgbmV3X2NhcmRfaWQgKyBcIlxcXCI+UmVtb3ZlIEZsYXNoY2FyZCBcIiArIG5ld19jYXJkX2lkICsgXCI8L2J1dHRvbj48L2Rpdj48L2Rpdj5cIjtcbiAgICAgICAgcHJldmlvdXNfZmxhc2hjYXJkLmluc2VydEFkamFjZW50SFRNTCgnYWZ0ZXJlbmQnLCBuZXdfZG9tX2NvZGUpO1xuICAgICAgICByZWNlbnRseV9pbnNlcnRlZF9yZW1vdmVfYnV0dG9uID0gcHJldmlvdXNfZmxhc2hjYXJkLm5leHRTaWJsaW5nLnF1ZXJ5U2VsZWN0b3JBbGwoXCIuZmxhc2hjYXJkLXJlbW92ZS1idXR0b246bGFzdC1jaGlsZFwiKTtcbiAgICAgICAgZmxhc2hjYXJkX2Vhc3lNREVfd2F0Y2goKTtcblxuICAgICAgICByZWNlbnRseV9pbnNlcnRlZF9yZW1vdmVfYnV0dG9uWzBdLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgcmVtb3ZlX2ZsYXNoY2FyZF9ieV9pZGVudGlmaWVyKHRoaXMuaWQpO1xuICAgICAgICAgICAgb3JkZXJfd2F0Y2goKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHVwZGF0ZV9mbGFzaGNhcmRfY291bnQoKTtcbiAgICB9XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gbG9va3MgYXQgYW5kIGNvcnJlY3RzIGFueSBjaGFuZ2VzIHRvIHRoZSBsaXN0IG9mIGZsYXNoY2FyZHNcbi8vIGJlY2F1c2UgdGhlIHVzZXIgbWF5IHdpc2ggdG8gZGVsZXRlIGZsYXNoY2FyZHMgYXQgYW55IHRpbWUsIHRoaXMgZnVuY3Rpb25cbi8vIHVwZGF0ZXMgdGhlIGxpc3Qgc28gdGhhdCB0aGVyZSBpcyBhbHdheXMgYSBjb25zZWN1dGl2ZSBwcm9jZXNzIHdoZW4gdGhlXG4vLyBjYXJkcyBhcmUgc3VibWl0dGVkIGFuZCB1cGRhdGVkIGJ5IHRoZSB1c2VyLlxuZnVuY3Rpb24gb3JkZXJfd2F0Y2goKSB7XG4gICAgbGV0IGNhcmRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImZsYXNoY2FyZC1jb250YWluZXJcIik7XG4gICAgZWFzeW1kZV90ZXh0YXJlYXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjdXJyZW50X2NhcmRfaW5kZXggPSBpICsgMTtcbiAgICAgICAgY2FyZHNbaV0uc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJmbGFzaGNhcmQtXCIgKyBjdXJyZW50X2NhcmRfaW5kZXggKyBcIi1jb250YWluZXJcIik7XG5cbiAgICAgICAgbGV0IGZyb250X3RpdGxlID0gJChjYXJkc1tpXSkuZmluZChcIi5mbGFzaGNhcmQtdGl0bGUtZnJvbnRcIilbMF07XG4gICAgICAgIGxldCBmcm9udF90ZXh0YXJlYSA9ICQoY2FyZHNbaV0pLmZpbmQoXCIuZmxhc2hjYXJkLWZyb250XCIpWzBdO1xuICAgICAgICBsZXQgYmFja190aXRsZSA9ICQoY2FyZHNbaV0pLmZpbmQoXCIuZmxhc2hjYXJkLXRpdGxlLWJhY2tcIilbMF07XG4gICAgICAgIGxldCBiYWNrX3RleHRhcmVhID0gJChjYXJkc1tpXSkuZmluZChcIi5mbGFzaGNhcmQtYmFja1wiKVswXTtcbiAgICAgICAgbGV0IGRlbF9idXR0b24gPSAkKGNhcmRzW2ldKS5maW5kKFwiLmZsYXNoY2FyZC1yZW1vdmUtYnV0dG9uXCIpWzBdO1xuXG4gICAgICAgIGZyb250X3RpdGxlLmlubmVySFRNTCA9IFwiRmxhc2hjYXJkIFwiICsgY3VycmVudF9jYXJkX2luZGV4ICsgXCIgLSBGcm9udFwiO1xuICAgICAgICBiYWNrX3RpdGxlLmlubmVySFRNTCA9IFwiRmxhc2hjYXJkIFwiICsgY3VycmVudF9jYXJkX2luZGV4ICsgXCIgLSBCYWNrXCI7XG5cbiAgICAgICAgZnJvbnRfdGV4dGFyZWEuc2V0QXR0cmlidXRlKFwiaWRcIiwgXCJmbGFzaGNhcmQtXCIgKyBjdXJyZW50X2NhcmRfaW5kZXggKyBcIi1mcm9udFwiKTtcbiAgICAgICAgYmFja190ZXh0YXJlYS5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBcImZsYXNoY2FyZC1cIiArIGN1cnJlbnRfY2FyZF9pbmRleCArIFwiLWJhY2tcIik7XG5cbiAgICAgICAgZnJvbnRfdGV4dGFyZWEuc2V0QXR0cmlidXRlKFwibmFtZVwiLCBcImZsYXNoY2FyZC1cIiArIGN1cnJlbnRfY2FyZF9pbmRleCArIFwiLWZyb250XCIpO1xuICAgICAgICBiYWNrX3RleHRhcmVhLnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgXCJmbGFzaGNhcmQtXCIgKyBjdXJyZW50X2NhcmRfaW5kZXggKyBcIi1iYWNrXCIpO1xuXG4gICAgICAgIGRlbF9idXR0b24uc2V0QXR0cmlidXRlKFwiaWRcIiwgY3VycmVudF9jYXJkX2luZGV4KTtcbiAgICAgICAgZGVsX2J1dHRvbi5pbm5lckhUTUwgPSBcIlJlbW92ZSBGbGFzaGNhcmQgXCIgKyBjdXJyZW50X2NhcmRfaW5kZXg7XG5cbiAgICAgICAgLy8gVXBkYXRlIG1hc3RlciBsaXN0IG9mIHRleHRhcmVhcyBmb3IgYWRkIGFuZCByZW1vdmUgZnVuY3Rpb25zLlxuICAgICAgICBlYXN5bWRlX3RleHRhcmVhcy5wdXNoKFwiZmxhc2hjYXJkLVwiICsgY3VycmVudF9jYXJkX2luZGV4ICsgXCItZnJvbnRcIik7XG4gICAgICAgIGVhc3ltZGVfdGV4dGFyZWFzLnB1c2goXCJmbGFzaGNhcmQtXCIgKyBjdXJyZW50X2NhcmRfaW5kZXggKyBcIi1iYWNrXCIpO1xuICAgIH1cbiAgICAvLyBVcGRhdGUgQ291bnRcbiAgICB1cGRhdGVfZmxhc2hjYXJkX2NvdW50KCk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZV9mbGFzaGNhcmRfY291bnQoKSB7XG4gICAgbGV0IGNhcmRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImZsYXNoY2FyZC1jb250YWluZXJcIik7XG4gICAgJCgnLmZsYXNoY2FyZC1jb3VudCcpLmh0bWwoY2FyZHMubGVuZ3RoICsgXCIgZmxhc2hjYXJkcyBpbiBzZXQuXCIpO1xufVxuXG5cblxuXG4kKCdkb2N1bWVudCcpLnJlYWR5KGZ1bmN0aW9uKCkge1xuXG4gICAgJCgnLmZsYXNoY2FyZC1yZW1vdmUtYnV0dG9uJykuY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlbW92ZV9mbGFzaGNhcmRfYnlfaWRlbnRpZmllcih0aGlzLmlkKTtcbiAgICAgICAgb3JkZXJfd2F0Y2goKTtcbiAgICB9KTtcblxuICAgICQoJyNuZXctZmxhc2hjYXJkJykuY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgIGFkZF9mbGFzaGNhcmRfYnlfaWRlbnRpZmllcihlYXN5bWRlX3RleHRhcmVhcy5sZW5ndGggLyAyKTtcbiAgICAgICAgZmxhc2hjYXJkX2Vhc3lNREVfd2F0Y2goKTtcbiAgICB9KTtcblxuICAgICQoJyNzYXZlLWZsYXNoY2FyZHMnKS5jbGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2ZsYXNoY2FyZHMnKS5zdWJtaXQoKTtcbiAgICB9KTtcblxuICAgIC8vIEFkZCBlYXN5TURFIFRleHRBcmVhcyB0byBhbGwgYm94ZXMgdGhhdCBuZWVkIHRoZW0uXG4gICAgZmxhc2hjYXJkX2Vhc3lNREVfd2F0Y2goKTtcblxuICAgIC8vIEZpeCBhbnkgb3JkZXIgc2hlbmFuaWdhbnMuXG4gICAgb3JkZXJfd2F0Y2goKTtcblxuICAgIC8vIFNldCBmbGFzaGNhcmQgY291bnQgdG8gZmluaXNoLlxuICAgIHVwZGF0ZV9mbGFzaGNhcmRfY291bnQoKTtcblxufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/set-editor-flashcard-manager.js\n");

/***/ }),

/***/ 2:
/*!************************************************************!*\
  !*** multi ./resources/js/set-editor-flashcard-manager.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! C:\xampp\htdocs\resources\js\set-editor-flashcard-manager.js */"./resources/js/set-editor-flashcard-manager.js");


/***/ })

/******/ });